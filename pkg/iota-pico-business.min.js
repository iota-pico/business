!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("@iota-pico/data/dist/data/trits"),require("@iota-pico/data/dist/data/trytes"),require("@iota-pico/core/dist/helpers/arrayHelper"),require("@iota-pico/core/dist/helpers/objectHelper"),require("@iota-pico/crypto/dist/factories/spongeFactory"),require("@iota-pico/data/dist/data/address"),require("@iota-pico/data/dist/data/hash"),require("@iota-pico/crypto/dist/hash/iss"),require("@iota-pico/data/dist/data/bundle"),require("@iota-pico/data/dist/data/signatureMessageFragment"),require("@iota-pico/data/dist/data/tag"),require("@iota-pico/data/dist/data/transaction"),require("@iota-pico/core/dist/helpers/numberHelper"),require("@iota-pico/core/dist/services/timeService"),require("@iota-pico/data/dist/data/transfer"),require("@iota-pico/core/dist/error/coreError"),require("@iota-pico/data/dist/data/tryteNumber"),require("@iota-pico/core/dist/loggers/nullLogger"),require("@iota-pico/core/dist/services/backgroundTaskService"),require("@iota-pico/crypto/dist/helpers/transactionHelper"),require("@iota-pico/data/dist/data/addressSecurity"),require("@iota-pico/data/dist/data/input"),require("@iota-pico/crypto/dist/error/cryptoError")):"function"==typeof define&&define.amd?define("@iota-pico/business",["@iota-pico/data/dist/data/trits","@iota-pico/data/dist/data/trytes","@iota-pico/core/dist/helpers/arrayHelper","@iota-pico/core/dist/helpers/objectHelper","@iota-pico/crypto/dist/factories/spongeFactory","@iota-pico/data/dist/data/address","@iota-pico/data/dist/data/hash","@iota-pico/crypto/dist/hash/iss","@iota-pico/data/dist/data/bundle","@iota-pico/data/dist/data/signatureMessageFragment","@iota-pico/data/dist/data/tag","@iota-pico/data/dist/data/transaction","@iota-pico/core/dist/helpers/numberHelper","@iota-pico/core/dist/services/timeService","@iota-pico/data/dist/data/transfer","@iota-pico/core/dist/error/coreError","@iota-pico/data/dist/data/tryteNumber","@iota-pico/core/dist/loggers/nullLogger","@iota-pico/core/dist/services/backgroundTaskService","@iota-pico/crypto/dist/helpers/transactionHelper","@iota-pico/data/dist/data/addressSecurity","@iota-pico/data/dist/data/input","@iota-pico/crypto/dist/error/cryptoError"],e):"object"==typeof exports?exports["@iota-pico/business"]=e(require("@iota-pico/data/dist/data/trits"),require("@iota-pico/data/dist/data/trytes"),require("@iota-pico/core/dist/helpers/arrayHelper"),require("@iota-pico/core/dist/helpers/objectHelper"),require("@iota-pico/crypto/dist/factories/spongeFactory"),require("@iota-pico/data/dist/data/address"),require("@iota-pico/data/dist/data/hash"),require("@iota-pico/crypto/dist/hash/iss"),require("@iota-pico/data/dist/data/bundle"),require("@iota-pico/data/dist/data/signatureMessageFragment"),require("@iota-pico/data/dist/data/tag"),require("@iota-pico/data/dist/data/transaction"),require("@iota-pico/core/dist/helpers/numberHelper"),require("@iota-pico/core/dist/services/timeService"),require("@iota-pico/data/dist/data/transfer"),require("@iota-pico/core/dist/error/coreError"),require("@iota-pico/data/dist/data/tryteNumber"),require("@iota-pico/core/dist/loggers/nullLogger"),require("@iota-pico/core/dist/services/backgroundTaskService"),require("@iota-pico/crypto/dist/helpers/transactionHelper"),require("@iota-pico/data/dist/data/addressSecurity"),require("@iota-pico/data/dist/data/input"),require("@iota-pico/crypto/dist/error/cryptoError")):t.IotaPicoBusiness=e(t["@iota-pico/data/dist/data/trits"],t["@iota-pico/data/dist/data/trytes"],t["@iota-pico/core/dist/helpers/arrayHelper"],t["@iota-pico/core/dist/helpers/objectHelper"],t["@iota-pico/crypto/dist/factories/spongeFactory"],t["@iota-pico/data/dist/data/address"],t["@iota-pico/data/dist/data/hash"],t["@iota-pico/crypto/dist/hash/iss"],t["@iota-pico/data/dist/data/bundle"],t["@iota-pico/data/dist/data/signatureMessageFragment"],t["@iota-pico/data/dist/data/tag"],t["@iota-pico/data/dist/data/transaction"],t["@iota-pico/core/dist/helpers/numberHelper"],t["@iota-pico/core/dist/services/timeService"],t["@iota-pico/data/dist/data/transfer"],t["@iota-pico/core/dist/error/coreError"],t["@iota-pico/data/dist/data/tryteNumber"],t["@iota-pico/core/dist/loggers/nullLogger"],t["@iota-pico/core/dist/services/backgroundTaskService"],t["@iota-pico/crypto/dist/helpers/transactionHelper"],t["@iota-pico/data/dist/data/addressSecurity"],t["@iota-pico/data/dist/data/input"],t["@iota-pico/crypto/dist/error/cryptoError"])}("undefined"!=typeof self?self:this,function(t,e,r,i,o,n,s,a,c,u,h,f,y,d,l,p,T,g,m,w,b,S,_){return function(t){var e={};function r(i){if(e[i])return e[i].exports;var o=e[i]={i:i,l:!1,exports:{}};return t[i].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=t,r.c=e,r.d=function(t,e,i){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)r.d(i,o,function(e){return t[e]}.bind(null,o));return i},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=21)}([function(e,r){e.exports=t},function(t,r){t.exports=e},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(22);e.BusinessError=class extends i.CoreError{constructor(t,e,r){super(t,e,r),this.domain="Business"}}},function(t,e){t.exports=r},function(t,e){t.exports=i},function(t,e,r){"use strict";r.r(e),r.d(e,"__extends",function(){return o}),r.d(e,"__assign",function(){return n}),r.d(e,"__rest",function(){return s}),r.d(e,"__decorate",function(){return a}),r.d(e,"__param",function(){return c}),r.d(e,"__metadata",function(){return u}),r.d(e,"__awaiter",function(){return h}),r.d(e,"__generator",function(){return f}),r.d(e,"__exportStar",function(){return y}),r.d(e,"__values",function(){return d}),r.d(e,"__read",function(){return l}),r.d(e,"__spread",function(){return p}),r.d(e,"__await",function(){return T}),r.d(e,"__asyncGenerator",function(){return g}),r.d(e,"__asyncDelegator",function(){return m}),r.d(e,"__asyncValues",function(){return w}),r.d(e,"__makeTemplateObject",function(){return b}),r.d(e,"__importStar",function(){return S}),r.d(e,"__importDefault",function(){return _});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var i=function(t,e){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)e.hasOwnProperty(r)&&(t[r]=e[r])})(t,e)};function o(t,e){function r(){this.constructor=t}i(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}var n=function(){return(n=Object.assign||function(t){for(var e,r=1,i=arguments.length;r<i;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t}).apply(this,arguments)};function s(t,e){var r={};for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.indexOf(i)<0&&(r[i]=t[i]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(i=Object.getOwnPropertySymbols(t);o<i.length;o++)e.indexOf(i[o])<0&&(r[i[o]]=t[i[o]])}return r}function a(t,e,r,i){var o,n=arguments.length,s=n<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(o=t[a])&&(s=(n<3?o(s):n>3?o(e,r,s):o(e,r))||s);return n>3&&s&&Object.defineProperty(e,r,s),s}function c(t,e){return function(r,i){e(r,i,t)}}function u(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)}function h(t,e,r,i){return new(r||(r=Promise))(function(o,n){function s(t){try{c(i.next(t))}catch(t){n(t)}}function a(t){try{c(i.throw(t))}catch(t){n(t)}}function c(t){t.done?o(t.value):new r(function(e){e(t.value)}).then(s,a)}c((i=i.apply(t,e||[])).next())})}function f(t,e){var r,i,o,n,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return n={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(n[Symbol.iterator]=function(){return this}),n;function a(n){return function(a){return function(n){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,i&&(o=2&n[0]?i.return:n[0]?i.throw||((o=i.return)&&o.call(i),0):i.next)&&!(o=o.call(i,n[1])).done)return o;switch(i=0,o&&(n=[2&n[0],o.value]),n[0]){case 0:case 1:o=n;break;case 4:return s.label++,{value:n[1],done:!1};case 5:s.label++,i=n[1],n=[0];continue;case 7:n=s.ops.pop(),s.trys.pop();continue;default:if(!(o=(o=s.trys).length>0&&o[o.length-1])&&(6===n[0]||2===n[0])){s=0;continue}if(3===n[0]&&(!o||n[1]>o[0]&&n[1]<o[3])){s.label=n[1];break}if(6===n[0]&&s.label<o[1]){s.label=o[1],o=n;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(n);break}o[2]&&s.ops.pop(),s.trys.pop();continue}n=e.call(t,s)}catch(t){n=[6,t],i=0}finally{r=o=0}if(5&n[0])throw n[1];return{value:n[0]?n[1]:void 0,done:!0}}([n,a])}}}function y(t,e){for(var r in t)e.hasOwnProperty(r)||(e[r]=t[r])}function d(t){var e="function"==typeof Symbol&&t[Symbol.iterator],r=0;return e?e.call(t):{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}}}function l(t,e){var r="function"==typeof Symbol&&t[Symbol.iterator];if(!r)return t;var i,o,n=r.call(t),s=[];try{for(;(void 0===e||e-- >0)&&!(i=n.next()).done;)s.push(i.value)}catch(t){o={error:t}}finally{try{i&&!i.done&&(r=n.return)&&r.call(n)}finally{if(o)throw o.error}}return s}function p(){for(var t=[],e=0;e<arguments.length;e++)t=t.concat(l(arguments[e]));return t}function T(t){return this instanceof T?(this.v=t,this):new T(t)}function g(t,e,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,o=r.apply(t,e||[]),n=[];return i={},s("next"),s("throw"),s("return"),i[Symbol.asyncIterator]=function(){return this},i;function s(t){o[t]&&(i[t]=function(e){return new Promise(function(r,i){n.push([t,e,r,i])>1||a(t,e)})})}function a(t,e){try{(r=o[t](e)).value instanceof T?Promise.resolve(r.value.v).then(c,u):h(n[0][2],r)}catch(t){h(n[0][3],t)}var r}function c(t){a("next",t)}function u(t){a("throw",t)}function h(t,e){t(e),n.shift(),n.length&&a(n[0][0],n[0][1])}}function m(t){var e,r;return e={},i("next"),i("throw",function(t){throw t}),i("return"),e[Symbol.iterator]=function(){return this},e;function i(i,o){e[i]=t[i]?function(e){return(r=!r)?{value:T(t[i](e)),done:"return"===i}:o?o(e):e}:o}}function w(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,r=t[Symbol.asyncIterator];return r?r.call(t):(t=d(t),e={},i("next"),i("throw"),i("return"),e[Symbol.asyncIterator]=function(){return this},e);function i(r){e[r]=t[r]&&function(e){return new Promise(function(i,o){(function(t,e,r,i){Promise.resolve(i).then(function(e){t({value:e,done:r})},e)})(i,o,(e=t[r](e)).done,e.value)})}}}function b(t,e){return Object.defineProperty?Object.defineProperty(t,"raw",{value:e}):t.raw=e,t}function S(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)Object.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e.default=t,e}function _(t){return t&&t.__esModule?t:{default:t}}},function(t,e){t.exports=o},function(t,e){t.exports=n},function(t,e){t.exports=s},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(3),o=r(4),n=r(6),s=r(10),a=r(7),c=r(11),u=r(8),h=r(12),f=r(13),y=r(14),d=r(0),l=r(23),p=r(1),T=r(17);class g{static isValid(t){let e=!1;if(o.ObjectHelper.isType(t,c.Bundle)&&i.ArrayHelper.isTyped(t.transactions,y.Transaction)){let r=0;const i=n.SpongeFactory.instance().create("kerl");i.initialize();const o=[];e=!0;for(let n=0;n<t.transactions.length&&e;n++){const s=t.transactions[n];if(r+=s.value.toNumber(),s.currentIndex.toNumber()!==n)e=!1;else{const e=s.toTrytes(),r=d.Trits.fromTrytes(e.sub(h.SignatureMessageFragment.LENGTH,162)).toArray();if(i.absorb(r,0,r.length),s.value.toNumber()<0){const e={address:s.address,signatureMessageFragments:[s.signatureMessageFragment]};for(let r=n;r<t.transactions.length-1;r++){const i=t.transactions[r+1];i.address.toTrytes().toString()===s.address.toTrytes().toString()&&0===i.value.toNumber()&&e.signatureMessageFragments.push(i.signatureMessageFragment)}o.push(e)}}}if(0!==r)e=!1;else{const r=new Int8Array(i.getConstant("HASH_LENGTH"));i.squeeze(r,0,r.length);const n=d.Trits.fromArray(r).toTrytes().toString(),a=t.transactions[0].bundle;if(n!==a.toTrytes().toString())e=!1;else if(t.transactions[t.transactions.length-1].currentIndex.toNumber()!==t.transactions[t.transactions.length-1].lastIndex.toNumber())e=!1;else for(let t=0;t<o.length&&e;t++){s.ISS.validateSignatures(o[t].address,o[t].signatureMessageFragments,a)||(e=!1)}}}return e}static validateSignatures(t,e){let r=!1;if(o.ObjectHelper.isType(t,c.Bundle)&&i.ArrayHelper.isTyped(t.transactions,y.Transaction)&&o.ObjectHelper.isType(e,a.Address)){let i;const o=[],n=e.toTrytes().toString();for(let e=0;e<t.transactions.length;e++)if(t.transactions[e].address.toTrytes().toString()===n){if(i=t.transactions[e].bundle,t.transactions[e].signatureMessageFragment.toTrytes().toString()===h.SignatureMessageFragment.EMPTY.toTrytes().toString())break;o.push(t.transactions[e].signatureMessageFragment)}i&&(r=s.ISS.validateSignatures(e,o,i))}return r}static prepareBundle(t,e){const r=new c.Bundle;let i,o=0;const n=[];for(let s=0;s<e.length;s++){let a=1;const c=e[s].message.toString();if(c.length>h.SignatureMessageFragment.LENGTH){a+=Math.floor(c.length/h.SignatureMessageFragment.LENGTH);let t=c;for(;t;){let e=t.slice(0,h.SignatureMessageFragment.LENGTH);t=t.slice(h.SignatureMessageFragment.LENGTH,t.length);for(let t=0;e.length<h.SignatureMessageFragment.LENGTH;t++)e+="9";n.push(h.SignatureMessageFragment.fromTrytes(p.Trytes.fromString(e)))}}else{let t="";c&&(t=c.slice(0,h.SignatureMessageFragment.LENGTH));for(let e=0;t.length<h.SignatureMessageFragment.LENGTH;e++)t+="9";n.push(h.SignatureMessageFragment.fromTrytes(p.Trytes.fromString(t)))}const u=Math.floor(t.msSinceEpoch()/1e3);i=e[s].tag,r.addTransactions(a,e[s].address,e[s].value,e[s].tag,u),o+=e[s].value}return{bundle:r,totalValue:o,lastTag:i,signatureMessageFragments:n}}static signInputs(t,e,r,i,o,n){g.finalizeBundle(e),e.addSignatureMessageFragments(i);for(let i=0;i<e.transactions.length;i++)if(e.transactions[i].value.toNumber()<0){const n=e.transactions[i].address.toTrytes().toString();let a,c;for(let t=0;t<o.length;t++)if(o[t].address.toTrytes().toString()===n){a=o[t].keyIndex,c=o[t].security?o[t].security:r.security;break}const u=s.ISS.key(t,a,c);g.signTransactions(e,i,0,u,n,c)}if(n){new T.HmacCurl(r.hmacKey).addHMAC(e)}}static signTransactions(t,e,r,i,o,n){const a=t.transactions[e].bundle,c=s.ISS.normalizedBundle(a),u=[];for(let t=0;t<3;t++)u[t]=c.slice(27*t,27*(t+1));const f=i.slice(0,6561),y=u[r],l=s.ISS.signatureMessageFragment(y,f);t.transactions[e].signatureMessageFragment=h.SignatureMessageFragment.fromTrytes(d.Trits.fromArray(l).toTrytes());for(let r=1;r<n;r++)if(t.transactions[e+r].address.toTrytes().toString()===o&&0===t.transactions[e+r].value.toNumber()){const o=i.slice(6561*r,6561*(r+1)),n=u[r],a=s.ISS.signatureMessageFragment(n,o);t.transactions[e+r].signatureMessageFragment=h.SignatureMessageFragment.fromTrytes(d.Trits.fromArray(a).toTrytes())}}static finalizeBundle(t){if(t.transactions.length>0){let e=!1;for(;!e;){const r=n.SpongeFactory.instance().create("kerl");r.initialize();for(let e=0;e<t.transactions.length;e++){t.transactions[e].currentIndex=l.TryteNumber.fromNumber(e),t.transactions[e].lastIndex=l.TryteNumber.fromNumber(t.transactions.length-1);const i=d.Trits.fromTrytes(p.Trytes.fromString(t.transactions[e].address.toTrytes().toString()+t.transactions[e].value.toTrytes().toString()+y.Transaction.CHECK_VALUE+t.transactions[e].obsoleteTag.toTrytes().toString()+t.transactions[e].timestamp.toTrytes().toString()+t.transactions[e].currentIndex.toTrytes().toString()+t.transactions[e].lastIndex.toTrytes().toString())).toArray();r.absorb(i,0,i.length)}const i=new Int8Array(r.getConstant("HASH_LENGTH"));r.squeeze(i,0,i.length);const o=u.Hash.fromTrytes(d.Trits.fromArray(i).toTrytes());for(let e=0;e<t.transactions.length;e++)t.transactions[e].bundle=o;if(-1!==s.ISS.normalizedBundle(o).indexOf(13)){const e=d.Trits.add(d.Trits.fromTrytes(t.transactions[0].obsoleteTag.toTrytes()),d.Trits.fromNumberArray([1]));t.transactions[0].obsoleteTag=f.Tag.fromTrytes(e.toTrytes())}else e=!0}}}}g.NUMBER_OF_FRAGMENT_CHUNKS=27,e.BundleHelper=g},function(t,e){t.exports=a},function(t,e){t.exports=c},function(t,e){t.exports=u},function(t,e){t.exports=h},function(t,e){t.exports=f},function(t,e){t.exports=y},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(6),o=r(0);e.AddressHelper=class{static createChecksum(t,e){const r=i.SpongeFactory.instance().create("kerl");r.initialize(),r.absorb(t,0,t.length);const n=new Int8Array(r.getConstant("HASH_LENGTH"));return r.squeeze(n,0,n.length),o.Trits.fromArray(n).toTrytes().toString().substring(81-e,81)}}},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(6),o=r(12),n=r(0),s=r(1);class a{constructor(t){this._keyTrits=n.Trits.fromTrytes(t).toArray()}addHMAC(t){const e=i.SpongeFactory.instance().create("curl",a.HMAC_ROUNDS),r=e.getConstant("HASH_LENGTH"),c=this._keyTrits;for(let i=0;i<t.transactions.length;i++)if(t.transactions[i].value.toNumber()>0){const a=n.Trits.fromTrytes(t.transactions[i].bundle.toTrytes()).toArray(),u=new Int8Array(r);e.initialize(),e.absorb(c,0,c.length),e.absorb(a,0,a.length),e.squeeze(u,0,u.length);const h=n.Trits.fromArray(u).toTrytes().toString(),f=t.transactions[i].signatureMessageFragment.toTrytes().toString().substring(81,o.SignatureMessageFragment.LENGTH);t.transactions[i].signatureMessageFragment=o.SignatureMessageFragment.fromTrytes(s.Trytes.fromString(h+f))}}}a.HMAC_ROUNDS=27,e.HmacCurl=a},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(3),o=r(4),n=r(6),s=r(7),a=r(0),c=r(1),u=r(2);e.MultiSigAddress=class{constructor(){this._kerl=n.SpongeFactory.instance().create("kerl"),this._hashLength=this._kerl.getConstant("HASH_LENGTH"),this._kerl.initialize()}absorb(t){if(!i.ArrayHelper.isTyped(t,c.Trytes))throw new u.BusinessError("The digests should be an array of type Trytes");for(let e=0;e<t.length;e++){const r=a.Trits.fromTrytes(t[e]).toArray();this._kerl.absorb(r,0,r.length)}}finalize(t){o.ObjectHelper.isEmpty(t)||this.absorb(t);const e=new Int8Array(this._hashLength);return this._kerl.squeeze(e,0,e.length),s.Address.fromTrytes(a.Trits.fromArray(e).toTrytes())}}},function(t,e){t.exports=d},function(t,e){t.exports=l},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(5);i.__exportStar(r(2),e),i.__exportStar(r(16),e),i.__exportStar(r(9),e),i.__exportStar(r(18),e),i.__exportStar(r(24),e),i.__exportStar(r(17),e),i.__exportStar(r(25),e)},function(t,e){t.exports=p},function(t,e){t.exports=T},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(5),o=r(3),n=r(15),s=r(4),a=r(19),c=r(10),u=r(7),h=r(11),f=r(8),y=r(12),d=r(13),l=r(14),p=r(20),T=r(0),g=r(1),m=r(2),w=r(9),b=r(18);e.MultiSigClient=class{constructor(t,e=new a.TimeService){this._apiClient=t,this._timeService=e}static getKey(t,e,r){if(!s.ObjectHelper.isType(t,f.Hash))throw new m.BusinessError("The seed should be an object of type Hash");if(!n.NumberHelper.isInteger(e)||e<0)throw new m.BusinessError("The index should be a number >= 0");if(!n.NumberHelper.isInteger(r)||r<1||r>3)throw new m.BusinessError("The security must be between 1 and 3",{security:r});return T.Trits.fromArray(c.ISS.key(t,e,r)).toTrytes()}static getDigest(t,e,r){if(!s.ObjectHelper.isType(t,f.Hash))throw new m.BusinessError("The seed should be an object of type Hash");if(!n.NumberHelper.isInteger(e)||e<0)throw new m.BusinessError("The index should be a number >= 0");if(!n.NumberHelper.isInteger(r)||r<1||r>3)throw new m.BusinessError("The security must be between 1 and 3",{security:r});const i=c.ISS.key(t,e,r);return T.Trits.fromArray(c.ISS.digests(i)).toTrytes()}static validateAddress(t,e){if(!s.ObjectHelper.isType(t,u.Address))throw new m.BusinessError("The address should be an object of type Address");if(!o.ArrayHelper.isTyped(e,g.Trytes))throw new m.BusinessError("The digests should be an array of type Trytes");return t.toTrytes().toString()===(new b.MultiSigAddress).finalize(e).toTrytes().toString()}static addSignature(t,e,r){if(!s.ObjectHelper.isType(t,h.Bundle))throw new m.BusinessError("The bundle should be an object of type Bundle");if(!o.ArrayHelper.isTyped(t.transactions,l.Transaction))throw new m.BusinessError("The bundle.transactions should be an array of type Transaction");if(!s.ObjectHelper.isType(e,u.Address))throw new m.BusinessError("The address should be an object of type Address");if(!s.ObjectHelper.isType(r,g.Trytes))throw new m.BusinessError("The key should be an object of type Trytes");const i=T.Trits.fromTrytes(r).toArray(),n=i.length/3/2187;let a=0;const c=e.toTrytes().toString();for(let e=0;e<t.transactions.length;e++)if(t.transactions[e].address.toTrytes().toString()===c){if(t.transactions[e].signatureMessageFragment.toTrytes().toString()===y.SignatureMessageFragment.EMPTY.toTrytes().toString()){w.BundleHelper.signTransactions(t,e,a%3,i,c,n);break}a++}}prepareTransfer(t,e,r,a,c){return i.__awaiter(this,void 0,void 0,function*(){if(!s.ObjectHelper.isType(t,u.Address))throw new m.BusinessError("The address should be an object of type Address");if(!n.NumberHelper.isInteger(e)||e<0)throw new m.BusinessError("The securitySum should be a number >= 0");if(!n.NumberHelper.isInteger(r)||r<0)throw new m.BusinessError("The balance should be a number >= 0");if(!o.ArrayHelper.isTyped(a,p.Transfer))throw new m.BusinessError("The transfers should be an array of type Transfer");if(!s.ObjectHelper.isEmpty(c)&&!s.ObjectHelper.isType(c,u.Address))throw new m.BusinessError("The remainderAddress should be an object of type Address");const i=g.Trytes.fromString("");a.forEach(t=>{t.message=t.message?t.message:i,t.tag=t.tag||d.Tag.EMPTY});const h=w.BundleHelper.prepareBundle(this._timeService,a);if(0===h.totalValue)throw new m.BusinessError("The total transfer value is 0, the transfer does not require a signature");{let i=r;if(0===i){const e={addresses:[t.toTrytes().toString()],threshold:100},r=yield this._apiClient.getBalances(e);i=parseInt(r.balances[0],10)}if(h.totalValue>i)throw new m.BusinessError("Not enough balance to satisfy the value",{totalValue:h.totalValue,totalBalance:i});const o=Math.floor(this._timeService.msSinceEpoch()/1e3);if(h.bundle.addTransactions(e,t,-i,h.lastTag,o),i>h.totalValue){if(s.ObjectHelper.isEmpty(c))throw new m.BusinessError("Transfer has remainder but no remainder address was provided");h.bundle.addTransactions(1,c,i-h.totalValue,h.lastTag,o)}w.BundleHelper.finalizeBundle(h.bundle),h.bundle.addSignatureMessageFragments(h.signatureMessageFragments)}return h.bundle})}}},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(5),o=r(3),n=r(15),s=r(4),a=r(26),c=r(27),u=r(19),h=r(10),f=r(28),y=r(7),d=r(29),l=r(11),p=r(8),T=r(30),g=r(13),m=r(14),w=r(20),b=r(0),S=r(1),_=r(2),v=r(16),H=r(9),E=r(31);class j{constructor(t,e,r,i,o){if(s.ObjectHelper.isEmpty(t))throw new _.BusinessError("The apiClient must not be empty");this._apiClient=t,this._proofOfWork=e||new E.ProofOfWorkApi(t),this._timeService=r||new u.TimeService,this._backgroundTaskService=i||new c.BackgroundTaskService,this._logger=o||new a.NullLogger}getTransactionsInProgress(){return i.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::getTransactionsInProgress");const t=yield this._apiClient.getTips();if(t&&t.hashes){const e=t.hashes.map(t=>p.Hash.fromTrytes(S.Trytes.fromString(t)));return this._logger.info("<=== TransactionClient::getTransactionsInProgress",e),e}return this._logger.info("<=== TransactionClient::getTransactionsInProgress",[]),[]})}findTransactions(t,e,r,n){return i.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::findTransactions",t,e,r,n);const i=null!=t&&t.length>0,s=null!=e&&e.length>0,a=null!=r&&r.length>0,c=null!=n&&n.length>0;if(i&&!o.ArrayHelper.isTyped(t,p.Hash))throw new _.BusinessError("The bundles must be an array of type Hash");if(s&&!o.ArrayHelper.isTyped(e,y.Address))throw new _.BusinessError("The addresses must be an array of type Address");if(a&&!o.ArrayHelper.isTyped(r,g.Tag))throw new _.BusinessError("The tags must be an array of type Tag");if(c&&!o.ArrayHelper.isTyped(n,p.Hash))throw new _.BusinessError("The approvees must be an array of type Hash");if(!(i||s||a||c))throw new _.BusinessError("You must provide bundles, addresses, tags or approvees");const u={bundles:i?t.map(t=>t.toTrytes().toString()):void 0,addresses:s?e.map(t=>t.toTrytes().toString()):void 0,tags:a?r.map(t=>t.toTrytes().toString()):void 0,approvees:c?n.map(t=>t.toTrytes().toString()):void 0},h=yield this._apiClient.findTransactions(u);if(h&&h.hashes){const t=h.hashes.map(t=>p.Hash.fromTrytes(S.Trytes.fromString(t)));return this._logger.info("<=== TransactionClient::findTransactions",t),t}return this._logger.info("<=== TransactionClient::findTransactions",[]),[]})}getTransactionsObjects(t){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getTransactionsObjects",t),!o.ArrayHelper.isTyped(t,p.Hash))throw new _.BusinessError("The transactionHashes must be an array of type Hash");const e={hashes:t.map(t=>t.toTrytes().toString())},r=yield this._apiClient.getTrytes(e);if(r&&r.trytes){const t=r.trytes.map(t=>m.Transaction.fromTrytes(S.Trytes.fromString(t)));return this._logger.info("<=== TransactionClient::getTransactionsObjects",t),t}return this._logger.info("<=== TransactionClient::getTransactionsObjects",[]),[]})}getLatestInclusion(t){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::transactionHashes"),!o.ArrayHelper.isTyped(t,p.Hash))throw new _.BusinessError("The transactionHashes must be an array of type Hash");const e=yield this._apiClient.getNodeInfo();if(e&&n.NumberHelper.isInteger(e.latestSolidSubtangleMilestone)){const r={transactions:t.map(t=>t.toTrytes().toString()),tips:[e.latestSolidSubtangleMilestone]},i=yield this._apiClient.getInclusionStates(r);return i&&i.states?(this._logger.info("<=== TransactionClient::transactionHashes",i.states),i.states):(this._logger.info("<=== TransactionClient::transactionHashes",[]),[])}throw new _.BusinessError("The node could not provide the latestSolidSubtangleMilestone")})}getNewAddress(t,e,r,o,a){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getNewAddress",t,e,r,o,a),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The seed must be of type Hash");if(!s.ObjectHelper.isEmpty(e)&&!s.ObjectHelper.isType(e,Number))throw new _.BusinessError("The startIndex must be an integer",{startIndex:e});const i=e||0;if(i<0)throw new _.BusinessError("The startIndex must be >= 0",{localStartIndex:i});const c=n.NumberHelper.isInteger(r),u=a||d.AddressSecurity.medium;let h;if(c){if(!n.NumberHelper.isInteger(r)||r<0)throw new _.BusinessError("The endIndex must be a number >= 0",{endIndex:r});const i=r-e+1;if(i<=0||i>j.MAX_INPUTS)throw new _.BusinessError(`The total must be > 0 and <= ${j.MAX_INPUTS}`,{total:i});h=yield this.getAddressesByIndex(t,e,r,o,u)}else h=yield this.getAddressesToUnused(t,e,o,u);return this._logger.info("<=== TransactionClient::getNewAddress",h),h})}getAddressesByIndex(t,e,r,o,a){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getAddressesByIndex",t,e,r,o,a),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The seed must be of type Hash");if(!n.NumberHelper.isInteger(e)||e<0)throw new _.BusinessError("The startIndex must be a number >= 0",{startIndex:e});if(!n.NumberHelper.isInteger(r)||r<0)throw new _.BusinessError("The endIndex must be a number >= 0",{endIndex:r});const i=r-e+1;if(i<=0||i>j.MAX_INPUTS)throw new _.BusinessError(`The total must be > 0 and <= ${j.MAX_INPUTS}`,{total:i});if(!n.NumberHelper.isInteger(a)||a<1||a>3)throw new _.BusinessError("The security must be between 1 and 3",{security:a});const c=[];for(let r=0;r<i;r++)c.push(this.generateAddress(t,e+r,a,o));return this._logger.info("<=== TransactionClient::getAddressesByIndex",c),Promise.resolve(c)})}getAddressesToUnused(t,e,r,o){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getAddressesToUnused",t,e,r,o),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The seed must be of type Hash");if(!n.NumberHelper.isInteger(e)||e<0)throw new _.BusinessError("The startIndex must be a number >= 0",{startIndex:e});if(!n.NumberHelper.isInteger(o)||o<1||o>3)throw new _.BusinessError("The security must be between 1 and 3",{security:o});let i,a=e;const c=[];do{const e=this.generateAddress(t,a++,o,r);c.push(e);const n=e.toTrytes().toString(),s={addresses:[n]},u=yield this._apiClient.wereAddressesSpentFrom(s);if(!(i=!!(u&&u.states&&u.states.length>0)&&u.states[0])){const t={addresses:[n]},e=yield this._apiClient.findTransactions(t);i=e&&e.hashes&&e.hashes.length>0}}while(i);return this._logger.info("<=== TransactionClient::getAddressesToUnused",c),Promise.resolve(c)})}getInputs(t,e,r,o,a){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getInputs",t,e,r,o,a),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The seed must be of type Hash");if(!n.NumberHelper.isInteger(e)||e<0)throw new _.BusinessError("The startIndex must be a number >= 0",{startIndex:e});if(!n.NumberHelper.isInteger(o)||o<1||o>3)throw new _.BusinessError("The security must be between 1 and 3",{security:o});if(!n.NumberHelper.isInteger(a)||a<0)throw new _.BusinessError("The totalRequired must be >= 0",{totalRequired:a});const i=yield this.getNewAddress(t,e,r,!1,o),c={addresses:i.map(t=>t.toTrytes().toString()),threshold:100},u=yield this._apiClient.getBalances(c),h=[];let f=0;if(u)for(let t=0;t<i.length;t++){const r=parseInt(u.balances[t],10);if(r>0&&(h.push(T.Input.fromParams(i[t],o,e+t,r)),f+=r,a>0&&f>=a))break}const y={inputs:h,totalBalance:f};if(this._logger.info("<=== TransactionClient::getInputs",y),a>0&&f<a)throw new _.BusinessError("Not enough combined balance in the addresses to satisfy the total required",{totalRequired:a,totalBalance:f});return y})}prepareTransfers(t,e,r){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::prepareTransfers",t,e,r),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The seed must be of type Hash");if(!o.ArrayHelper.isTyped(e,w.Transfer))throw new _.BusinessError("The transfers must be an array of Transfer objects");const i=r||{};i.security=i.security||d.AddressSecurity.medium;const n=S.Trytes.fromString(""),a=!s.ObjectHelper.isEmpty(i.hmacKey);let c=!1;e.forEach(t=>{t.message=t.message?t.message:n,t.tag=t.tag||g.Tag.EMPTY,a&&t.value>0&&(t.message=S.Trytes.fromString(j.NULL_HASH_TRYTES+t.message.toString()),c=!0)});const u=H.BundleHelper.prepareBundle(this._timeService,e),h=u.bundle,f=u.lastTag,y=u.totalValue,l=u.signatureMessageFragments;if(y>0)if(i.inputs){const e={addresses:i.inputs.map(t=>t.address.toTrytes().toString()),threshold:100},r=yield this._apiClient.getBalances(e),o=[];let n=0;for(let t=0;t<r.balances.length;t++){const e=parseInt(r.balances[t],10);if(e>0&&(n+=e,i.inputs[t].balance=e,o.push(i.inputs[t]),n>=y))break}if(y>n)throw new _.BusinessError("Not enough balance in the input addresses to satisfy the total for the transfer");yield this.addRemainder(t,h,i,o,l,y,f,c)}else{const e=yield this.getInputs(t,0,void 0,i.security,y);yield this.addRemainder(t,h,i,e.inputs,l,y,f,c)}else H.BundleHelper.finalizeBundle(h),h.addSignatureMessageFragments(l);return h.transactions=h.transactions.reverse(),this._logger.info("<=== TransactionClient::prepareTransfers",h),h})}attachToTangle(t,e,r,a){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::attachToTangle",t,e,r,a),!s.ObjectHelper.isType(t,l.Bundle))throw new _.BusinessError("The bundle must be an array of type Bundle");if(!o.ArrayHelper.isTyped(t.transactions,m.Transaction))throw new _.BusinessError("The bundle.transactions must be an array of type Transaction");if(!n.NumberHelper.isInteger(e)||e<=0)throw new _.BusinessError("The depth must be a number > 0",{depth:e});if(!n.NumberHelper.isInteger(r)||r<=0)throw new _.BusinessError("The minWeightMagnitude must be a number > 0",{minWeightMagnitude:r});const i={depth:e,reference:a?a.toTrytes().toString():void 0},c=yield this._apiClient.getTransactionsToApprove(i),u=(yield this._proofOfWork.pow(p.Hash.fromTrytes(S.Trytes.fromString(c.trunkTransaction)),p.Hash.fromTrytes(S.Trytes.fromString(c.branchTransaction)),t.transactions.map(t=>t.toTrytes()),r)).map(t=>m.Transaction.fromTrytes(t)),h=new l.Bundle;return h.transactions=u,this._logger.info("<=== TransactionClient::attachToTangle",h),h})}sendTransactions(t,e,r,o){return i.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::sendTransactions",t,e,r,o);const i=yield this.attachToTangle(t,e,r,o),n={trytes:i.transactions.map(t=>t.toTrytes().toString())};yield this._apiClient.storeTransactions(n);const s={trytes:n.trytes};return yield this._apiClient.broadcastTransactions(s),this._logger.info("<=== TransactionClient::sendTransactions",i),i})}sendTransfer(t,e,r,o,n,s){return i.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::sendTransfer",t,e,r,o,n,s);const i=yield this.prepareTransfers(t,o,n),a=yield this.sendTransactions(i,e,r,s);return this._logger.info("<=== TransactionClient::sendTransfer",a),a})}isPromotable(t){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::isPromotable",t),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The transactionTail must be an object of type Hash");const e={tails:[t.toTrytes().toString()]},r=yield this._apiClient.checkConsistency(e);return this._logger.info("<=== TransactionClient::isPromotable",r.state),r.state})}isReattachable(t){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::isReattachable",t),!o.ArrayHelper.isTyped(t,y.Address))throw new _.BusinessError("The addresses must be an object of type Address");const e={};for(let r=0;r<t.length;r++){const i=t[r].toTrytes().toString();e[i]=[]}const r=yield this.findTransactionObjects(void 0,t),i=[];let n;if(r.forEach(t=>{if(t.value.toNumber()<0){const r=t.address,o=f.TransactionHelper.hash(t);e[r.toTrytes().toString()].push(o),i.push(o)}}),i.length>0){const r=yield this.getLatestInclusion(i);n=t.map(t=>{let o=!0;const n=e[t.toTrytes().toString()];for(let t=0;t<n.length;t++){const e=i.indexOf(n[t]);if(!(o=!r[e]))break}return o})}else{n=[];for(let e=0;e<t.length;e++)n.push(!0)}return this._logger.info("<=== TransactionClient::isReattachable",n),n})}promoteTransaction(t,e,r,a,c){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::promoteTransaction",t,e,r,a,c),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The transactionTail must be an object of type Hash");if(!n.NumberHelper.isInteger(e)||e<=0)throw new _.BusinessError("The depth must be a number > 0",{depth:e});if(!n.NumberHelper.isInteger(r)||r<=0)throw new _.BusinessError("The minWeightMagnitude must be a number > 0",{minWeightMagnitude:r});if(!o.ArrayHelper.isTyped(a,w.Transfer))throw new _.BusinessError("The transfers must an array of Transfer objects");const u=c||{};if(s.ObjectHelper.isEmpty(u.interrupt)&&(u.interrupt=!1),!1===u.interrupt||"function"==typeof u.interrupt&&!u.interrupt()){if(yield this.isPromotable(t)){const o=yield this.sendTransfer(p.Hash.fromTrytes(a[0].address.toTrytes()),e,r,a,void 0,t);return n.NumberHelper.isInteger(u.delay)?this._backgroundTaskService.create(()=>i.__awaiter(this,void 0,void 0,function*(){return this.promoteTransaction(t,e,r,a,u)}),u.delay):(this._logger.info("<=== TransactionClient::promoteTransaction",o),o)}throw new _.BusinessError("Transaction is not promotable")}this._logger.info("<=== TransactionClient::promoteTransaction",void 0)})}getBundle(t){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getBundle",t),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The transactionHash must be an object of type Hash");const e=yield this.traverseBundle(t),r=new l.Bundle;if(r.transactions=e,!H.BundleHelper.isValid(r))throw new _.BusinessError("Invalid bundle provided");return this._logger.info("<=== TransactionClient::getBundle",r),r})}traverseBundle(t,e){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::traverseBundle",t,e),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The trunkTransaction must be an object of type Hash");const r=[];let i=t,o=e;do{const t={hashes:[i.toTrytes().toString()]},e=yield this._apiClient.getTrytes(t),n=!s.ObjectHelper.isEmpty(e)&&!s.ObjectHelper.isEmpty(e.trytes)&&e.trytes.length>0?e.trytes[0]:void 0;if(s.ObjectHelper.isEmpty(n))throw new _.BusinessError("Bundle transactions not visible");{const t=m.Transaction.fromTrytes(S.Trytes.fromString(n)),e=!s.ObjectHelper.isEmpty(o);if(!e&&0!==t.currentIndex.toNumber())throw new _.BusinessError("Invalid tail transaction supplied");const a=e?o:t.bundle;i=void 0,o=void 0,a.toTrytes().toString()===t.bundle.toTrytes().toString()&&(r.push(t),0===t.lastIndex.toNumber()&&0===t.currentIndex.toNumber()||(i=t.trunkTransaction,o=a))}}while(void 0!==i);return this._logger.info("<=== TransactionClient::traverseBundle",r),r})}reattachBundle(t,e,r){return i.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::reattachBundle",t,e,r);const i=yield this.getBundle(t);i.transactions=i.transactions.reverse();const o=yield this.sendTransactions(i,e,r);return this._logger.info("<=== TransactionClient::reattachBundle",o),o})}rebroadcastBundle(t){return i.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::rebroadcastBundle",t);const e=yield this.getBundle(t),r={trytes:e.transactions.reverse().map(t=>t.toTrytes().toString())};return yield this._apiClient.broadcastTransactions(r),this._logger.info("<=== TransactionClient::rebroadcastBundle",e),e})}findTransactionObjects(t,e,r,o){return i.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::findTransactionObjects",t,e,r,o);const i=yield this.findTransactions(t,e,r,o);if(i.length>0){const t=yield this.getTransactionsObjects(i);return this._logger.info("<=== TransactionClient::findTransactionObjects",t),t}return this._logger.info("<=== TransactionClient::findTransactionObjects",[]),[]})}getTransfers(t,e,r,o,a){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getTransfers",t,e,r,o,a),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The seed must be of type Hash");let i=e;n.NumberHelper.isInteger(i)||(i=0);const c=yield this.getNewAddress(t,i,r,!1,o),u=yield this.bundlesFromAddresses(c,a);return this._logger.info("<=== TransactionClient::getTransfers",u),u})}getAccountData(t,e,r,o){return i.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getAccountData",t,e,r,o),!s.ObjectHelper.isType(t,p.Hash))throw new _.BusinessError("The seed must be of type Hash");let i=e;n.NumberHelper.isInteger(i)||(i=0);const a=yield this.getNewAddress(t,i,r,!1,o||d.AddressSecurity.medium),c=yield this.bundlesFromAddresses(a,!0),u={latestAddress:a.pop(),addresses:a,transfers:c,inputs:[],balance:0},h={addresses:u.addresses.map(t=>t.toTrytes().toString()),threshold:100},f=yield this._apiClient.getBalances(h);for(let t=0;t<f.balances.length;t++){const e=parseInt(f.balances[t],10);e>0&&(u.inputs.push(T.Input.fromParams(u.addresses[t],o||d.AddressSecurity.medium,i+t,e)),u.balance+=e)}return this._logger.info("<=== TransactionClient::getAccountData",u),u})}bundlesFromAddresses(t,e){return i.__awaiter(this,void 0,void 0,function*(){const r=yield this.findTransactionObjects(void 0,t,void 0,void 0),i=new Set,o=new Set;if(r.forEach(t=>{0===t.currentIndex.toNumber()?i.add(f.TransactionHelper.hash(t).toTrytes().toString()):o.add(t.bundle.toTrytes().toString())}),o.size>0){(yield this.findTransactionObjects(Array.from(o).map(t=>p.Hash.fromTrytes(S.Trytes.fromString(t))))).forEach(t=>{0===t.currentIndex.toNumber()&&i.add(f.TransactionHelper.hash(t).toTrytes().toString())})}const n=[],s=Array.from(i);let a;e&&(a=yield this.getLatestInclusion(s.map(t=>p.Hash.fromTrytes(S.Trytes.fromString(t)))));for(let t=0;t<s.length;t++){const e=yield this.getBundle(p.Hash.fromTrytes(S.Trytes.fromString(s[t])));e.inclusionState=a?a[t]:void 0,n.push(e)}return n.sort((t,e)=>{const r=t.transactions[0].attachmentTimestamp.toNumber(),i=e.transactions[0].attachmentTimestamp.toNumber();return r<i?-1:r>i?1:0}),n})}generateAddress(t,e,r,i){const o=h.ISS.key(t,e,r),n=h.ISS.digests(o),s=h.ISS.address(n);let a=b.Trits.fromArray(s).toTrytes().toString();return i&&(a+=v.AddressHelper.createChecksum(s,9)),y.Address.fromTrytes(S.Trytes.fromString(a))}addRemainder(t,e,r,o,n,a,c,u){return i.__awaiter(this,void 0,void 0,function*(){let i=a;for(let a=0;a<o.length;a++){const h=Math.floor(this._timeService.msSinceEpoch()/1e3);if(e.addTransactions(o[a].security,o[a].address,-o[a].balance,c,h),o[a].balance>=i){const f=o[a].balance-i;if(f>0&&!s.ObjectHelper.isEmpty(r)&&s.ObjectHelper.isType(r.remainderAddress,y.Address))e.addTransactions(1,r.remainderAddress,f,c,h),H.BundleHelper.signInputs(t,e,r,n,o,u);else if(f>0){let i=0;for(let t=0;t<o.length;t++)i=Math.max(o[t].keyIndex,i);i++;const s=yield this.getAddressesToUnused(t,i,!1,r.security),a=Math.floor(this._timeService.msSinceEpoch()/1e3);e.addTransactions(1,s[s.length-1],f,c,a),H.BundleHelper.signInputs(t,e,r,n,o,u)}else H.BundleHelper.signInputs(t,e,r,n,o,u)}else i-=o[a].balance}})}}j.NULL_HASH_TRYTES="9".repeat(243),j.MAX_INPUTS=500,e.TransactionClient=j},function(t,e){t.exports=g},function(t,e){t.exports=m},function(t,e){t.exports=w},function(t,e){t.exports=b},function(t,e){t.exports=S},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});const i=r(5),o=r(3),n=r(15),s=r(4),a=r(32),c=r(8),u=r(1),h=r(2);e.ProofOfWorkApi=class{constructor(t){if(s.ObjectHelper.isEmpty(t))throw new h.BusinessError("The apiClient must not be empty");this._apiClient=t}initialize(){return i.__awaiter(this,void 0,void 0,function*(){return Promise.resolve()})}pow(t,e,r,h){return i.__awaiter(this,void 0,void 0,function*(){if(!s.ObjectHelper.isType(t,c.Hash))throw new a.CryptoError("The trunkTransaction must be an object of type Hash");if(!s.ObjectHelper.isType(e,c.Hash))throw new a.CryptoError("The branchTransaction must be an object of type Hash");if(!o.ArrayHelper.isTyped(r,u.Trytes))throw new a.CryptoError("The trytes must be an array of type Trytes");if(!n.NumberHelper.isInteger(h)||h<=0)throw new a.CryptoError("The minWeightMagnitude must be > 0");const i={trunkTransaction:t.toString(),branchTransaction:e.toString(),minWeightMagnitude:h,trytes:r.map(t=>t.toString())},f=yield this._apiClient.attachToTangle(i);if(s.ObjectHelper.isEmpty(f)||o.ArrayHelper.isEmpty(f.trytes))throw new a.CryptoError("The attachToTangleRequest did not return any trytes");return f.trytes.map(t=>u.Trytes.fromString(t))})}}},function(t,e){t.exports=_}])});