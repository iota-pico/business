!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@iota-pico/data/dist/data/trits"),require("@iota-pico/data/dist/data/trytes"),require("@iota-pico/core/dist/helpers/arrayHelper"),require("@iota-pico/core/dist/helpers/objectHelper"),require("@iota-pico/crypto/dist/factories/spongeFactory"),require("@iota-pico/data/dist/data/address"),require("@iota-pico/data/dist/data/hash"),require("@iota-pico/crypto/dist/hash/iss"),require("@iota-pico/data/dist/data/bundle"),require("@iota-pico/data/dist/data/signatureMessageFragment"),require("@iota-pico/data/dist/data/tag"),require("@iota-pico/data/dist/data/transaction"),require("@iota-pico/core/dist/helpers/numberHelper"),require("@iota-pico/core/dist/services/timeService"),require("@iota-pico/data/dist/data/transfer"),require("@iota-pico/core/dist/error/coreError"),require("@iota-pico/data/dist/data/tryteNumber"),require("@iota-pico/core/dist/loggers/nullLogger"),require("@iota-pico/core/dist/services/backgroundTaskService"),require("@iota-pico/crypto/dist/helpers/transactionHelper"),require("@iota-pico/data/dist/data/addressSecurity"),require("@iota-pico/data/dist/data/input"),require("@iota-pico/crypto/dist/error/cryptoError")):"function"==typeof define&&define.amd?define("@iota-pico/business",["@iota-pico/data/dist/data/trits","@iota-pico/data/dist/data/trytes","@iota-pico/core/dist/helpers/arrayHelper","@iota-pico/core/dist/helpers/objectHelper","@iota-pico/crypto/dist/factories/spongeFactory","@iota-pico/data/dist/data/address","@iota-pico/data/dist/data/hash","@iota-pico/crypto/dist/hash/iss","@iota-pico/data/dist/data/bundle","@iota-pico/data/dist/data/signatureMessageFragment","@iota-pico/data/dist/data/tag","@iota-pico/data/dist/data/transaction","@iota-pico/core/dist/helpers/numberHelper","@iota-pico/core/dist/services/timeService","@iota-pico/data/dist/data/transfer","@iota-pico/core/dist/error/coreError","@iota-pico/data/dist/data/tryteNumber","@iota-pico/core/dist/loggers/nullLogger","@iota-pico/core/dist/services/backgroundTaskService","@iota-pico/crypto/dist/helpers/transactionHelper","@iota-pico/data/dist/data/addressSecurity","@iota-pico/data/dist/data/input","@iota-pico/crypto/dist/error/cryptoError"],t):"object"==typeof exports?exports["@iota-pico/business"]=t(require("@iota-pico/data/dist/data/trits"),require("@iota-pico/data/dist/data/trytes"),require("@iota-pico/core/dist/helpers/arrayHelper"),require("@iota-pico/core/dist/helpers/objectHelper"),require("@iota-pico/crypto/dist/factories/spongeFactory"),require("@iota-pico/data/dist/data/address"),require("@iota-pico/data/dist/data/hash"),require("@iota-pico/crypto/dist/hash/iss"),require("@iota-pico/data/dist/data/bundle"),require("@iota-pico/data/dist/data/signatureMessageFragment"),require("@iota-pico/data/dist/data/tag"),require("@iota-pico/data/dist/data/transaction"),require("@iota-pico/core/dist/helpers/numberHelper"),require("@iota-pico/core/dist/services/timeService"),require("@iota-pico/data/dist/data/transfer"),require("@iota-pico/core/dist/error/coreError"),require("@iota-pico/data/dist/data/tryteNumber"),require("@iota-pico/core/dist/loggers/nullLogger"),require("@iota-pico/core/dist/services/backgroundTaskService"),require("@iota-pico/crypto/dist/helpers/transactionHelper"),require("@iota-pico/data/dist/data/addressSecurity"),require("@iota-pico/data/dist/data/input"),require("@iota-pico/crypto/dist/error/cryptoError")):e.IotaPicoBusiness=t(e["@iota-pico/data/dist/data/trits"],e["@iota-pico/data/dist/data/trytes"],e["@iota-pico/core/dist/helpers/arrayHelper"],e["@iota-pico/core/dist/helpers/objectHelper"],e["@iota-pico/crypto/dist/factories/spongeFactory"],e["@iota-pico/data/dist/data/address"],e["@iota-pico/data/dist/data/hash"],e["@iota-pico/crypto/dist/hash/iss"],e["@iota-pico/data/dist/data/bundle"],e["@iota-pico/data/dist/data/signatureMessageFragment"],e["@iota-pico/data/dist/data/tag"],e["@iota-pico/data/dist/data/transaction"],e["@iota-pico/core/dist/helpers/numberHelper"],e["@iota-pico/core/dist/services/timeService"],e["@iota-pico/data/dist/data/transfer"],e["@iota-pico/core/dist/error/coreError"],e["@iota-pico/data/dist/data/tryteNumber"],e["@iota-pico/core/dist/loggers/nullLogger"],e["@iota-pico/core/dist/services/backgroundTaskService"],e["@iota-pico/crypto/dist/helpers/transactionHelper"],e["@iota-pico/data/dist/data/addressSecurity"],e["@iota-pico/data/dist/data/input"],e["@iota-pico/crypto/dist/error/cryptoError"])}("undefined"!=typeof self?self:this,function(e,t,r,s,n,i,o,a,c,u,d,l,p,f,h,g,y,T,b,m,_,w,S){return function(e){var t={};function r(s){if(t[s])return t[s].exports;var n=t[s]={i:s,l:!1,exports:{}};return e[s].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(s,n,function(t){return e[t]}.bind(null,n));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=21)}([function(t,r){t.exports=e},function(e,r){e.exports=t},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(22);t.BusinessError=class extends s.CoreError{constructor(e,t,r){super(e,t,r),this.domain="Business"}}},function(e,t){e.exports=r},function(e,t){e.exports=s},function(e,t,r){"use strict";r.r(t),r.d(t,"__extends",function(){return n}),r.d(t,"__assign",function(){return i}),r.d(t,"__rest",function(){return o}),r.d(t,"__decorate",function(){return a}),r.d(t,"__param",function(){return c}),r.d(t,"__metadata",function(){return u}),r.d(t,"__awaiter",function(){return d}),r.d(t,"__generator",function(){return l}),r.d(t,"__exportStar",function(){return p}),r.d(t,"__values",function(){return f}),r.d(t,"__read",function(){return h}),r.d(t,"__spread",function(){return g}),r.d(t,"__await",function(){return y}),r.d(t,"__asyncGenerator",function(){return T}),r.d(t,"__asyncDelegator",function(){return b}),r.d(t,"__asyncValues",function(){return m}),r.d(t,"__makeTemplateObject",function(){return _}),r.d(t,"__importStar",function(){return w}),r.d(t,"__importDefault",function(){return S});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var s=function(e,t){return(s=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)};function n(e,t){function r(){this.constructor=e}s(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}var i=function(){return(i=Object.assign||function(e){for(var t,r=1,s=arguments.length;r<s;r++)for(var n in t=arguments[r])Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}).apply(this,arguments)};function o(e,t){var r={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.indexOf(s)<0&&(r[s]=e[s]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(s=Object.getOwnPropertySymbols(e);n<s.length;n++)t.indexOf(s[n])<0&&(r[s[n]]=e[s[n]])}return r}function a(e,t,r,s){var n,i=arguments.length,o=i<3?t:null===s?s=Object.getOwnPropertyDescriptor(t,r):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,r,s);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(o=(i<3?n(o):i>3?n(t,r,o):n(t,r))||o);return i>3&&o&&Object.defineProperty(t,r,o),o}function c(e,t){return function(r,s){t(r,s,e)}}function u(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}function d(e,t,r,s){return new(r||(r=Promise))(function(n,i){function o(e){try{c(s.next(e))}catch(e){i(e)}}function a(e){try{c(s.throw(e))}catch(e){i(e)}}function c(e){e.done?n(e.value):new r(function(t){t(e.value)}).then(o,a)}c((s=s.apply(e,t||[])).next())})}function l(e,t){var r,s,n,i,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(r)throw new TypeError("Generator is already executing.");for(;o;)try{if(r=1,s&&(n=2&i[0]?s.return:i[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,i[1])).done)return n;switch(s=0,n&&(i=[2&i[0],n.value]),i[0]){case 0:case 1:n=i;break;case 4:return o.label++,{value:i[1],done:!1};case 5:o.label++,s=i[1],i=[0];continue;case 7:i=o.ops.pop(),o.trys.pop();continue;default:if(!(n=(n=o.trys).length>0&&n[n.length-1])&&(6===i[0]||2===i[0])){o=0;continue}if(3===i[0]&&(!n||i[1]>n[0]&&i[1]<n[3])){o.label=i[1];break}if(6===i[0]&&o.label<n[1]){o.label=n[1],n=i;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(i);break}n[2]&&o.ops.pop(),o.trys.pop();continue}i=t.call(e,o)}catch(e){i=[6,e],s=0}finally{r=n=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}}function p(e,t){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}function f(e){var t="function"==typeof Symbol&&e[Symbol.iterator],r=0;return t?t.call(e):{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}}function h(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var s,n,i=r.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(s=i.next()).done;)o.push(s.value)}catch(e){n={error:e}}finally{try{s&&!s.done&&(r=i.return)&&r.call(i)}finally{if(n)throw n.error}}return o}function g(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(h(arguments[t]));return e}function y(e){return this instanceof y?(this.v=e,this):new y(e)}function T(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,n=r.apply(e,t||[]),i=[];return s={},o("next"),o("throw"),o("return"),s[Symbol.asyncIterator]=function(){return this},s;function o(e){n[e]&&(s[e]=function(t){return new Promise(function(r,s){i.push([e,t,r,s])>1||a(e,t)})})}function a(e,t){try{(r=n[e](t)).value instanceof y?Promise.resolve(r.value.v).then(c,u):d(i[0][2],r)}catch(e){d(i[0][3],e)}var r}function c(e){a("next",e)}function u(e){a("throw",e)}function d(e,t){e(t),i.shift(),i.length&&a(i[0][0],i[0][1])}}function b(e){var t,r;return t={},s("next"),s("throw",function(e){throw e}),s("return"),t[Symbol.iterator]=function(){return this},t;function s(s,n){t[s]=e[s]?function(t){return(r=!r)?{value:y(e[s](t)),done:"return"===s}:n?n(t):t}:n}}function m(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e=f(e),t={},s("next"),s("throw"),s("return"),t[Symbol.asyncIterator]=function(){return this},t);function s(r){t[r]=e[r]&&function(t){return new Promise(function(s,n){(function(e,t,r,s){Promise.resolve(s).then(function(t){e({value:t,done:r})},t)})(s,n,(t=e[r](t)).done,t.value)})}}}function _(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e}function w(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}function S(e){return e&&e.__esModule?e:{default:e}}},function(e,t){e.exports=n},function(e,t){e.exports=i},function(e,t){e.exports=o},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(3),n=r(4),i=r(6),o=r(10),a=r(7),c=r(11),u=r(8),d=r(12),l=r(13),p=r(14),f=r(0),h=r(23),g=r(1),y=r(17);class T{static isValid(e){let t=!1;if(n.ObjectHelper.isType(e,c.Bundle)&&s.ArrayHelper.isTyped(e.transactions,p.Transaction)){let r=0;const s=i.SpongeFactory.instance().create("kerl");s.initialize();const n=[];t=!0;for(let i=0;i<e.transactions.length&&t;i++){const o=e.transactions[i];if(r+=o.value.toNumber(),o.currentIndex.toNumber()!==i)t=!1;else{const t=o.toTrytes(),r=f.Trits.fromTrytes(t.sub(d.SignatureMessageFragment.LENGTH,162)).toArray();if(s.absorb(r,0,r.length),o.value.toNumber()<0){const t={address:o.address,signatureMessageFragments:[o.signatureMessageFragment]};for(let r=i;r<e.transactions.length-1;r++){const s=e.transactions[r+1];s.address.toTrytes().toString()===o.address.toTrytes().toString()&&0===s.value.toNumber()&&t.signatureMessageFragments.push(s.signatureMessageFragment)}n.push(t)}}}if(0!==r)t=!1;else{const r=new Int8Array(s.getConstant("HASH_LENGTH"));s.squeeze(r,0,r.length);const i=f.Trits.fromArray(r).toTrytes().toString(),a=e.transactions[0].bundle;if(i!==a.toTrytes().toString())t=!1;else if(e.transactions[e.transactions.length-1].currentIndex.toNumber()!==e.transactions[e.transactions.length-1].lastIndex.toNumber())t=!1;else for(let e=0;e<n.length&&t;e++){o.ISS.validateSignatures(n[e].address,n[e].signatureMessageFragments,a)||(t=!1)}}}return t}static validateSignatures(e,t){let r=!1;if(n.ObjectHelper.isType(e,c.Bundle)&&s.ArrayHelper.isTyped(e.transactions,p.Transaction)&&n.ObjectHelper.isType(t,a.Address)){let s;const n=[],i=t.toTrytes().toString();for(let t=0;t<e.transactions.length;t++)if(e.transactions[t].address.toTrytes().toString()===i){if(s=e.transactions[t].bundle,e.transactions[t].signatureMessageFragment.toTrytes().toString()===d.SignatureMessageFragment.EMPTY.toTrytes().toString())break;n.push(e.transactions[t].signatureMessageFragment)}s&&(r=o.ISS.validateSignatures(t,n,s))}return r}static prepareBundle(e,t){const r=new c.Bundle;let s,n=0;const i=[];for(let o=0;o<t.length;o++){let a=1;const c=t[o].message.toString();if(c.length>d.SignatureMessageFragment.LENGTH){a+=Math.floor(c.length/d.SignatureMessageFragment.LENGTH);let e=c;for(;e;){let t=e.slice(0,d.SignatureMessageFragment.LENGTH);e=e.slice(d.SignatureMessageFragment.LENGTH,e.length);for(let e=0;t.length<d.SignatureMessageFragment.LENGTH;e++)t+="9";i.push(d.SignatureMessageFragment.fromTrytes(g.Trytes.fromString(t)))}}else{let e="";c&&(e=c.slice(0,d.SignatureMessageFragment.LENGTH));for(let t=0;e.length<d.SignatureMessageFragment.LENGTH;t++)e+="9";i.push(d.SignatureMessageFragment.fromTrytes(g.Trytes.fromString(e)))}const u=Math.floor(e.msSinceEpoch()/1e3);s=t[o].tag,r.addTransactions(a,t[o].address,t[o].value,t[o].tag,u),n+=t[o].value}return{bundle:r,totalValue:n,lastTag:s,signatureMessageFragments:i}}static signInputs(e,t,r,s,n,i){T.finalizeBundle(t),t.addSignatureMessageFragments(s);for(let s=0;s<t.transactions.length;s++)if(t.transactions[s].value.toNumber()<0){const i=t.transactions[s].address.toTrytes().toString();let a,c;for(let e=0;e<n.length;e++)if(n[e].address.toTrytes().toString()===i){a=n[e].keyIndex,c=n[e].security?n[e].security:r.security;break}const u=o.ISS.key(e,a,c);T.signTransactions(t,s,0,u,i,c)}if(i){new y.HmacCurl(r.hmacKey).addHMAC(t)}}static signTransactions(e,t,r,s,n,i){const a=e.transactions[t].bundle,c=o.ISS.normalizedBundle(a),u=[];for(let e=0;e<3;e++)u[e]=c.slice(27*e,27*(e+1));const l=s.slice(0,6561),p=u[r],h=o.ISS.signatureMessageFragment(p,l);e.transactions[t].signatureMessageFragment=d.SignatureMessageFragment.fromTrytes(f.Trits.fromArray(h).toTrytes());for(let r=1;r<i;r++)if(e.transactions[t+r].address.toTrytes().toString()===n&&0===e.transactions[t+r].value.toNumber()){const n=s.slice(6561*r,6561*(r+1)),i=u[r],a=o.ISS.signatureMessageFragment(i,n);e.transactions[t+r].signatureMessageFragment=d.SignatureMessageFragment.fromTrytes(f.Trits.fromArray(a).toTrytes())}}static finalizeBundle(e){if(e.transactions.length>0){let t=!1;for(;!t;){const r=i.SpongeFactory.instance().create("kerl");r.initialize();for(let t=0;t<e.transactions.length;t++){e.transactions[t].currentIndex=h.TryteNumber.fromNumber(t),e.transactions[t].lastIndex=h.TryteNumber.fromNumber(e.transactions.length-1);const s=f.Trits.fromTrytes(g.Trytes.fromString(e.transactions[t].address.toTrytes().toString()+e.transactions[t].value.toTrytes().toString()+p.Transaction.CHECK_VALUE+e.transactions[t].obsoleteTag.toTrytes().toString()+e.transactions[t].timestamp.toTrytes().toString()+e.transactions[t].currentIndex.toTrytes().toString()+e.transactions[t].lastIndex.toTrytes().toString())).toArray();r.absorb(s,0,s.length)}const s=new Int8Array(r.getConstant("HASH_LENGTH"));r.squeeze(s,0,s.length);const n=u.Hash.fromTrytes(f.Trits.fromArray(s).toTrytes());for(let t=0;t<e.transactions.length;t++)e.transactions[t].bundle=n;if(-1!==o.ISS.normalizedBundle(n).indexOf(13)){const t=f.Trits.add(f.Trits.fromTrytes(e.transactions[0].obsoleteTag.toTrytes()),f.Trits.fromNumberArray([1]));e.transactions[0].obsoleteTag=l.Tag.fromTrytes(t.toTrytes())}else t=!0}}}}T.NUMBER_OF_FRAGMENT_CHUNKS=27,t.BundleHelper=T},function(e,t){e.exports=a},function(e,t){e.exports=c},function(e,t){e.exports=u},function(e,t){e.exports=d},function(e,t){e.exports=l},function(e,t){e.exports=p},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(6),n=r(0);t.AddressHelper=class{static createChecksum(e,t){const r=s.SpongeFactory.instance().create("kerl");r.initialize(),r.absorb(e,0,e.length);const i=new Int8Array(r.getConstant("HASH_LENGTH"));return r.squeeze(i,0,i.length),n.Trits.fromArray(i).toTrytes().toString().substring(81-t,81)}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(6),n=r(12),i=r(0),o=r(1);class a{constructor(e){this._keyTrits=i.Trits.fromTrytes(e).toArray()}addHMAC(e){const t=s.SpongeFactory.instance().create("curl",a.HMAC_ROUNDS),r=t.getConstant("HASH_LENGTH"),c=this._keyTrits;for(let s=0;s<e.transactions.length;s++)if(e.transactions[s].value.toNumber()>0){const a=i.Trits.fromTrytes(e.transactions[s].bundle.toTrytes()).toArray(),u=new Int8Array(r);t.initialize(),t.absorb(c,0,c.length),t.absorb(a,0,a.length),t.squeeze(u,0,u.length);const d=i.Trits.fromArray(u).toTrytes().toString(),l=e.transactions[s].signatureMessageFragment.toTrytes().toString().substring(81,n.SignatureMessageFragment.LENGTH);e.transactions[s].signatureMessageFragment=n.SignatureMessageFragment.fromTrytes(o.Trytes.fromString(d+l))}}}a.HMAC_ROUNDS=27,t.HmacCurl=a},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(3),n=r(4),i=r(6),o=r(7),a=r(0),c=r(1),u=r(2);t.MultiSigAddress=class{constructor(){this._kerl=i.SpongeFactory.instance().create("kerl"),this._hashLength=this._kerl.getConstant("HASH_LENGTH"),this._kerl.initialize()}absorb(e){if(!s.ArrayHelper.isTyped(e,c.Trytes))throw new u.BusinessError("The digests should be an array of type Trytes");for(let t=0;t<e.length;t++){const r=a.Trits.fromTrytes(e[t]).toArray();this._kerl.absorb(r,0,r.length)}}finalize(e){n.ObjectHelper.isEmpty(e)||this.absorb(e);const t=new Int8Array(this._hashLength);return this._kerl.squeeze(t,0,t.length),o.Address.fromTrytes(a.Trits.fromArray(t).toTrytes())}}},function(e,t){e.exports=f},function(e,t){e.exports=h},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(5);s.__exportStar(r(2),t),s.__exportStar(r(16),t),s.__exportStar(r(9),t),s.__exportStar(r(18),t),s.__exportStar(r(24),t),s.__exportStar(r(17),t),s.__exportStar(r(25),t)},function(e,t){e.exports=g},function(e,t){e.exports=y},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(5),n=r(3),i=r(15),o=r(4),a=r(19),c=r(10),u=r(7),d=r(11),l=r(8),p=r(12),f=r(13),h=r(14),g=r(20),y=r(0),T=r(1),b=r(2),m=r(9),_=r(18);t.MultiSigClient=class{constructor(e,t=new a.TimeService){this._apiClient=e,this._timeService=t}static getKey(e,t,r){if(!o.ObjectHelper.isType(e,l.Hash))throw new b.BusinessError("The seed should be an object of type Hash");if(!i.NumberHelper.isInteger(t)||t<0)throw new b.BusinessError("The index should be a number >= 0");if(!i.NumberHelper.isInteger(r)||r<1||r>3)throw new b.BusinessError("The security must be between 1 and 3",{security:r});return y.Trits.fromArray(c.ISS.key(e,t,r)).toTrytes()}static getDigest(e,t,r){if(!o.ObjectHelper.isType(e,l.Hash))throw new b.BusinessError("The seed should be an object of type Hash");if(!i.NumberHelper.isInteger(t)||t<0)throw new b.BusinessError("The index should be a number >= 0");if(!i.NumberHelper.isInteger(r)||r<1||r>3)throw new b.BusinessError("The security must be between 1 and 3",{security:r});const s=c.ISS.key(e,t,r);return y.Trits.fromArray(c.ISS.digests(s)).toTrytes()}static validateAddress(e,t){if(!o.ObjectHelper.isType(e,u.Address))throw new b.BusinessError("The address should be an object of type Address");if(!n.ArrayHelper.isTyped(t,T.Trytes))throw new b.BusinessError("The digests should be an array of type Trytes");return e.toTrytes().toString()===(new _.MultiSigAddress).finalize(t).toTrytes().toString()}static addSignature(e,t,r){if(!o.ObjectHelper.isType(e,d.Bundle))throw new b.BusinessError("The bundle should be an object of type Bundle");if(!n.ArrayHelper.isTyped(e.transactions,h.Transaction))throw new b.BusinessError("The bundle.transactions should be an array of type Transaction");if(!o.ObjectHelper.isType(t,u.Address))throw new b.BusinessError("The address should be an object of type Address");if(!o.ObjectHelper.isType(r,T.Trytes))throw new b.BusinessError("The key should be an object of type Trytes");const s=y.Trits.fromTrytes(r).toArray(),i=s.length/3/2187;let a=0;const c=t.toTrytes().toString();for(let t=0;t<e.transactions.length;t++)if(e.transactions[t].address.toTrytes().toString()===c){if(e.transactions[t].signatureMessageFragment.toTrytes().toString()===p.SignatureMessageFragment.EMPTY.toTrytes().toString()){m.BundleHelper.signTransactions(e,t,a%3,s,c,i);break}a++}}prepareTransfer(e,t,r,a,c){return s.__awaiter(this,void 0,void 0,function*(){if(!o.ObjectHelper.isType(e,u.Address))throw new b.BusinessError("The address should be an object of type Address");if(!i.NumberHelper.isInteger(t)||t<0)throw new b.BusinessError("The securitySum should be a number >= 0");if(!i.NumberHelper.isInteger(r)||r<0)throw new b.BusinessError("The balance should be a number >= 0");if(!n.ArrayHelper.isTyped(a,g.Transfer))throw new b.BusinessError("The transfers should be an array of type Transfer");if(!o.ObjectHelper.isEmpty(c)&&!o.ObjectHelper.isType(c,u.Address))throw new b.BusinessError("The remainderAddress should be an object of type Address");const s=T.Trytes.fromString("");a.forEach(e=>{e.message=e.message?e.message:s,e.tag=e.tag||f.Tag.EMPTY});const d=m.BundleHelper.prepareBundle(this._timeService,a);if(0===d.totalValue)throw new b.BusinessError("The total transfer value is 0, the transfer does not require a signature");{let s=r;if(0===s){const t={addresses:[e.toTrytes().toString()],threshold:100},r=yield this._apiClient.getBalances(t);s=parseInt(r.balances[0],10)}if(d.totalValue>s)throw new b.BusinessError("Not enough balance to satisfy the value",{totalValue:d.totalValue,totalBalance:s});const n=Math.floor(this._timeService.msSinceEpoch()/1e3);if(d.bundle.addTransactions(t,e,-s,d.lastTag,n),s>d.totalValue){if(o.ObjectHelper.isEmpty(c))throw new b.BusinessError("Transfer has remainder but no remainder address was provided");d.bundle.addTransactions(1,c,s-d.totalValue,d.lastTag,n)}m.BundleHelper.finalizeBundle(d.bundle),d.bundle.addSignatureMessageFragments(d.signatureMessageFragments)}return d.bundle})}}},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(5),n=r(3),i=r(15),o=r(4),a=r(26),c=r(27),u=r(19),d=r(10),l=r(28),p=r(7),f=r(29),h=r(11),g=r(8),y=r(30),T=r(13),b=r(14),m=r(20),_=r(0),w=r(1),S=r(2),H=r(16),v=r(9),E=r(31);class B{constructor(e,t,r,s,n){if(o.ObjectHelper.isEmpty(e))throw new S.BusinessError("The apiClient must not be empty");this._apiClient=e,this._proofOfWork=t||new E.ProofOfWorkApi(e),this._timeService=r||new u.TimeService,this._backgroundTaskService=s||new c.BackgroundTaskService,this._logger=n||new a.NullLogger}getTransactionsInProgress(){return s.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::getTransactionsInProgress");const e=yield this._apiClient.getTips();if(e&&e.hashes){const t=e.hashes.map(e=>g.Hash.fromTrytes(w.Trytes.fromString(e)));return this._logger.info("<=== TransactionClient::getTransactionsInProgress",t),t}return this._logger.info("<=== TransactionClient::getTransactionsInProgress",[]),[]})}findTransactions(e,t,r,i){return s.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::findTransactions",e,t,r,i);const s=null!=e&&e.length>0,o=null!=t&&t.length>0,a=null!=r&&r.length>0,c=null!=i&&i.length>0;if(s&&!n.ArrayHelper.isTyped(e,g.Hash))throw new S.BusinessError("The bundles must be an array of type Hash");if(o&&!n.ArrayHelper.isTyped(t,p.Address))throw new S.BusinessError("The addresses must be an array of type Address");if(a&&!n.ArrayHelper.isTyped(r,T.Tag))throw new S.BusinessError("The tags must be an array of type Tag");if(c&&!n.ArrayHelper.isTyped(i,g.Hash))throw new S.BusinessError("The approvees must be an array of type Hash");if(!(s||o||a||c))throw new S.BusinessError("You must provide bundles, addresses, tags or approvees");const u={bundles:s?e.map(e=>e.toTrytes().toString()):void 0,addresses:o?t.map(e=>e.toTrytes().toString()):void 0,tags:a?r.map(e=>e.toTrytes().toString()):void 0,approvees:c?i.map(e=>e.toTrytes().toString()):void 0},d=yield this._apiClient.findTransactions(u);if(d&&d.hashes){const e=d.hashes.map(e=>g.Hash.fromTrytes(w.Trytes.fromString(e)));return this._logger.info("<=== TransactionClient::findTransactions",e),e}return this._logger.info("<=== TransactionClient::findTransactions",[]),[]})}getTransactionsObjects(e){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getTransactionsObjects",e),!n.ArrayHelper.isTyped(e,g.Hash))throw new S.BusinessError("The transactionHashes must be an array of type Hash");const t={hashes:e.map(e=>e.toTrytes().toString())},r=yield this._apiClient.getTrytes(t);if(r&&r.trytes){const e=r.trytes.map(e=>b.Transaction.fromTrytes(w.Trytes.fromString(e)));return this._logger.info("<=== TransactionClient::getTransactionsObjects",e),e}return this._logger.info("<=== TransactionClient::getTransactionsObjects",[]),[]})}getLatestInclusion(e){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::transactionHashes"),!n.ArrayHelper.isTyped(e,g.Hash))throw new S.BusinessError("The transactionHashes must be an array of type Hash");const t=yield this._apiClient.getNodeInfo();if(t&&i.NumberHelper.isInteger(t.latestSolidSubtangleMilestone)){const r={transactions:e.map(e=>e.toTrytes().toString()),tips:[t.latestSolidSubtangleMilestone]},s=yield this._apiClient.getInclusionStates(r);return s&&s.states?(this._logger.info("<=== TransactionClient::transactionHashes",s.states),s.states):(this._logger.info("<=== TransactionClient::transactionHashes",[]),[])}throw new S.BusinessError("The node could not provide the latestSolidSubtangleMilestone")})}getNewAddress(e,t,r,n,a){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getNewAddress",e,t,r,n,a),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The seed must be of type Hash");if(!o.ObjectHelper.isEmpty(t)&&!o.ObjectHelper.isType(t,Number))throw new S.BusinessError("The startIndex must be an integer",{startIndex:t});const s=t||0;if(s<0)throw new S.BusinessError("The startIndex must be >= 0",{localStartIndex:s});const c=i.NumberHelper.isInteger(r),u=a||f.AddressSecurity.medium;let d;if(c){if(!i.NumberHelper.isInteger(r)||r<0)throw new S.BusinessError("The endIndex must be a number >= 0",{endIndex:r});const s=r-t+1;if(s<=0||s>B.MAX_INPUTS)throw new S.BusinessError(`The total must be > 0 and <= ${B.MAX_INPUTS}`,{total:s});d=yield this.getAddressesByIndex(e,t,r,n,u)}else d=yield this.getAddressesToUnused(e,t,n,u);return this._logger.info("<=== TransactionClient::getNewAddress",d),d})}getAddressesByIndex(e,t,r,n,a){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getAddressesByIndex",e,t,r,n,a),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The seed must be of type Hash");if(!i.NumberHelper.isInteger(t)||t<0)throw new S.BusinessError("The startIndex must be a number >= 0",{startIndex:t});if(!i.NumberHelper.isInteger(r)||r<0)throw new S.BusinessError("The endIndex must be a number >= 0",{endIndex:r});const s=r-t+1;if(s<=0||s>B.MAX_INPUTS)throw new S.BusinessError(`The total must be > 0 and <= ${B.MAX_INPUTS}`,{total:s});if(!i.NumberHelper.isInteger(a)||a<1||a>3)throw new S.BusinessError("The security must be between 1 and 3",{security:a});const c=[];for(let r=0;r<s;r++)c.push(this.generateAddress(e,t+r,a,n));return this._logger.info("<=== TransactionClient::getAddressesByIndex",c),Promise.resolve(c)})}getAddressesToUnused(e,t,r,n){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getAddressesToUnused",e,t,r,n),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The seed must be of type Hash");if(!i.NumberHelper.isInteger(t)||t<0)throw new S.BusinessError("The startIndex must be a number >= 0",{startIndex:t});if(!i.NumberHelper.isInteger(n)||n<1||n>3)throw new S.BusinessError("The security must be between 1 and 3",{security:n});let s,a=t;const c=[];do{const t=this.generateAddress(e,a++,n,r);c.push(t);const i=t.toTrytes().toString(),o={addresses:[i]},u=yield this._apiClient.wereAddressesSpentFrom(o);if(!(s=!!(u&&u.states&&u.states.length>0)&&u.states[0])){const e={addresses:[i]},t=yield this._apiClient.findTransactions(e);s=t&&t.hashes&&t.hashes.length>0}}while(s);return this._logger.info("<=== TransactionClient::getAddressesToUnused",c),Promise.resolve(c)})}getInputs(e,t,r,n,a){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getInputs",e,t,r,n,a),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The seed must be of type Hash");if(!i.NumberHelper.isInteger(t)||t<0)throw new S.BusinessError("The startIndex must be a number >= 0",{startIndex:t});if(!i.NumberHelper.isInteger(n)||n<1||n>3)throw new S.BusinessError("The security must be between 1 and 3",{security:n});if(!i.NumberHelper.isInteger(a)||a<0)throw new S.BusinessError("The totalRequired must be >= 0",{totalRequired:a});const s=yield this.getNewAddress(e,t,r,!1,n),c={addresses:s.map(e=>e.toTrytes().toString()),threshold:100},u=yield this._apiClient.getBalances(c),d=[];let l=0;if(u)for(let e=0;e<s.length;e++){const r=parseInt(u.balances[e],10);if(r>0&&(d.push(y.Input.fromParams(s[e],n,t+e,r)),l+=r,a>0&&l>=a))break}const p={inputs:d,totalBalance:l};if(this._logger.info("<=== TransactionClient::getInputs",p),a>0&&l<a)throw new S.BusinessError("Not enough combined balance in the addresses to satisfy the total required",{totalRequired:a,totalBalance:l});return p})}prepareTransfers(e,t,r){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::prepareTransfers",e,t,r),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The seed must be of type Hash");if(!n.ArrayHelper.isTyped(t,m.Transfer))throw new S.BusinessError("The transfers must be an array of Transfer objects");const s=r||{};s.security=s.security||f.AddressSecurity.medium;const i=w.Trytes.fromString(""),a=!o.ObjectHelper.isEmpty(s.hmacKey);let c=!1;t.forEach(e=>{e.message=e.message?e.message:i,e.tag=e.tag||T.Tag.EMPTY,a&&e.value>0&&(e.message=w.Trytes.fromString(B.NULL_HASH_TRYTES+e.message.toString()),c=!0)});const u=v.BundleHelper.prepareBundle(this._timeService,t),d=u.bundle,l=u.lastTag,p=u.totalValue,h=u.signatureMessageFragments;if(p>0)if(s.inputs){const t={addresses:s.inputs.map(e=>e.address.toTrytes().toString()),threshold:100},r=yield this._apiClient.getBalances(t),n=[];let i=0;for(let e=0;e<r.balances.length;e++){const t=parseInt(r.balances[e],10);if(t>0&&(i+=t,s.inputs[e].balance=t,n.push(s.inputs[e]),i>=p))break}if(p>i)throw new S.BusinessError("Not enough balance in the input addresses to satisfy the total for the transfer");yield this.addRemainder(e,d,s,n,h,p,l,c)}else{const t=yield this.getInputs(e,0,void 0,s.security,p);yield this.addRemainder(e,d,s,t.inputs,h,p,l,c)}else v.BundleHelper.finalizeBundle(d),d.addSignatureMessageFragments(h);return d.transactions=d.transactions.reverse(),this._logger.info("<=== TransactionClient::prepareTransfers",d),d})}attachToTangle(e,t,r,a){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::attachToTangle",e,t,r,a),!o.ObjectHelper.isType(e,h.Bundle))throw new S.BusinessError("The bundle must be an array of type Bundle");if(!n.ArrayHelper.isTyped(e.transactions,b.Transaction))throw new S.BusinessError("The bundle.transactions must be an array of type Transaction");if(!i.NumberHelper.isInteger(t)||t<=0)throw new S.BusinessError("The depth must be a number > 0",{depth:t});if(!i.NumberHelper.isInteger(r)||r<=0)throw new S.BusinessError("The minWeightMagnitude must be a number > 0",{minWeightMagnitude:r});const s={depth:t,reference:a?a.toTrytes().toString():void 0},c=yield this._apiClient.getTransactionsToApprove(s),u=(yield this._proofOfWork.pow(g.Hash.fromTrytes(w.Trytes.fromString(c.trunkTransaction)),g.Hash.fromTrytes(w.Trytes.fromString(c.branchTransaction)),e.transactions.map(e=>e.toTrytes()),r)).map(e=>b.Transaction.fromTrytes(e)),d=new h.Bundle;return d.transactions=u,this._logger.info("<=== TransactionClient::attachToTangle",d),d})}sendTransactions(e,t,r,n){return s.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::sendTransactions",e,t,r,n);const s=yield this.attachToTangle(e,t,r,n),i={trytes:s.transactions.map(e=>e.toTrytes().toString())};yield this._apiClient.storeTransactions(i);const o={trytes:i.trytes};return yield this._apiClient.broadcastTransactions(o),this._logger.info("<=== TransactionClient::sendTransactions",s),s})}sendTransfer(e,t,r,n,i,o){return s.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::sendTransfer",e,t,r,n,i,o);const s=yield this.prepareTransfers(e,n,i),a=yield this.sendTransactions(s,t,r,o);return this._logger.info("<=== TransactionClient::sendTransfer",a),a})}isPromotable(e){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::isPromotable",e),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The transactionTail must be an object of type Hash");const t={tails:[e.toTrytes().toString()]},r=yield this._apiClient.checkConsistency(t);return this._logger.info("<=== TransactionClient::isPromotable",r.state),r.state})}isReattachable(e){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::isReattachable",e),!n.ArrayHelper.isTyped(e,p.Address))throw new S.BusinessError("The addresses must be an object of type Address");const t={};for(let r=0;r<e.length;r++){const s=e[r].toTrytes().toString();t[s]=[]}const r=yield this.findTransactionObjects(void 0,e),s=[];let i;if(r.forEach(e=>{if(e.value.toNumber()<0){const r=e.address,n=l.TransactionHelper.hash(e);t[r.toTrytes().toString()].push(n),s.push(n)}}),s.length>0){const r=yield this.getLatestInclusion(s);i=e.map(e=>{let n=!0;const i=t[e.toTrytes().toString()];for(let e=0;e<i.length;e++){const t=s.indexOf(i[e]);if(!(n=!r[t]))break}return n})}else{i=[];for(let t=0;t<e.length;t++)i.push(!0)}return this._logger.info("<=== TransactionClient::isReattachable",i),i})}promoteTransaction(e,t,r,a,c){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::promoteTransaction",e,t,r,a,c),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The transactionTail must be an object of type Hash");if(!i.NumberHelper.isInteger(t)||t<=0)throw new S.BusinessError("The depth must be a number > 0",{depth:t});if(!i.NumberHelper.isInteger(r)||r<=0)throw new S.BusinessError("The minWeightMagnitude must be a number > 0",{minWeightMagnitude:r});if(!n.ArrayHelper.isTyped(a,m.Transfer))throw new S.BusinessError("The transfers must an array of Transfer objects");const u=c||{};if(o.ObjectHelper.isEmpty(u.interrupt)&&(u.interrupt=!1),!1===u.interrupt||"function"==typeof u.interrupt&&!u.interrupt()){if(yield this.isPromotable(e)){const n=yield this.sendTransfer(g.Hash.fromTrytes(a[0].address.toTrytes()),t,r,a,void 0,e);return i.NumberHelper.isInteger(u.delay)?this._backgroundTaskService.create(()=>s.__awaiter(this,void 0,void 0,function*(){return this.promoteTransaction(e,t,r,a,u)}),u.delay):(this._logger.info("<=== TransactionClient::promoteTransaction",n),n)}throw new S.BusinessError("Transaction is not promotable")}this._logger.info("<=== TransactionClient::promoteTransaction",void 0)})}getBundle(e){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getBundle",e),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The transactionHash must be an object of type Hash");const t=yield this.traverseBundle(e),r=new h.Bundle;if(r.transactions=t,!v.BundleHelper.isValid(r))throw new S.BusinessError("Invalid bundle provided");return this._logger.info("<=== TransactionClient::getBundle",r),r})}traverseBundle(e,t){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::traverseBundle",e,t),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The trunkTransaction must be an object of type Hash");const r=[];let s=e,n=t;do{const e={hashes:[s.toTrytes().toString()]},t=yield this._apiClient.getTrytes(e),i=!o.ObjectHelper.isEmpty(t)&&!o.ObjectHelper.isEmpty(t.trytes)&&t.trytes.length>0?t.trytes[0]:void 0;if(o.ObjectHelper.isEmpty(i))throw new S.BusinessError("Bundle transactions not visible");{const e=b.Transaction.fromTrytes(w.Trytes.fromString(i)),t=!o.ObjectHelper.isEmpty(n);if(!t&&0!==e.currentIndex.toNumber())throw new S.BusinessError("Invalid tail transaction supplied");const a=t?n:e.bundle;s=void 0,n=void 0,a.toTrytes().toString()===e.bundle.toTrytes().toString()&&(r.push(e),0===e.lastIndex.toNumber()&&0===e.currentIndex.toNumber()||(s=e.trunkTransaction,n=a))}}while(void 0!==s);return this._logger.info("<=== TransactionClient::traverseBundle",r),r})}reattachBundle(e,t,r){return s.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::reattachBundle",e,t,r);const s=yield this.getBundle(e);s.transactions=s.transactions.reverse();const n=yield this.sendTransactions(s,t,r);return this._logger.info("<=== TransactionClient::reattachBundle",n),n})}rebroadcastBundle(e){return s.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::rebroadcastBundle",e);const t=yield this.getBundle(e),r={trytes:t.transactions.reverse().map(e=>e.toTrytes().toString())};return yield this._apiClient.broadcastTransactions(r),this._logger.info("<=== TransactionClient::rebroadcastBundle",t),t})}findTransactionObjects(e,t,r,n){return s.__awaiter(this,void 0,void 0,function*(){this._logger.info("===> TransactionClient::findTransactionObjects",e,t,r,n);const s=yield this.findTransactions(e,t,r,n);if(s.length>0){const e=yield this.getTransactionsObjects(s);return this._logger.info("<=== TransactionClient::findTransactionObjects",e),e}return this._logger.info("<=== TransactionClient::findTransactionObjects",[]),[]})}getTransfers(e,t,r,n,a){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getTransfers",e,t,r,n,a),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The seed must be of type Hash");let s=t;i.NumberHelper.isInteger(s)||(s=0);const c=yield this.getNewAddress(e,s,r,!1,n),u=yield this.bundlesFromAddresses(c,a);return this._logger.info("<=== TransactionClient::getTransfers",u),u})}getAccountData(e,t,r,n){return s.__awaiter(this,void 0,void 0,function*(){if(this._logger.info("===> TransactionClient::getAccountData",e,t,r,n),!o.ObjectHelper.isType(e,g.Hash))throw new S.BusinessError("The seed must be of type Hash");let s=t;i.NumberHelper.isInteger(s)||(s=0);const a=yield this.getNewAddress(e,s,r,!1,n||f.AddressSecurity.medium),c=yield this.bundlesFromAddresses(a,!0),u={latestAddress:a.pop(),addresses:a,transfers:c,inputs:[],balance:0},d={addresses:u.addresses.map(e=>e.toTrytes().toString()),threshold:100},l=yield this._apiClient.getBalances(d);for(let e=0;e<l.balances.length;e++){const t=parseInt(l.balances[e],10);t>0&&(u.inputs.push(y.Input.fromParams(u.addresses[e],n||f.AddressSecurity.medium,s+e,t)),u.balance+=t)}return this._logger.info("<=== TransactionClient::getAccountData",u),u})}bundlesFromAddresses(e,t){return s.__awaiter(this,void 0,void 0,function*(){const r=yield this.findTransactionObjects(void 0,e,void 0,void 0),s=new Set,n=new Set;if(r.forEach(e=>{0===e.currentIndex.toNumber()?s.add(l.TransactionHelper.hash(e).toTrytes().toString()):n.add(e.bundle.toTrytes().toString())}),n.size>0){(yield this.findTransactionObjects(Array.from(n).map(e=>g.Hash.fromTrytes(w.Trytes.fromString(e))))).forEach(e=>{0===e.currentIndex.toNumber()&&s.add(l.TransactionHelper.hash(e).toTrytes().toString())})}const i=[],o=Array.from(s);let a;t&&(a=yield this.getLatestInclusion(o.map(e=>g.Hash.fromTrytes(w.Trytes.fromString(e)))));for(let e=0;e<o.length;e++){const t=yield this.getBundle(g.Hash.fromTrytes(w.Trytes.fromString(o[e])));t.inclusionState=a?a[e]:void 0,i.push(t)}return i.sort((e,t)=>{const r=e.transactions[0].attachmentTimestamp.toNumber(),s=t.transactions[0].attachmentTimestamp.toNumber();return r<s?-1:r>s?1:0}),i})}generateAddress(e,t,r,s){const n=d.ISS.key(e,t,r),i=d.ISS.digests(n),o=d.ISS.address(i);let a=_.Trits.fromArray(o).toTrytes().toString();return s&&(a+=H.AddressHelper.createChecksum(o,9)),p.Address.fromTrytes(w.Trytes.fromString(a))}addRemainder(e,t,r,n,i,a,c,u){return s.__awaiter(this,void 0,void 0,function*(){let s=a;for(let a=0;a<n.length;a++){const d=Math.floor(this._timeService.msSinceEpoch()/1e3);if(t.addTransactions(n[a].security,n[a].address,-n[a].balance,c,d),n[a].balance>=s){const l=n[a].balance-s;if(l>0&&!o.ObjectHelper.isEmpty(r)&&o.ObjectHelper.isType(r.remainderAddress,p.Address))t.addTransactions(1,r.remainderAddress,l,c,d),v.BundleHelper.signInputs(e,t,r,i,n,u);else if(l>0){let s=0;for(let e=0;e<n.length;e++)s=Math.max(n[e].keyIndex,s);s++;const o=yield this.getAddressesToUnused(e,s,!1,r.security),a=Math.floor(this._timeService.msSinceEpoch()/1e3);t.addTransactions(1,o[o.length-1],l,c,a),v.BundleHelper.signInputs(e,t,r,i,n,u)}else v.BundleHelper.signInputs(e,t,r,i,n,u)}else s-=n[a].balance}})}}B.NULL_HASH_TRYTES="9".repeat(243),B.MAX_INPUTS=500,t.TransactionClient=B},function(e,t){e.exports=T},function(e,t){e.exports=b},function(e,t){e.exports=m},function(e,t){e.exports=_},function(e,t){e.exports=w},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});const s=r(5),n=r(3),i=r(15),o=r(4),a=r(32),c=r(8),u=r(1),d=r(2);t.ProofOfWorkApi=class{constructor(e){if(o.ObjectHelper.isEmpty(e))throw new d.BusinessError("The apiClient must not be empty");this._apiClient=e}initialize(){return s.__awaiter(this,void 0,void 0,function*(){return Promise.resolve()})}pow(e,t,r,d){return s.__awaiter(this,void 0,void 0,function*(){if(!o.ObjectHelper.isType(e,c.Hash))throw new a.CryptoError("The trunkTransaction must be an object of type Hash");if(!o.ObjectHelper.isType(t,c.Hash))throw new a.CryptoError("The branchTransaction must be an object of type Hash");if(!n.ArrayHelper.isTyped(r,u.Trytes))throw new a.CryptoError("The trytes must be an array of type Trytes");if(!i.NumberHelper.isInteger(d)||d<=0)throw new a.CryptoError("The minWeightMagnitude must be > 0");const s={trunkTransaction:e.toString(),branchTransaction:t.toString(),minWeightMagnitude:d,trytes:r.map(e=>e.toString())},l=yield this._apiClient.attachToTangle(s);if(o.ObjectHelper.isEmpty(l)||n.ArrayHelper.isEmpty(l.trytes))throw new a.CryptoError("The attachToTangleRequest did not return any trytes");return l.trytes.map(e=>u.Trytes.fromString(e))})}}},function(e,t){e.exports=S}])});