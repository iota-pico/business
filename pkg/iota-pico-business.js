(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("@iota-pico/business", [], factory);
	else if(typeof exports === 'object')
		exports["@iota-pico/business"] = factory();
	else
		root["IotaPicoBusiness"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../iota-pico-core/dist/error/coreError.js":
/*!*************************************************!*\
  !*** ../iota-pico-core/dist/error/coreError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

var jsonHelper_1 = __webpack_require__(/*! ../helpers/jsonHelper */ "../iota-pico-core/dist/helpers/jsonHelper.js");

var stringHelper_1 = __webpack_require__(/*! ../helpers/stringHelper */ "../iota-pico-core/dist/helpers/stringHelper.js");
/**
 * A core implementation of an error.
 */


var CoreError =
/*#__PURE__*/
function (_extendableBuiltin2) {
  _inherits(CoreError, _extendableBuiltin2);

  /**
   * Create an instance of CoreError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function CoreError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, CoreError);

    _this = _possibleConstructorReturn(this, (CoreError.__proto__ || Object.getPrototypeOf(CoreError)).call(this, message));
    _this.additional = additional ? additional : {};
    _this.innerError = innerError;
    _this.domain = "Core";
    return _this;
  }
  /**
   * Check if an object could be a CoreError.
   * @param obj The object to check if it is a CoreError.
   * @returns true If the tested object is a CoreError.
   */


  _createClass(CoreError, [{
    key: "format",

    /**
     * Format the error to a readable version.
     */
    value: function format() {
      var _this2 = this;

      var out = "";

      if (!stringHelper_1.StringHelper.isEmpty(this.domain)) {
        out += "".concat(this.domain, ": ");
      }

      if (!stringHelper_1.StringHelper.isEmpty(this.message)) {
        out += "".concat(this.message);
      }

      var keys = Object.keys(this.additional);

      if (keys.length > 0) {
        if (out.length > 0) {
          out += "\n";
        }

        keys.forEach(function (key) {
          out += "\t".concat(key, ": ").concat(jsonHelper_1.JsonHelper.stringify(_this2.additional[key]), "\n");
        });
      }

      return out;
    }
  }], [{
    key: "isError",
    value: function isError(obj) {
      return obj !== undefined && obj !== null && _typeof(obj) === "object" && "message" in obj && "additional" in obj;
    }
  }]);

  return CoreError;
}(_extendableBuiltin(Error));

exports.CoreError = CoreError;

/***/ }),

/***/ "../iota-pico-core/dist/factories/factoryBase.js":
/*!*******************************************************!*\
  !*** ../iota-pico-core/dist/factories/factoryBase.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Factory to generate types.
 * @typeparam T The generic type for the object types in the factory.
 */

var FactoryBase =
/*#__PURE__*/
function () {
  function FactoryBase() {
    _classCallCheck(this, FactoryBase);

    /* @internal */
    this._types = {};
  }
  /**
   * Register a new type with the factory.
   * @param name The name of the type to register.
   * @param typeConstructor The constructor for the type.
   */


  _createClass(FactoryBase, [{
    key: "register",
    value: function register(name, typeConstructor) {
      this.getInstance()._types[name] = typeConstructor;
    }
    /**
     * Unregister a type from the factory.
     * @param name The name of the type to unregister.
     */

  }, {
    key: "unregister",
    value: function unregister(name) {
      delete this.getInstance()._types[name];
    }
    /**
     * Does the factory contain a specific type.
     * @param name The name of the type to look for.
     * @returns True if the type exists.
     */

  }, {
    key: "exists",
    value: function exists(name) {
      return this.getInstance()._types[name] !== undefined;
    }
    /**
     * List the types in the factory.
     * @param name The name of the type to look for.
     * @returns True if the type exists.
     */

  }, {
    key: "types",
    value: function types() {
      return Object.keys(this.getInstance()._types);
    }
    /**
     * Create an instance of an object from the factory.
     * @param name The name of the type to create.
     * @param args Any parameters to pass to the constructor.
     * @returns A new instance of the type if it exists, or undefined if it does not.
     */

  }, {
    key: "create",
    value: function create(name) {
      var instance = this.getInstance();

      if (instance._types[name]) {
        var _instance$_types;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return (_instance$_types = instance._types)[name].apply(_instance$_types, args);
      } else {
        return undefined;
      }
    }
  }]);

  return FactoryBase;
}();

exports.FactoryBase = FactoryBase;

/***/ }),

/***/ "../iota-pico-core/dist/helpers/arrayHelper.js":
/*!*****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/arrayHelper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! ./objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");
/**
 * Array helper methods.
 */


var ArrayHelper =
/*#__PURE__*/
function () {
  function ArrayHelper() {
    _classCallCheck(this, ArrayHelper);
  }

  _createClass(ArrayHelper, null, [{
    key: "isArray",

    /**
     * Is the value an array.
     * @param value Object to test.
     * @returns True if the value is an array.
     */
    value: function isArray(value) {
      return value === null || value === undefined ? false : Array.isArray(value);
    }
    /**
     * Is the value a empty array.
     * @param value Object to test.
     * @returns True if the value is a empty array.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return !ArrayHelper.isArray(value) || value.length === 0;
    }
    /**
     * Is the value a non empty array of specific type.
     * @param value Object to test.
     * @param type The type of the object
     * @returns True if the value is a non empty array of a specific type.
     */

  }, {
    key: "isTyped",
    value: function isTyped(value, type) {
      return !ArrayHelper.isEmpty(value) && !value.includes(undefined) && !value.includes(null) && value.every(function (a) {
        return objectHelper_1.ObjectHelper.isType(a, type);
      });
    }
  }]);

  return ArrayHelper;
}();

exports.ArrayHelper = ArrayHelper;

/***/ }),

/***/ "../iota-pico-core/dist/helpers/jsonHelper.js":
/*!****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/jsonHelper.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Json helper methods.
 */

var JsonHelper =
/*#__PURE__*/
function () {
  function JsonHelper() {
    _classCallCheck(this, JsonHelper);
  }

  _createClass(JsonHelper, null, [{
    key: "stringify",

    /**
     * Stringify an object with recursion breaking.
     * @param value A JavaScript value, usually an object or array, to be converted.
     * @param replacer A function that transforms the results.
     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
     * @returns String version of the object.
     */
    value: function stringify(value, replacer, space) {
      // eliminates any recursion in the stringify
      var cache = [];

      var recusionReplacer = function recusionReplacer(key, replaceValue) {
        if (_typeof(replaceValue) === "object" && value !== null && replaceValue !== undefined) {
          if (cache.indexOf(replaceValue) !== -1) {
            // circular reference found, discard key
            return;
          } else {
            cache.push(replaceValue);
          }
        }

        return replacer ? replacer(key, replaceValue) : replaceValue;
      };

      return JSON.stringify(value, recusionReplacer, space);
    }
  }]);

  return JsonHelper;
}();

exports.JsonHelper = JsonHelper;

/***/ }),

/***/ "../iota-pico-core/dist/helpers/numberHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/numberHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Number helper methods.
 */

var NumberHelper =
/*#__PURE__*/
function () {
  function NumberHelper() {
    _classCallCheck(this, NumberHelper);
  }

  _createClass(NumberHelper, null, [{
    key: "isInteger",

    /**
     * Is the value an integer.
     * @param value Object to test for its integerness.
     * @returns True if the object is a integer.
     */
    value: function isInteger(value) {
      return Number.isInteger(value) && !Number.isNaN(value) && Number.isFinite(value);
    }
    /**
     * Is the value a number.
     * @param value Object to test for its numberyness.
     * @returns True if the object is a number.
     */

  }, {
    key: "isNumber",
    value: function isNumber(value) {
      return value !== undefined && value !== null && typeof value === "number" && !Number.isNaN(value) && Number.isFinite(value);
    }
    /**
     * Is the value a float number formatted as a string, can be used for big numbers that would overflow parseFloat.
     * @param value The value to check
     * @returns True if the number is formatted correctly.
     */

  }, {
    key: "isFloatString",
    value: function isFloatString(value) {
      return /^-?\d*\.?\d+$/.test(value);
    }
    /**
     * Is the value a integer number formatted as a string, can be used for big numbers that would overflow parseInt.
     * @param value The value to check
     * @returns True if the number is formatted correctly.
     */

  }, {
    key: "isIntegerString",
    value: function isIntegerString(value) {
      return /^-?\d+$/.test(value);
    }
  }]);

  return NumberHelper;
}();

exports.NumberHelper = NumberHelper;

/***/ }),

/***/ "../iota-pico-core/dist/helpers/objectHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/objectHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Object helper methods.
 */

var ObjectHelper =
/*#__PURE__*/
function () {
  function ObjectHelper() {
    _classCallCheck(this, ObjectHelper);
  }

  _createClass(ObjectHelper, null, [{
    key: "isEmpty",

    /**
     * Is the value empty.
     * @param value Object to test.
     * @returns True if the value is empty.
     */
    value: function isEmpty(value) {
      return value === null || value === undefined;
    }
    /**
     * Is the value an object.
     * @param value Object to test.
     * @returns True if the value is an object.
     */

  }, {
    key: "isObject",
    value: function isObject(value) {
      return value === null || value === undefined ? false : _typeof(value) === "object" && !Array.isArray(value);
    }
    /**
     * Is the value an object if given type.
     * @param value Object to test.
     * @param type The type of the object
     * @returns True if the value is an object of the specified type.
     */

  }, {
    key: "isType",
    value: function isType(value, typeConstructor) {
      var valueClassName = ObjectHelper.getClassName(value);
      return valueClassName !== undefined && valueClassName === ObjectHelper.getClassName(typeConstructor);
    }
    /**
     * Get the class name of an object if it has one.
     * @param object The object to get the class name for.
     * @returns The class name if it has one or undefined if not.
     */

  }, {
    key: "getClassName",
    value: function getClassName(object) {
      if (object === null || object === undefined) {
        return undefined;
      } else {
        var _constructor = typeof object === "function" ? object.toString() : object.constructor.toString();

        var results = _constructor.match(/\w+/g);

        return results && results.length > 1 ? results[1] : undefined;
      }
    }
  }]);

  return ObjectHelper;
}();

exports.ObjectHelper = ObjectHelper;

/***/ }),

/***/ "../iota-pico-core/dist/helpers/stringHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/stringHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * String helper methods.
 */

var StringHelper =
/*#__PURE__*/
function () {
  function StringHelper() {
    _classCallCheck(this, StringHelper);
  }

  _createClass(StringHelper, null, [{
    key: "isString",

    /**
     * Is the value a string.
     * @param value Object to test for its stringyness.
     * @returns True if the object is a string.
     */
    value: function isString(value) {
      return value === null || value === undefined ? false : Object.prototype.toString.call(value) === "[object String]";
    }
    /**
     * Is the value a string that is empty.
     * @param value Object to test for its no emptyness.
     * @returns True if the object is an empty string.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty(value) {
      return !StringHelper.isString(value) || value.length === 0;
    }
    /**
     * Is the string all ASCII characters.
     * @param value string to test if is is ASCII.
     * @returns True if the object is all ASCII.
     */

  }, {
    key: "isAscii",
    value: function isAscii(value) {
      return value === null || value === undefined ? false : /^[\x00-\xFF]*$/.test(value);
    }
    /**
     * Encode non ASCII characters with control characters.
     * @param value The string value to escape.
     * @returns The escaped version of the string.
     */

  }, {
    key: "encodeNonASCII",
    value: function encodeNonASCII(value) {
      return StringHelper.isString(value) ? value.replace(/[\u007F-\uFFFF]/g, function (chr) {
        return "\\u".concat("0000".concat(chr.charCodeAt(0).toString(16)).substr(-4));
      }) : undefined;
    }
    /**
     * Decode control characters to ASCII.
     * @param value The encoded string to convert back to ASCII.
     * @returns The decoded version of the string.
     */

  }, {
    key: "decodeNonASCII",
    value: function decodeNonASCII(value) {
      return StringHelper.isString(value) ? value.replace(/\\u([\d\w]{4})/gi, function (match, grp) {
        return String.fromCharCode(parseInt(grp, 16));
      }) : undefined;
    }
  }]);

  return StringHelper;
}();

exports.StringHelper = StringHelper;

/***/ }),

/***/ "../iota-pico-core/dist/loggers/nullLogger.js":
/*!****************************************************!*\
  !*** ../iota-pico-core/dist/loggers/nullLogger.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Implementation of ILogger which is silent.
 */

var NullLogger =
/*#__PURE__*/
function () {
  function NullLogger() {
    _classCallCheck(this, NullLogger);
  }

  _createClass(NullLogger, [{
    key: "banner",

    /**
     * Send banner to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */
    value: function banner(message) {}
    /**
     * Send log to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "log",
    value: function log(message) {}
    /**
     * Send information to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "info",
    value: function info(message) {}
    /**
     * Send warning to the logger.
     * @param message The message to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "warning",
    value: function warning(message) {}
    /**
     * Send error to the logger.
     * @param message The message to log.
     * @param err An error object to log.
     * @param args Additional parameters to log.
     */

  }, {
    key: "error",
    value: function error(message, err) {}
  }]);

  return NullLogger;
}();

exports.NullLogger = NullLogger;

/***/ }),

/***/ "../iota-pico-core/dist/services/backgroundTaskService.js":
/*!****************************************************************!*\
  !*** ../iota-pico-core/dist/services/backgroundTaskService.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Default implementation of background task service.
 */

var BackgroundTaskService =
/*#__PURE__*/
function () {
  function BackgroundTaskService() {
    _classCallCheck(this, BackgroundTaskService);
  }

  _createClass(BackgroundTaskService, [{
    key: "create",

    /**
     * Create a background task.
     * @param task The task to run in the background.
     * @param delay The delay before running the task.
     */
    value: function () {
      var _create = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(task, delay) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  setTimeout(function () {
                    try {
                      resolve(task());
                    } catch (err) {
                      reject(err);
                    }
                  }, delay);
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function create(_x, _x2) {
        return _create.apply(this, arguments);
      };
    }()
  }]);

  return BackgroundTaskService;
}();

exports.BackgroundTaskService = BackgroundTaskService;

/***/ }),

/***/ "../iota-pico-core/dist/services/timeService.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/services/timeService.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Represents a class which can provide the time.
 */

var TimeService =
/*#__PURE__*/
function () {
  function TimeService() {
    _classCallCheck(this, TimeService);
  }

  _createClass(TimeService, [{
    key: "msSinceEpoch",

    /**
     * Returns the number of milliseconds since 1970/01/01.
     * @returns Number of milliseconds.
     */
    value: function msSinceEpoch() {
      return Date.now();
    }
  }]);

  return TimeService;
}();

exports.TimeService = TimeService;

/***/ }),

/***/ "../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js":
/*!**************************************************************************!*\
  !*** ../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js");


/***/ }),

/***/ "../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js":
/*!****************************************************************************!*\
  !*** ../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ "../iota-pico-core/node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ "../iota-pico-core/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************!*\
  !*** ../iota-pico-core/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),

/***/ "../iota-pico-crypto/dist/digests/sha3.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/digests/sha3.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../iota-pico-crypto/dist/error/cryptoError.js");
/**
 * Sha3 implementation.
 */


var Sha3 =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of SHA3.
   * @param bits The number of input bits.
   * @param padding The padding to use.
   * @param outputBits The number of output bits.
   */
  function Sha3(bits, padding, outputBits) {
    _classCallCheck(this, Sha3);

    this._padding = padding;
    this._outputBits = outputBits;
    this._blockCount = 1600 - (bits << 1) >> 5;
    this._byteCount = this._blockCount << 2;
    this._outputBlocks = outputBits >> 5;
    this._extraBytes = (outputBits & 31) >> 3;
    this.reset();
  }
  /**
   * Reset the digest.
   */


  _createClass(Sha3, [{
    key: "reset",
    value: function reset() {
      this._reset = true;
      this._block = 0;
      this._start = 0;
      this._blocks = new Uint32Array(this._blockCount + 1);
      this._state = new Uint32Array(50);
    }
    /**
     * Update the digest.
     * @param input Array of data to use in the update.
     */

  }, {
    key: "update",
    value: function update(input) {
      if (!objectHelper_1.ObjectHelper.isType(input, ArrayBuffer)) {
        throw new cryptoError_1.CryptoError("Input is not of type ArrayBuffer");
      }

      var message = new Uint8Array(input);
      var length = message.length;
      var index = 0;
      var i;

      while (index < length) {
        if (this._reset) {
          this._reset = false;
          this._blocks[0] = this._block;

          for (i = 1; i < this._blockCount + 1; ++i) {
            this._blocks[i] = 0;
          }
        }

        for (i = this._start; index < length && i < this._byteCount; ++index) {
          this._blocks[i >> 2] |= message[index] << Sha3.SHIFT[i++ & 3];
        }

        this._lastByteIndex = i;

        if (i >= this._byteCount) {
          this._start = i - this._byteCount;
          this._block = this._blocks[this._blockCount];

          for (i = 0; i < this._blockCount; ++i) {
            this._state[i] ^= this._blocks[i];
          }

          this.keccakPermutation(this._state);
          this._reset = true;
        } else {
          this._start = i;
        }
      }
    }
    /**
     * Finalize and return the hash for the digest, will also reset the state.
     * @returns Array buffer containing the digest.
     */

  }, {
    key: "digest",
    value: function digest() {
      this.finalize();
      var i = 0;
      var j = 0;
      var bytes = this._outputBits >> 3;
      var buffer;

      if (this._extraBytes) {
        buffer = new ArrayBuffer(this._outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }

      var array = new Uint32Array(buffer);

      while (j < this._outputBlocks) {
        for (i = 0; i < this._blockCount && j < this._outputBlocks; ++i, ++j) {
          array[j] = this._state[i];
        }
      }

      if (this._extraBytes) {
        array[i] = this._state[i];
        buffer = buffer.slice(0, bytes);
      }

      this.reset();
      return buffer;
    }
    /* @internal */

  }, {
    key: "finalize",
    value: function finalize() {
      var i = this._lastByteIndex;
      this._blocks[i >> 2] |= this._padding[i & 3];

      if (this._lastByteIndex === this._byteCount) {
        this._blocks[0] = this._blocks[this._blockCount];

        for (i = 1; i < this._blockCount + 1; ++i) {
          this._blocks[i] = 0;
        }
      }

      this._blocks[this._blockCount - 1] |= 0x80000000;

      for (i = 0; i < this._blockCount; ++i) {
        this._state[i] ^= this._blocks[i];
      }

      this.keccakPermutation(this._state);
    }
    /* @internal */

  }, {
    key: "keccakPermutation",
    value: function keccakPermutation(s) {
      // tslint:disable-next-line:one-variable-per-declaration
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;

      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= Sha3.ROUND_CONSTANTS[n];
        s[1] ^= Sha3.ROUND_CONSTANTS[n + 1];
      }
    }
  }]);

  return Sha3;
}();
/* Padding to use for Keccak */


Sha3.KECCAK_PADDING = new Uint32Array([1, 256, 65536, 16777216]);
/* @internal */

Sha3.SHIFT = new Uint8Array([0, 8, 16, 24]);
/* @internal */

Sha3.ROUND_CONSTANTS = new Uint32Array([1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]);
exports.Sha3 = Sha3;

/***/ }),

/***/ "../iota-pico-crypto/dist/error/cryptoError.js":
/*!*****************************************************!*\
  !*** ../iota-pico-crypto/dist/error/cryptoError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ "../iota-pico-core/dist/error/coreError.js");
/**
 * A crypto implementation of an error.
 */


var CryptoError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(CryptoError, _coreError_1$CoreErro);

  /**
   * Create an instance of CryptoError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function CryptoError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, CryptoError);

    _this = _possibleConstructorReturn(this, (CryptoError.__proto__ || Object.getPrototypeOf(CryptoError)).call(this, message, additional, innerError));
    _this.domain = "Crypto";
    return _this;
  }

  return CryptoError;
}(coreError_1.CoreError);

exports.CryptoError = CryptoError;

/***/ }),

/***/ "../iota-pico-crypto/dist/factories/spongeFactory.js":
/*!***********************************************************!*\
  !*** ../iota-pico-crypto/dist/factories/spongeFactory.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var factoryBase_1 = __webpack_require__(/*! @iota-pico/core/dist/factories/factoryBase */ "../iota-pico-core/dist/factories/factoryBase.js");

var curl_1 = __webpack_require__(/*! ../sponges/curl */ "../iota-pico-crypto/dist/sponges/curl.js");

var kerl_1 = __webpack_require__(/*! ../sponges/kerl */ "../iota-pico-crypto/dist/sponges/kerl.js");
/**
 * Factory to generate sponges.
 */


var SpongeFactory =
/*#__PURE__*/
function (_factoryBase_1$Factor) {
  _inherits(SpongeFactory, _factoryBase_1$Factor);

  /**
   * Don't allow manual construction of the factory.
   * @internal
   */
  function SpongeFactory() {
    _classCallCheck(this, SpongeFactory);

    return _possibleConstructorReturn(this, (SpongeFactory.__proto__ || Object.getPrototypeOf(SpongeFactory)).call(this));
  }
  /**
   * Get the instance of the factory.
   * @returns The factory instance.
   */


  _createClass(SpongeFactory, [{
    key: "getInstance",

    /* @internal */
    value: function getInstance() {
      return SpongeFactory.instance();
    }
  }], [{
    key: "instance",
    value: function instance() {
      if (!SpongeFactory._instance) {
        SpongeFactory._instance = new SpongeFactory();

        SpongeFactory._instance.register("curl", function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          return new (Function.prototype.bind.apply(curl_1.Curl, [null].concat(args)))();
        });

        SpongeFactory._instance.register("curl81", function () {
          return new curl_1.Curl(81);
        });

        SpongeFactory._instance.register("curl27", function () {
          return new curl_1.Curl(27);
        });

        SpongeFactory._instance.register("kerl", function () {
          return new kerl_1.Kerl();
        });
      }

      return SpongeFactory._instance;
    }
  }]);

  return SpongeFactory;
}(factoryBase_1.FactoryBase);

exports.SpongeFactory = SpongeFactory;

/***/ }),

/***/ "../iota-pico-crypto/dist/hash/iss.js":
/*!********************************************!*\
  !*** ../iota-pico-crypto/dist/hash/iss.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../iota-pico-core/dist/helpers/arrayHelper.js");

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ "../iota-pico-data/dist/data/address.js");

var addressSecurity_1 = __webpack_require__(/*! @iota-pico/data/dist/data/addressSecurity */ "../iota-pico-data/dist/data/addressSecurity.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../iota-pico-data/dist/data/hash.js");

var signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ "../iota-pico-data/dist/data/signatureMessageFragment.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../iota-pico-data/dist/data/trytes.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../iota-pico-crypto/dist/error/cryptoError.js");

var spongeFactory_1 = __webpack_require__(/*! ../factories/spongeFactory */ "../iota-pico-crypto/dist/factories/spongeFactory.js");
/**
 * ISS Hashing functions.
 * Converted https://github.com/iotaledger/iri/src/main/java/com/iota/iri/hash/ISS.java
 */


var ISS =
/*#__PURE__*/
function () {
  function ISS() {
    _classCallCheck(this, ISS);
  }

  _createClass(ISS, null, [{
    key: "subseed",

    /**
     * Get the subseed for the seed and index.
     * @param seed The seed.
     * @param index The index for the seed.
     * @param spongeType The sponge type to use for operations.
     * @returns The subseed.
     */
    value: function subseed(seed, index) {
      var spongeType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "curl27";

      if (!objectHelper_1.ObjectHelper.isType(seed, Int8Array)) {
        throw new cryptoError_1.CryptoError("The seed must be of type Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {
        throw new cryptoError_1.CryptoError("The index must be an integer >= 0");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var sponge = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = sponge.getConstant("HASH_LENGTH");
      sponge.initialize();
      var subseedPreimage = seed.slice();
      var localIndex = index;

      while (localIndex-- > 0) {
        for (var i = 0; i < subseedPreimage.length; i++) {
          if (++subseedPreimage[i] > ISS.MAX_TRIT_VALUE) {
            subseedPreimage[i] = ISS.MIN_TRIT_VALUE;
          } else {
            break;
          }
        }
      }

      var subseed = new Int8Array(hashLength);
      sponge.absorb(subseedPreimage, 0, subseedPreimage.length);
      sponge.squeeze(subseed, 0, subseed.length);
      return subseed;
    }
    /**
     * Create the key for the seed.
     * @param seed The seed to create the key for.
     * @param index The index to use for the seed.
     * @param length The security level to create the key.
     * @param spongeType The sponge type to use for operations.
     * @returns the key.
     */

  }, {
    key: "key",
    value: function key(seed, index, security) {
      var spongeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "kerl";

      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
        throw new cryptoError_1.CryptoError("The seed must be of type Hash");
      }

      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {
        throw new cryptoError_1.CryptoError("The index must be an integer >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < addressSecurity_1.AddressSecurity.low || security > addressSecurity_1.AddressSecurity.high) {
        throw new cryptoError_1.CryptoError("The security must be an integer >= 1 and <= 3");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var seedTrits = trits_1.Trits.fromTrytes(seed.toTrytes());
      var indexTrits = trits_1.Trits.fromNumber(index);
      var subseed = trits_1.Trits.add(seedTrits, indexTrits).toArray();
      var subseedLength = subseed.length;
      var sponge = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = sponge.getConstant("HASH_LENGTH");
      sponge.initialize();
      sponge.absorb(subseed, 0, subseedLength);
      sponge.squeeze(subseed, 0, subseedLength);
      sponge.reset();
      sponge.absorb(subseed, 0, subseedLength);
      var key = new Int8Array(ISS.NUMBER_OF_FRAGMENT_CHUNKS * hashLength * security);
      var offset = 0;
      var buffer = new Int8Array(subseedLength);
      var localLength = security;

      while (localLength-- > 0) {
        for (var i = 0; i < ISS.NUMBER_OF_FRAGMENT_CHUNKS; i++) {
          sponge.squeeze(buffer, 0, subseedLength);

          for (var j = 0; j < hashLength; j++) {
            key[offset++] = buffer[j];
          }
        }
      }

      return key;
    }
    /**
     * Create the digests for the given subseed.
     * @param subseed To create the digests for.
     * @param spongeType The sponge type to use for operations.
     * @returns The digests.
     */

  }, {
    key: "digests",
    value: function digests(subseed) {
      var spongeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "kerl";

      if (!objectHelper_1.ObjectHelper.isType(subseed, Int8Array)) {
        throw new cryptoError_1.CryptoError("The subseed must be of type Int8Array");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var sponge = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = sponge.getConstant("HASH_LENGTH");
      var fragmentLength = hashLength * ISS.NUMBER_OF_FRAGMENT_CHUNKS;

      if (subseed.length % fragmentLength !== 0) {
        throw new cryptoError_1.CryptoError("The subseed length must be a multiple of ".concat(fragmentLength));
      }

      var tryteRange = ISS.MAX_TRYTE_VALUE - ISS.MIN_TRYTE_VALUE;
      var keyLenDiv = subseed.length / fragmentLength;
      var digests = new Int8Array(keyLenDiv * hashLength);
      var buffer;

      for (var i = 0; i < keyLenDiv; i++) {
        var iMul = i * fragmentLength;
        var keyFragment = subseed.slice(iMul, iMul + fragmentLength);

        for (var j = 0; j < ISS.NUMBER_OF_FRAGMENT_CHUNKS; j++) {
          var jMul = j * hashLength;
          buffer = keyFragment.slice(jMul, jMul + hashLength);

          for (var k = 0; k < tryteRange; k++) {
            sponge.reset();
            sponge.absorb(buffer, 0, buffer.length);
            sponge.squeeze(buffer, 0, hashLength);
          }

          for (var _k = 0; _k < hashLength; _k++) {
            keyFragment[jMul + _k] = buffer[_k];
          }
        }

        sponge.reset();
        sponge.absorb(keyFragment, 0, keyFragment.length);
        sponge.squeeze(buffer, 0, hashLength);
        var iMul2 = i * hashLength;

        for (var _j = 0; _j < hashLength; _j++) {
          digests[iMul2 + _j] = buffer[_j];
        }
      }

      return digests;
    }
    /**
     * Create the address for the digests.
     * @param digests The digests to create the address for.
     * @param spongeType The sponge type to use for operations.
     * @returns the address trits.
     */

  }, {
    key: "address",
    value: function address(digests) {
      var spongeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "kerl";

      if (!objectHelper_1.ObjectHelper.isType(digests, Int8Array)) {
        throw new cryptoError_1.CryptoError("The digests must be of type Int8Array");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var sponge = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = sponge.getConstant("HASH_LENGTH");

      if (digests.length % hashLength !== 0) {
        throw new cryptoError_1.CryptoError("Invalid digests length, must be a multiple of ".concat(hashLength));
      }

      sponge.initialize();
      sponge.absorb(digests, 0, digests.length);
      var addressTrits = new Int8Array(hashLength);
      sponge.squeeze(addressTrits, 0, addressTrits.length);
      return addressTrits;
    }
    /**
     * Create digest of the normalized bundle fragment.
     * @param normalizedBundleFragment The fragment to create digest.
     * @param signatureMessageFragment The trits for signature message fragment.
     * @param spongeType The sponge type to use for operations.
     * @returns The digest of the bundle and signature message fragment.
     */

  }, {
    key: "digest",
    value: function digest(normalizedBundleFragment, signatureMessageFragment) {
      var spongeType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "kerl";

      if (!objectHelper_1.ObjectHelper.isType(normalizedBundleFragment, Int8Array)) {
        throw new cryptoError_1.CryptoError("The normalizedBundleFragment must be of type Int8Array");
      }

      if (!objectHelper_1.ObjectHelper.isType(signatureMessageFragment, Int8Array)) {
        throw new cryptoError_1.CryptoError("The signatureMessageFragment must be of type Int8Array");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var buffer;
      var sponge = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = sponge.getConstant("HASH_LENGTH");
      sponge.initialize();

      for (var i = 0; i < ISS.NUMBER_OF_FRAGMENT_CHUNKS; i++) {
        buffer = new Int8Array(signatureMessageFragment.slice(i * hashLength, (i + 1) * hashLength));

        for (var j = normalizedBundleFragment[i] - ISS.MIN_TRYTE_VALUE; j > 0; j--) {
          var sponge2 = spongeFactory_1.SpongeFactory.instance().create(spongeType);
          sponge2.initialize();
          sponge2.absorb(buffer, 0, buffer.length);
          sponge2.squeeze(buffer, 0, sponge2.getConstant("HASH_LENGTH"));
        }

        sponge.absorb(buffer, 0, buffer.length);
      }

      sponge.squeeze(buffer, 0, sponge.getConstant("HASH_LENGTH"));
      return buffer;
    }
    /**
     * Get the digest for the subseed.
     * @param subseed The subseed to get the digest for.
     * @param security The security level.
     * @param spongeType The sponge type to use for operations.
     * @returns The digest.
     */

  }, {
    key: "subseedToDigest",
    value: function subseedToDigest(subseed, security) {
      var spongeType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "curl27";

      if (!objectHelper_1.ObjectHelper.isType(subseed, Int8Array)) {
        throw new cryptoError_1.CryptoError("The subseed must be of type Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < addressSecurity_1.AddressSecurity.low || security > addressSecurity_1.AddressSecurity.high) {
        throw new cryptoError_1.CryptoError("The security must be an integer >= 1 and <= 3");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var c1 = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var c2 = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var c3 = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      c1.initialize();
      c2.initialize();
      c3.initialize();
      var hashLength = c1.getConstant("HASH_LENGTH");
      var keyLength = hashLength / 3 / ISS.RADIX * hashLength;
      var length = security * keyLength / hashLength;
      var out = new Int8Array(hashLength);
      c1.absorb(subseed, 0, subseed.length);

      for (var i = 0; i < length; i++) {
        c1.squeeze(out, 0, out.length);

        for (var j = 0; j < ISS.MAX_TRYTE_VALUE - ISS.MIN_TRYTE_VALUE + 1; j++) {
          c2.reset();
          c2.absorb(out, 0, out.length);
          out = c2.getState().slice(0, hashLength);
        }

        c3.absorb(out, 0, out.length);
      }

      c3.squeeze(out, 0, out.length);
      return out;
    }
    /**
     * Create a normalized bundle.
     * @param bundleHash The hash of the bundle.
     * @param spongeType The sponge type to use for operations.
     * @returns the normalized bundle.
     */

  }, {
    key: "normalizedBundle",
    value: function normalizedBundle(bundleHash) {
      var spongeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "curl81";

      if (!objectHelper_1.ObjectHelper.isType(bundleHash, hash_1.Hash)) {
        throw new cryptoError_1.CryptoError("The bundleHash must be of type Hash");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var sponge = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = sponge.getConstant("HASH_LENGTH");
      var normalizedBundle = new Int8Array(ISS.NUMBER_OF_FRAGMENT_CHUNKS * ISS.NUMBER_OF_SECURITY_LEVELS);
      var hashString = bundleHash.toTrytes().toString();
      var normalizedFragmentLength = hashLength / ISS.TRYTE_WIDTH / ISS.NUMBER_OF_SECURITY_LEVELS;

      for (var i = 0; i < ISS.NUMBER_OF_SECURITY_LEVELS; i++) {
        var sum = 0;

        for (var j = 0; j < normalizedFragmentLength; j++) {
          var hashChar = hashString.charAt(i * normalizedFragmentLength + j);
          var val = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(hashChar)).toNumber();
          normalizedBundle[i * normalizedFragmentLength + j] = val;
          sum += val;
        }

        if (sum >= 0) {
          while (sum-- > 0) {
            for (var _j2 = 0; _j2 < normalizedFragmentLength; _j2++) {
              if (normalizedBundle[i * normalizedFragmentLength + _j2] > ISS.MIN_TRYTE_VALUE) {
                normalizedBundle[i * normalizedFragmentLength + _j2]--;
                break;
              }
            }
          }
        } else {
          while (sum++ < 0) {
            for (var _j3 = 0; _j3 < normalizedFragmentLength; _j3++) {
              if (normalizedBundle[i * normalizedFragmentLength + _j3] < ISS.MAX_TRYTE_VALUE) {
                normalizedBundle[i * normalizedFragmentLength + _j3]++;
                break;
              }
            }
          }
        }
      }

      return normalizedBundle;
    }
    /**
     * Validate the signature fragments from the address.
     * @param expectedAddress The address.
     * @param signatureMessageFragments The signature message fragments.
     * @param bundleHash The hash for the bundle.
     * @param spongeType The sponge type to use for operations.
     * @returns True if the signature message fragment are signed by the expected address.
     */

  }, {
    key: "validateSignatures",
    value: function validateSignatures(expectedAddress, signatureMessageFragments, bundleHash) {
      var spongeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "kerl";

      if (!objectHelper_1.ObjectHelper.isType(expectedAddress, address_1.Address)) {
        throw new cryptoError_1.CryptoError("The expectedAddress must be of type Hash");
      }

      if (!arrayHelper_1.ArrayHelper.isTyped(signatureMessageFragments, signatureMessageFragment_1.SignatureMessageFragment)) {
        throw new cryptoError_1.CryptoError("The signatureMessageFragments must be an array of type SignatureMessageFragment");
      }

      if (!objectHelper_1.ObjectHelper.isType(bundleHash, hash_1.Hash)) {
        throw new cryptoError_1.CryptoError("The bundleHash must be of type Hash");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var normalizedBundleFragments = [];
      var normalizedBundleHash = ISS.normalizedBundle(bundleHash);
      var sponge = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = sponge.getConstant("HASH_LENGTH");

      for (var f = 0; f < 3; f++) {
        normalizedBundleFragments[f] = normalizedBundleHash.slice(f * ISS.NUMBER_OF_FRAGMENT_CHUNKS, (f + 1) * ISS.NUMBER_OF_FRAGMENT_CHUNKS);
      }

      var digests = new Int8Array(signatureMessageFragments.length * hashLength);

      for (var i = 0; i < signatureMessageFragments.length; i++) {
        var digestBuffer = ISS.digest(normalizedBundleFragments[i % 3], trits_1.Trits.fromTrytes(signatureMessageFragments[i].toTrytes()).toArray());

        for (var j = 0; j < hashLength; j++) {
          digests[i * hashLength + j] = digestBuffer[j];
        }
      }

      return expectedAddress.toTrytes().toString() === trits_1.Trits.fromArray(ISS.address(digests)).toTrytes().toString();
    }
    /**
     * Create a signed signature message fragment.
     * @param normalizedBundleFragment The fragment to sign.
     * @param keyFragment The key fragment to sign with.
     * @param spongeType The sponge type to use for operations.
     * @returns The signed fragment.
     */

  }, {
    key: "signatureMessageFragment",
    value: function signatureMessageFragment(normalizedBundleFragment, keyFragment) {
      var spongeType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "kerl";

      if (!objectHelper_1.ObjectHelper.isType(normalizedBundleFragment, Int8Array)) {
        throw new cryptoError_1.CryptoError("The normalizedBundleFragment must be of type Int8Array");
      }

      if (!objectHelper_1.ObjectHelper.isType(keyFragment, Int8Array)) {
        throw new cryptoError_1.CryptoError("The keyFragment must be of type Int8Array");
      }

      if (!spongeFactory_1.SpongeFactory.instance().exists(spongeType)) {
        throw new cryptoError_1.CryptoError("The spongeType must be one of [".concat(spongeFactory_1.SpongeFactory.instance().types().join(", "), "]"));
      }

      var signatureMessageFragment = keyFragment.slice();
      var hash;
      var kerl = spongeFactory_1.SpongeFactory.instance().create(spongeType);
      var hashLength = kerl.getConstant("HASH_LENGTH");

      for (var i = 0; i < 27; i++) {
        hash = signatureMessageFragment.slice(i * hashLength, (i + 1) * hashLength);

        for (var j = 0; j < 13 - normalizedBundleFragment[i]; j++) {
          kerl.initialize();
          kerl.reset();
          kerl.absorb(hash, 0, hashLength);
          kerl.squeeze(hash, 0, hashLength);
        }

        for (var _j4 = 0; _j4 < hashLength; _j4++) {
          signatureMessageFragment[i * hashLength + _j4] = hash[_j4];
        }
      }

      return signatureMessageFragment;
    }
  }]);

  return ISS;
}();
/* @internal */


ISS.NUMBER_OF_FRAGMENT_CHUNKS = 27;
/* @internal */

ISS.NUMBER_OF_SECURITY_LEVELS = 3;
/* @internal */

ISS.TRYTE_WIDTH = 3;
/* @internal */

ISS.MIN_TRYTE_VALUE = -13;
/* @internal */

ISS.MAX_TRYTE_VALUE = 13;
/* @internal */

ISS.MIN_TRIT_VALUE = -1;
/* @internal */

ISS.MAX_TRIT_VALUE = 1;
/* @internal */

ISS.RADIX = 3;
exports.ISS = ISS;

/***/ }),

/***/ "../iota-pico-crypto/dist/helpers/bigIntegerHelper.js":
/*!************************************************************!*\
  !*** ../iota-pico-crypto/dist/helpers/bigIntegerHelper.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js"); // tslint:disable-next-line:import-name


var big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ "../iota-pico-crypto/node_modules/big-integer/BigInteger.js"));

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../iota-pico-crypto/dist/error/cryptoError.js");
/**
 * Helper class to convert between BigInteger and other types.
 * Converted from https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java
 */


var BigIntegerHelper =
/*#__PURE__*/
function () {
  function BigIntegerHelper() {
    _classCallCheck(this, BigIntegerHelper);
  }

  _createClass(BigIntegerHelper, null, [{
    key: "tritsToBigInteger",

    /**
     * Convert trits to a bigInteger.
     * @param trits The trits to convert.
     * @param offset Offset within the array to start.
     * @param length The length of the trits array to convert.
     */
    value: function tritsToBigInteger(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("The trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (offset + length > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the array");
      }

      var value = big_integer_1.default.zero;

      for (var i = length - 1; i >= 0; i--) {
        value = value.multiply(BigIntegerHelper.RADIX).add(big_integer_1.default(trits[offset + i]));
      }

      return value;
    }
    /**
     * Convert bigInteger to trits.
     * @param value The bigInteger to convert to trits.
     * @param trits The array to receive the trits.
     * @param offset The offset to place the trits in the array.
     * @param length The length of the array.
     */

  }, {
    key: "bigIntegerToTrits",
    value: function bigIntegerToTrits(value, trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {
        throw new cryptoError_1.CryptoError("The value must be a bigInteger type");
      }

      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array)) {
        throw new cryptoError_1.CryptoError("The trits must be an Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (offset + length > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the array");
      }

      var absoluteValue = value.compareTo(big_integer_1.default.zero) < 0 ? value.negate() : value;

      for (var i = 0; i < length; i++) {
        var divRemainder = absoluteValue.divmod(BigIntegerHelper.RADIX);
        absoluteValue = divRemainder.quotient;
        var remainder = divRemainder.remainder;

        if (remainder > BigIntegerHelper.MAX_TRIT_VALUE) {
          remainder = BigIntegerHelper.MIN_TRIT_VALUE;
          absoluteValue = absoluteValue.add(big_integer_1.default["1"]);
        }

        trits[offset + i] = remainder.toJSNumber();
      }

      if (value.compareTo(big_integer_1.default.zero) < 0) {
        for (var _i = 0; _i < length; _i++) {
          // Avoid negative zero
          trits[offset + _i] = trits[offset + _i] === 0 ? 0 : -trits[offset + _i];
        }
      }
    }
    /**
     * Convert the bigInteger into bytes.
     * @param value The value to convert.
     * @param destination The destination array to store the bytes.
     * @param offset The offset within the array to store the bytes.
     */

  }, {
    key: "bigIntegerToBytes",
    value: function bigIntegerToBytes(value, destination, offset) {
      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {
        throw new cryptoError_1.CryptoError("The value must be a bigInteger type");
      }

      if (!objectHelper_1.ObjectHelper.isType(destination, ArrayBuffer) || destination.byteLength === 0) {
        throw new cryptoError_1.CryptoError("The destination must be an array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (destination.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {
        throw new cryptoError_1.CryptoError("Destination array has invalid size, it must be at least ".concat(BigIntegerHelper.BYTE_HASH_LENGTH));
      } // Remember if it is negative for later


      var isNeg = value.isNegative() ? -1 : 0;
      var hexString = value.toString(16);

      if (isNeg === -1) {
        // But remove it for now
        hexString = hexString.slice(1);
      } // Now make sure the hex string is an even length so the regex works


      if (hexString.length % 2 === 1) {
        hexString = "0".concat(hexString);
      }

      var matches = hexString.match(/[0-9a-f]{2}/g); // Convert the hex to numbers

      var signedBytes = new Int8Array(matches.map(function (hex) {
        return parseInt("0x".concat(hex), 16);
      }));

      if (isNeg === -1) {
        BigIntegerHelper.twosComplement(signedBytes);
      }

      var dataView = new DataView(destination); // Pad the start of the buffer with the neg value

      var i = offset;

      while (i + signedBytes.length < BigIntegerHelper.BYTE_HASH_LENGTH) {
        dataView.setInt8(i++, isNeg);
      } // And copy in the actual bytes


      for (var j = signedBytes.length; j-- > 0;) {
        dataView.setInt8(i++, signedBytes[signedBytes.length - 1 - j]);
      }
    }
    /**
     * Convert bytes to a bigInteger.
     * @param source The source bytes.
     * @param offset The offset within the bytes to start conversion.
     * @param length The length of the bytes to use for conversion.
     */

  }, {
    key: "bytesToBigInteger",
    value: function bytesToBigInteger(source, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(source, ArrayBuffer) || source.byteLength === 0) {
        throw new cryptoError_1.CryptoError("The source must be a non empty number array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("The offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new cryptoError_1.CryptoError("The length must be a number > 0");
      }

      if (source.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {
        throw new cryptoError_1.CryptoError("Source array has invalid size, it must be at least ".concat(BigIntegerHelper.BYTE_HASH_LENGTH));
      }

      var dataView = new DataView(source);
      var signedBytes = new Int8Array(dataView.byteLength);

      for (var b = 0; b < dataView.byteLength; b++) {
        signedBytes[b] = dataView.getInt8(b + offset);
      } // Remove the initial padding leaving at least one byte


      var paddingOffset = 0;
      var firstByte = signedBytes[0];
      var isNeg = firstByte < 0; // If the first padding character is negative then reverse the 2s complement
      // but first strip of the leading padding

      if (firstByte === 0 || firstByte === -1) {
        while (signedBytes[paddingOffset] === firstByte && paddingOffset < signedBytes.length - 1) {
          paddingOffset++;
        } // Strip any padding


        signedBytes = signedBytes.slice(paddingOffset);
      }

      if (isNeg) {
        BigIntegerHelper.twosComplement(signedBytes);
      }

      var hexString = isNeg ? "-" : "";
      var dv = new DataView(signedBytes.buffer);

      for (var h = 0; h < dv.byteLength; h++) {
        hexString += "00".concat(dv.getUint8(h).toString(16)).slice(-2);
      }

      return big_integer_1.default(hexString, 16);
    }
    /* @internal */

  }, {
    key: "twosComplement",
    value: function twosComplement(signedBytes) {
      // if the whole number is negative then
      // change to 2's complements by noting all the numbers
      // and adding 1 to the last i.e. ~bignum+1
      for (var b = 0; b < signedBytes.length; b++) {
        signedBytes[b] = ~signedBytes[b];
      } // Add 1 to last number, if the number is 0xFF continue to carry


      var c = signedBytes.length - 1;

      do {
        signedBytes[c]++;
      } while (signedBytes[c--] === 0 && c > 0);
    }
  }]);

  return BigIntegerHelper;
}();
/* @internal */


BigIntegerHelper.RADIX = big_integer_1.default(3);
/* @internal */

BigIntegerHelper.MAX_TRIT_VALUE = BigIntegerHelper.RADIX.minus(1).divide(2);
/* @internal */

BigIntegerHelper.MIN_TRIT_VALUE = BigIntegerHelper.MAX_TRIT_VALUE.negate();
/* @internal */

BigIntegerHelper.BIT_HASH_LENGTH = 384;
/* @internal */

BigIntegerHelper.BYTE_HASH_LENGTH = BigIntegerHelper.BIT_HASH_LENGTH / 8;
exports.BigIntegerHelper = BigIntegerHelper;

/***/ }),

/***/ "../iota-pico-crypto/dist/helpers/transactionHelper.js":
/*!*************************************************************!*\
  !*** ../iota-pico-crypto/dist/helpers/transactionHelper.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../iota-pico-data/dist/data/hash.js");

var transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ "../iota-pico-data/dist/data/transaction.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../iota-pico-crypto/dist/error/cryptoError.js");

var spongeFactory_1 = __webpack_require__(/*! ../factories/spongeFactory */ "../iota-pico-crypto/dist/factories/spongeFactory.js");
/**
 * Helper class for transactions.
 * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js
 */


var TransactionHelper =
/*#__PURE__*/
function () {
  function TransactionHelper() {
    _classCallCheck(this, TransactionHelper);
  }

  _createClass(TransactionHelper, null, [{
    key: "hash",

    /**
     * Create the hash for a transaction.
     * @param transaction The transaction to generate the hash.
     * @returns The hash of thr transaction.
     */
    value: function hash(transaction) {
      if (!objectHelper_1.ObjectHelper.isType(transaction, transaction_1.Transaction)) {
        throw new cryptoError_1.CryptoError("The transaction must be of type Transaction");
      }

      var curl = spongeFactory_1.SpongeFactory.instance().create("curl");
      var transactionTrits = trits_1.Trits.fromTrytes(transaction.toTrytes()).toArray();
      curl.initialize();
      curl.absorb(transactionTrits, 0, transactionTrits.length);
      var hashTrits = new Int8Array(curl.getConstant("HASH_LENGTH"));
      curl.squeeze(hashTrits, 0, hashTrits.length);
      return hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());
    }
  }]);

  return TransactionHelper;
}();

exports.TransactionHelper = TransactionHelper;

/***/ }),

/***/ "../iota-pico-crypto/dist/sponges/curl.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/sponges/curl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../iota-pico-crypto/dist/error/cryptoError.js");
/**
 * Implementation of ISponge using Curl algorithm.
 * https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/curl/curl.js
 */


var Curl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Curl.
   * @param rounds The number of rounds to use.
   */
  function Curl() {
    var rounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Curl.NUMBER_OF_ROUNDS;

    _classCallCheck(this, Curl);

    this._numberOfRounds = rounds;
  }
  /**
   * Get the constant for the spone.
   * @name The name of the contant to get.
   * @returns The constant.
   */


  _createClass(Curl, [{
    key: "getConstant",
    value: function getConstant(name) {
      switch (name) {
        case "NUMBER_OF_ROUNDS":
          {
            return this._numberOfRounds;
          }

        case "HASH_LENGTH":
        case "STATE_LENGTH":
          {
            return Curl[name];
          }

        default:
          throw new cryptoError_1.CryptoError("Unknown constant requested ".concat(name));
      }
    }
    /**
     * Get the state.
     * @returns The state.
     */

  }, {
    key: "getState",
    value: function getState() {
      return this._state;
    }
    /**
     * Initialise the hasher.
     * @param state The initial state for the hasher.
     */

  }, {
    key: "initialize",
    value: function initialize(state) {
      if (state) {
        this._state = state;
      } else {
        this._state = new Int8Array(Curl.STATE_LENGTH);
      }
    }
    /**
     * Reset the hasher.
     */

  }, {
    key: "reset",
    value: function reset() {
      this.initialize();
    }
    /**
     * Absorb trits into the hash.
     * @param trits The trits to absorb.
     * @param offset The offset into the trits to absorb from.
     * @param length The number of trits to absorb.
     */

  }, {
    key: "absorb",
    value: function absorb(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var i = 0;
        var limit = localLength < Curl.HASH_LENGTH ? localLength : Curl.HASH_LENGTH;

        while (i < limit) {
          this._state[i++] = trits[localOffset++];
        }

        this.transform();
        localLength -= Curl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Squeeze trits into the hash.
     * @param trits The trits to squeeze.
     * @param offset The offset into the trits to squeeze from.
     * @param length The number of trits to squeeze.
     */

  }, {
    key: "squeeze",
    value: function squeeze(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var i = 0;
        var limit = localLength < Curl.HASH_LENGTH ? length : Curl.HASH_LENGTH;

        while (i < limit) {
          trits[localOffset++] = this._state[i++];
        }

        this.transform();
        localLength -= Curl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Transform the hash.
     * @internal
     */

  }, {
    key: "transform",
    value: function transform() {
      var stateCopy;
      var index = 0;

      for (var round = 0; round < this._numberOfRounds; round++) {
        stateCopy = new Int8Array(this._state.slice());

        for (var i = 0; i < Curl.STATE_LENGTH; i++) {
          this._state[i] = Curl.TRUTH_TABLE[stateCopy[index] + (stateCopy[index += index < 365 ? 364 : -365] << 2) + 5];
        }
      }
    }
  }]);

  return Curl;
}();

Curl.HASH_LENGTH = 243;
Curl.NUMBER_OF_ROUNDS = 81;
Curl.STATE_LENGTH = Curl.HASH_LENGTH * 3;
/* @internal */

Curl.TRUTH_TABLE = new Int8Array([1, 0, -1, 2, 1, -1, 0, 2, -1, 1, 0]);
exports.Curl = Curl;

/***/ }),

/***/ "../iota-pico-crypto/dist/sponges/kerl.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/sponges/kerl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var sha3_1 = __webpack_require__(/*! ../digests/sha3 */ "../iota-pico-crypto/dist/digests/sha3.js");

var cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ "../iota-pico-crypto/dist/error/cryptoError.js");

var bigIntegerHelper_1 = __webpack_require__(/*! ../helpers/bigIntegerHelper */ "../iota-pico-crypto/dist/helpers/bigIntegerHelper.js");
/**
 * Implementation of ISponge using Kerl algorithm.
 * https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java
 */


var Kerl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Kerl.
   */
  function Kerl() {
    _classCallCheck(this, Kerl);

    this._keccak = new sha3_1.Sha3(384, sha3_1.Sha3.KECCAK_PADDING, 384);
  }
  /**
   * Get the constant for the spone.
   * @name The name of the contant to get.
   * @returns The constant.
   */


  _createClass(Kerl, [{
    key: "getConstant",
    value: function getConstant(name) {
      switch (name) {
        case "HASH_LENGTH":
        case "BIT_HASH_LENGTH":
        case "BYTE_HASH_LENGTH":
          {
            return Kerl[name];
          }

        default:
          throw new cryptoError_1.CryptoError("Unknown constant requested ".concat(name));
      }
    }
    /**
     * Get the state.
     * @returns The state.
     */

  }, {
    key: "getState",
    value: function getState() {
      return undefined;
    }
    /**
     * Initialise the hasher.
     * @param state The initial state for the hasher.
     */

  }, {
    key: "initialize",
    value: function initialize(state) {}
    /**
     * Reset the hasher.
     */

  }, {
    key: "reset",
    value: function reset() {
      this._keccak.reset();
    }
    /**
     * Absorb trits into the hash.
     * @param trits The trits to absorb.
     * @param offset The offset into the trits to absorb from.
     * @param length The number of trits to absorb.
     */

  }, {
    key: "absorb",
    value: function absorb(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      if (length % 243 !== 0) {
        throw new cryptoError_1.CryptoError("Length must be a multiple of ".concat(Kerl.HASH_LENGTH), {
          length: length
        });
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var tritState = trits.slice(localOffset, localOffset + Kerl.HASH_LENGTH);
        tritState[Kerl.HASH_LENGTH - 1] = 0;
        var bigInt = bigIntegerHelper_1.BigIntegerHelper.tritsToBigInteger(tritState, 0, tritState.length);
        var byteState = new ArrayBuffer(Kerl.BYTE_HASH_LENGTH);
        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToBytes(bigInt, byteState, 0);

        this._keccak.update(byteState);

        localOffset += Kerl.HASH_LENGTH;
        localLength -= Kerl.HASH_LENGTH;
      } while (localLength > 0);
    }
    /**
     * Squeeze trits into the hash.
     * @param trits The trits to squeeze.
     * @param offset The offset into the trits to squeeze from.
     * @param length The number of trits to squeeze.
     */

  }, {
    key: "squeeze",
    value: function squeeze(trits, offset, length) {
      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {
        throw new cryptoError_1.CryptoError("Trits must be a non empty Int8Array");
      }

      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {
        throw new cryptoError_1.CryptoError("Offset must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new cryptoError_1.CryptoError("Length must be a number >= 0");
      }

      if (length + offset > trits.length) {
        throw new cryptoError_1.CryptoError("The offset + length is beyond the length of the trits");
      }

      if (length % 243 !== 0) {
        throw new cryptoError_1.CryptoError("Length must be a multiple of ".concat(Kerl.HASH_LENGTH), {
          length: length
        });
      }

      var localOffset = offset;
      var localLength = length;

      do {
        var byteStateBuffer = this._keccak.digest();

        var bigInt = bigIntegerHelper_1.BigIntegerHelper.bytesToBigInteger(byteStateBuffer, 0, Kerl.BYTE_HASH_LENGTH);
        var tritState = new Int8Array(Kerl.HASH_LENGTH);
        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToTrits(bigInt, tritState, 0, Kerl.HASH_LENGTH);
        tritState[Kerl.HASH_LENGTH - 1] = 0;
        var i = 0;

        while (i < Kerl.HASH_LENGTH) {
          trits[localOffset++] = tritState[i++];
        }

        var dv = new DataView(byteStateBuffer);

        for (i = 0; i < dv.byteLength; i++) {
          dv.setUint8(i, dv.getUint8(i) ^ 0xFF);
        }

        this._keccak.update(byteStateBuffer);

        localLength -= Kerl.HASH_LENGTH;
      } while (localLength > 0);
    }
  }]);

  return Kerl;
}();
/* @internal */


Kerl.HASH_LENGTH = 243;
/* @internal */

Kerl.BIT_HASH_LENGTH = 384;
/* @internal */

Kerl.BYTE_HASH_LENGTH = Kerl.BIT_HASH_LENGTH / 8;
exports.Kerl = Kerl;

/***/ }),

/***/ "../iota-pico-crypto/node_modules/big-integer/BigInteger.js":
/*!******************************************************************!*\
  !*** ../iota-pico-crypto/node_modules/big-integer/BigInteger.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {
    "use strict";

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        LOG_MAX_INT = Math.log(MAX_INT);

    function Integer(v, radix) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a,b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };

    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
            if (isPrecise(a.value * this.value)) {
                return new SmallInteger(a.value * this.value);
            }
            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
            if (a.value === 0) return Integer[0];
            if (a.value === 1) return this;
            if (a.value === -1) return this.negate();
            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    function square(a) {
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            for (var j = 0; j < l; j++) {
                a_j = a[j];
                product = a_i * a_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;

    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        var value = n.value;
        if (value === 0) return false;
        if (value === 1) return true;
        if (value === 2) return this.isEven();
        return this.mod(n).equals(Integer[0]);
    };
    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(25)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    BigInteger.prototype.isPrime = function () {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs(),
            nPrev = n.prev();
        var a = [2, 3, 5, 7, 11, 13, 17, 19],
            b = nPrev,
            d, t, i, x;
        while (b.isEven()) b = b.divide(2);
        for (i = 0; i < a.length; i++) {
            x = bigInt(a[i]).modPow(b, n);
            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;
            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {
                x = x.square().mod(n);
                if (x.equals(nPrev)) t = false;
            }
            if (t) return false;
        }
        return true;
    };
    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        // use the Fermat primality test
        for (var i = 0; i < t; i++) {
            var a = bigInt.randBetween(2, n.minus(2));
            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite
        }
        return true; // large chance of being prime
    };
    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.equals(bigInt.zero)) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.equals(1)) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return ((typeof n === "number" || typeof n === "string") && +Math.abs(n) <= BASE) ||
            (n instanceof BigInteger && n.value.length <= 1);
    }

    BigInteger.prototype.shiftLeft = function (n) {
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (n) {
        var remQuo;
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = Math.min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(Math.random() * range));
        var length = range.value.length - 1;
        var result = [], restricted = true;
        for (var i = length; i >= 0; i--) {
            var top = restricted ? range.value[i] : BASE;
            var digit = truncate(Math.random() * top);
            result.unshift(digit);
            if (digit < top) restricted = false;
        }
        result = arrayToSmall(result);
        return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));
    }
    var parseBase = function (text, base) {
        var length = text.length;
		var i;
		var absBase = Math.abs(base);
		for(var i = 0; i < length; i++) {
			var c = text[i].toLowerCase();
			if(c === "-") continue;
			if(/[a-z0-9]/.test(c)) {
			    if(/[0-9]/.test(c) && +c >= absBase) {
					if(c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
				} else if(c.charCodeAt(0) - 87 >= absBase) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
			}
		}
        if (2 <= base && base <= 36) {
            if (length <= LOG_MAX_INT / Math.log(base)) {
				var result = parseInt(text, base);
				if(isNaN(result)) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
                return new SmallInteger(parseInt(text, base));
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i].toLowerCase(),
                charCode = c.charCodeAt(0);
            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));
            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">");
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit) {
        if (digit <= 35) {
            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(digit);
        }
        return "<" + digit + ">";
    }

    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return {value: [0], isNegative: false};
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return {value: [0], isNegative: false};
            if (n.isNegative())
              return {
                value: [].concat.apply([], Array.apply(null, Array(-n))
                            .map(Array.prototype.valueOf, [1, 0])
                          ),
                isNegative: false
              };

            var arr = Array.apply(null, Array(+n - 1))
              .map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
              value: [].concat.apply([], arr),
              isNegative: false
            };
        }

        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.equals(1)) {
            if (n.isZero()) return {value: [0], isNegative: false};
            
            return {
              value: Array.apply(null, Array(+n))
                       .map(Number.prototype.valueOf, 1),
              isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return {value: out.reverse(), isNegative: neg};
    }

    function toBaseString(n, base) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(stringify).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix !== 10) return toBaseString(this, radix);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix != 10) return toBaseString(this, radix);
        return String(this.value);
    };
    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() { return this.toString(); }

    BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;

    function parseStringValue(v) {
            if (isPrecise(+v)) {
                var x = +v;
                if (x === truncate(x))
                    return new SmallInteger(x);
                throw "Invalid integer: " + v;
            }
            var sign = v[0] === "-";
            if (sign) v = v.slice(1);
            var split = v.split(/e/i);
            if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
            if (split.length === 2) {
                var exp = split[1];
                if (exp[0] === "+") exp = exp.slice(1);
                exp = +exp;
                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
                var text = split[0];
                var decimalPlace = text.indexOf(".");
                if (decimalPlace >= 0) {
                    exp -= text.length - decimalPlace - 1;
                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
                }
                if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
                text += (new Array(exp + 1)).join("0");
                v = text;
            }
            var isValid = /^([0-9][0-9]*)$/.test(v);
            if (!isValid) throw new Error("Invalid integer: " + v);
            var r = [], max = v.length, l = LOG_BASE, min = max - l;
            while (max > 0) {
                r.push(+v.slice(min, max));
                min -= l;
                if (min < 0) min = 0;
                max -= l;
            }
            trim(r);
            return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = new SmallInteger(i);
        if (i > 0) Integer[-i] = new SmallInteger(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}

//amd check
if ( true ) {
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return bigInt;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../iota-pico-business/node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../iota-pico-data/dist/data/address.js":
/*!**********************************************!*\
  !*** ../iota-pico-data/dist/data/address.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling addresses.
 */


var Address =
/*#__PURE__*/
function () {
  /* @internal */
  function Address(addressTrytes, checksumTrytes) {
    _classCallCheck(this, Address);

    this._addressTrytes = addressTrytes;
    this._checksumTrytes = checksumTrytes;
  }
  /**
   * Create address from trytes.
   * @param address The trytes to create the address from.
   * @returns An instance of Address.
   */


  _createClass(Address, [{
    key: "toTrytes",

    /**
     * Convert the address to trytes with no checksum.
     * @returns Trytes version of the address with no checksum.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._addressTrytes);
    }
    /**
     * Convert the address to trytes with a checksum, creating a blank one if needed.
     * @returns Trytes version of the address with checksu,.
     */

  }, {
    key: "toTrytesWithChecksum",
    value: function toTrytesWithChecksum() {
      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {
        return trytes_1.Trytes.fromString(this._addressTrytes + this._checksumTrytes);
      } else {
        throw new dataError_1.DataError("This address has no checksum calculated for it");
      }
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {
        return this._addressTrytes + this._checksumTrytes;
      } else {
        return this._addressTrytes;
      }
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(address) {
      if (!objectHelper_1.ObjectHelper.isType(address, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The address should be a valid Trytes object");
      }

      var trytesString = address.toString();

      if (trytesString.length !== Address.LENGTH && trytesString.length !== Address.LENGTH_WITH_CHECKSUM) {
        throw new dataError_1.DataError("The address should either be ".concat(Address.LENGTH, " or ").concat(Address.LENGTH_WITH_CHECKSUM, " characters in length"), {
          length: trytesString.length
        });
      }

      var addressTrytes = trytesString.substr(0, Address.LENGTH);
      var checksumTrytes;

      if (trytesString.length === Address.LENGTH_WITH_CHECKSUM) {
        checksumTrytes = trytesString.substr(Address.LENGTH);
      }

      return new Address(addressTrytes, checksumTrytes);
    }
  }]);

  return Address;
}();
/**
 * The length for a valid address without checksum (81).
 */


Address.LENGTH = 81;
/**
 * The length for an address checksum (9).
 */

Address.LENGTH_CHECKSUM = 9;
/**
 * The length for valid address with checksum (90).
 */

Address.LENGTH_WITH_CHECKSUM = Address.LENGTH + Address.LENGTH_CHECKSUM;
/**
 * An empty hash all 9s.
 */

Address.EMPTY = Address.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Address.LENGTH)));
exports.Address = Address;

/***/ }),

/***/ "../iota-pico-data/dist/data/addressSecurity.js":
/*!******************************************************!*\
  !*** ../iota-pico-data/dist/data/addressSecurity.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Represents an enum for the address security values.
 */

var AddressSecurity;

(function (AddressSecurity) {
  AddressSecurity[AddressSecurity["low"] = 1] = "low";
  AddressSecurity[AddressSecurity["medium"] = 2] = "medium";
  AddressSecurity[AddressSecurity["high"] = 3] = "high";
})(AddressSecurity = exports.AddressSecurity || (exports.AddressSecurity = {}));

/***/ }),

/***/ "../iota-pico-data/dist/data/bundle.js":
/*!*********************************************!*\
  !*** ../iota-pico-data/dist/data/bundle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var hash_1 = __webpack_require__(/*! ./hash */ "../iota-pico-data/dist/data/hash.js");

var signatureMessageFragment_1 = __webpack_require__(/*! ./signatureMessageFragment */ "../iota-pico-data/dist/data/signatureMessageFragment.js");

var tag_1 = __webpack_require__(/*! ./tag */ "../iota-pico-data/dist/data/tag.js");

var transaction_1 = __webpack_require__(/*! ./transaction */ "../iota-pico-data/dist/data/transaction.js");

var tryteNumber_1 = __webpack_require__(/*! ./tryteNumber */ "../iota-pico-data/dist/data/tryteNumber.js");
/**
 * A class for handling bundles.
 */


var Bundle =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of Bundle.
   */
  function Bundle() {
    _classCallCheck(this, Bundle);

    this.transactions = [];
  }
  /**
   * Add new transactions to the bundle.
   * @param signatureMessageLength The number of transactions to add.
   * @param address The address for the transactions.
   * @param value The value for the first of the transactions.
   * @param tag The tag to include in the transactions.
   * @param timestamp The timestamp for the transactions.
   */


  _createClass(Bundle, [{
    key: "addTransactions",
    value: function addTransactions(signatureMessageLength, address, value, tag, timestamp) {
      for (var i = 0; i < signatureMessageLength; i++) {
        this.transactions.push(transaction_1.Transaction.fromParams(undefined, address, i === 0 ? value : 0, tag, timestamp, undefined, undefined, undefined, undefined, undefined, tag, undefined, undefined, undefined, undefined));
      }
    }
    /**
     * Add signature fragments to the bundle.
     * @param signatureMessageFragments The signature fragments to add to the bundle transactions.
     */

  }, {
    key: "addSignatureMessageFragments",
    value: function addSignatureMessageFragments(signatureMessageFragments) {
      if (objectHelper_1.ObjectHelper.isEmpty(signatureMessageFragments)) {
        throw new dataError_1.DataError("The signatureMessageFragments should be an array of SignatureMessageFragments");
      }

      for (var i = 0; i < this.transactions.length; i++) {
        this.transactions[i].signatureMessageFragment = signatureMessageFragments[i] || signatureMessageFragment_1.SignatureMessageFragment.EMPTY;
        this.transactions[i].trunkTransaction = hash_1.Hash.EMPTY;
        this.transactions[i].branchTransaction = hash_1.Hash.EMPTY;
        this.transactions[i].attachmentTimestamp = tryteNumber_1.TryteNumber.EMPTY_9;
        this.transactions[i].attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.EMPTY_9;
        this.transactions[i].attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.EMPTY_9;
        this.transactions[i].nonce = tag_1.Tag.EMPTY;
      }
    }
  }]);

  return Bundle;
}();

exports.Bundle = Bundle;

/***/ }),

/***/ "../iota-pico-data/dist/data/hash.js":
/*!*******************************************!*\
  !*** ../iota-pico-data/dist/data/hash.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling hashes.
 */


var Hash =
/*#__PURE__*/
function () {
  /* @internal */
  function Hash(trytes) {
    _classCallCheck(this, Hash);

    this._trytes = trytes;
  }
  /**
   * Create hash from trytes.
   * @param hash The trytes to create the hash from.
   * @returns An instance of Hash.
   */


  _createClass(Hash, [{
    key: "toTrytes",

    /**
     * Convert the hash to trytes.
     * @returns Trytes version of the hash.
     */
    value: function toTrytes() {
      return this._trytes;
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes.toString();
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(hash) {
      if (!objectHelper_1.ObjectHelper.isType(hash, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The hash should be a valid Trytes object");
      }

      var length = hash.length();

      if (length !== Hash.LENGTH) {
        throw new dataError_1.DataError("The hash should be ".concat(Hash.LENGTH, " characters in length"), {
          length: length
        });
      }

      return new Hash(hash);
    }
  }]);

  return Hash;
}();
/**
 * The length for a valid hash (81).
 */


Hash.LENGTH = 81;
/**
 * An empty hash all 9s.
 */

Hash.EMPTY = Hash.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Hash.LENGTH)));
exports.Hash = Hash;

/***/ }),

/***/ "../iota-pico-data/dist/data/input.js":
/*!********************************************!*\
  !*** ../iota-pico-data/dist/data/input.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var address_1 = __webpack_require__(/*! ./address */ "../iota-pico-data/dist/data/address.js");

var addressSecurity_1 = __webpack_require__(/*! ./addressSecurity */ "../iota-pico-data/dist/data/addressSecurity.js");
/**
 * A class for handling inputs.
 */


var Input =
/*#__PURE__*/
function () {
  /* @internal */
  function Input() {
    _classCallCheck(this, Input);
  }
  /**
   * Create instance of input from parameters.
   * @param address The address.
   * @param security The address security.
   * @param keyIndex The key index.
   * @param balance The balance of the address.
   * @returns New instance of Input.
   */


  _createClass(Input, null, [{
    key: "fromParams",
    value: function fromParams(address, security, keyIndex, balance) {
      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new dataError_1.DataError("The address should be a valid Address object");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < addressSecurity_1.AddressSecurity.low || security > addressSecurity_1.AddressSecurity.high) {
        throw new dataError_1.DataError("The security should be a number between ".concat(addressSecurity_1.AddressSecurity.low, " and ").concat(addressSecurity_1.AddressSecurity.high));
      }

      if (!numberHelper_1.NumberHelper.isInteger(keyIndex) || keyIndex < 0) {
        throw new dataError_1.DataError("The keyIndex should be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0) {
        throw new dataError_1.DataError("The balance should be a number >= 0");
      }

      var input = new Input();
      input.address = address;
      input.security = security;
      input.keyIndex = keyIndex;
      input.balance = balance;
      return input;
    }
  }]);

  return Input;
}();

exports.Input = Input;

/***/ }),

/***/ "../iota-pico-data/dist/data/signatureMessageFragment.js":
/*!***************************************************************!*\
  !*** ../iota-pico-data/dist/data/signatureMessageFragment.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling signature message fragments.
 */


var SignatureMessageFragment =
/*#__PURE__*/
function () {
  /* @internal */
  function SignatureMessageFragment(trytes) {
    _classCallCheck(this, SignatureMessageFragment);

    this._trytes = trytes;
  }
  /**
   * Create signature fragment from trytes.
   * @param signatureMessageFragment The trytes to create the signature fragment from.
   * @returns An instance of SignatureMessageFragment.
   */


  _createClass(SignatureMessageFragment, [{
    key: "toTrytes",

    /**
     * Convert the signature fragment to trytes.
     * @returns Trytes version of the signature fragment.
     */
    value: function toTrytes() {
      return this._trytes;
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes.toString();
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(signatureMessageFragment) {
      if (!objectHelper_1.ObjectHelper.isType(signatureMessageFragment, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The signatureMessageFragment should be a valid Trytes object");
      }

      var length = signatureMessageFragment.length();

      if (length !== SignatureMessageFragment.LENGTH) {
        throw new dataError_1.DataError("The signatureMessageFragment should be ".concat(SignatureMessageFragment.LENGTH, " characters in length"), {
          length: length
        });
      }

      return new SignatureMessageFragment(signatureMessageFragment);
    }
  }]);

  return SignatureMessageFragment;
}();
/**
 * The length of a valid signature message fragment (2187)
 */


SignatureMessageFragment.LENGTH = 2187;
/**
 * An empty signature message fragment all 9s.
 */

SignatureMessageFragment.EMPTY = SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString("9".repeat(SignatureMessageFragment.LENGTH)));
exports.SignatureMessageFragment = SignatureMessageFragment;

/***/ }),

/***/ "../iota-pico-data/dist/data/tag.js":
/*!******************************************!*\
  !*** ../iota-pico-data/dist/data/tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling tags.
 */


var Tag =
/*#__PURE__*/
function () {
  /* @internal */
  function Tag(trytes) {
    _classCallCheck(this, Tag);

    this._trytes = trytes;
  }
  /**
   * Create tag from trytes.
   * @param tag The trytes to create the tag from.
   * @returns An instance of Tag.
   */


  _createClass(Tag, [{
    key: "toTrytes",

    /**
     * Convert the tag to trytes.
     * @returns Trytes version of the tag.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._trytes);
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes;
    }
  }], [{
    key: "fromTrytes",
    value: function fromTrytes(tag) {
      if (!objectHelper_1.ObjectHelper.isType(tag, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The tag should be a valid Trytes object");
      }

      var trytesString = tag.toString();

      if (trytesString.length > Tag.LENGTH) {
        throw new dataError_1.DataError("The tag should be at most ".concat(Tag.LENGTH, " characters in length"), {
          length: trytesString.length
        });
      }

      while (trytesString.length < Tag.LENGTH) {
        trytesString += "9";
      }

      return new Tag(trytesString);
    }
  }]);

  return Tag;
}();
/**
 * The length of a valid tag (27).
 */


Tag.LENGTH = 27;
/**
 * An empty tag all 9s.
 */

Tag.EMPTY = Tag.fromTrytes(trytes_1.Trytes.fromString("9".repeat(Tag.LENGTH)));
exports.Tag = Tag;

/***/ }),

/***/ "../iota-pico-data/dist/data/transaction.js":
/*!**************************************************!*\
  !*** ../iota-pico-data/dist/data/transaction.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var address_1 = __webpack_require__(/*! ./address */ "../iota-pico-data/dist/data/address.js");

var hash_1 = __webpack_require__(/*! ./hash */ "../iota-pico-data/dist/data/hash.js");

var signatureMessageFragment_1 = __webpack_require__(/*! ./signatureMessageFragment */ "../iota-pico-data/dist/data/signatureMessageFragment.js");

var tag_1 = __webpack_require__(/*! ./tag */ "../iota-pico-data/dist/data/tag.js");

var tryteNumber_1 = __webpack_require__(/*! ./tryteNumber */ "../iota-pico-data/dist/data/tryteNumber.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling transactions.
 */


var Transaction =
/*#__PURE__*/
function () {
  /* @internal */
  function Transaction() {
    _classCallCheck(this, Transaction);
  }
  /**
   * Create instance of transaction from parameters.
   * @param signatureMessageFragment The signature message fragment.
   * @param address The address.
   * @param value The value.
   * @param obsoleteTag Obsolete transaction tag.
   * @param timestamp The timestamp.
   * @param currentIndex The current index.
   * @param lastIndex The last index.
   * @param bundle The bundle.
   * @param trunkTransaction The trunk transaction.
   * @param branchTransaction The branch transaction.
   * @param tag The tag.
   * @param attachmentTimestamp The attachment timestamp.
   * @param attachmentTimestampLowerBound The attachment timestamp lower bound.
   * @param attachmentTimestampUpperBound  The attachment timestamp upper bound.
   * @param nonce The nonce.
   * @returns New instance of transaction.
   */


  _createClass(Transaction, [{
    key: "toTrytes",

    /**
     * Convert the transaction to trytes.
     * @returns The transaction as trytes.
     */
    value: function toTrytes() {
      if (!objectHelper_1.ObjectHelper.isType(this.signatureMessageFragment, signatureMessageFragment_1.SignatureMessageFragment)) {
        throw new dataError_1.DataError("The signatureMessageFragment must be set to create transaction trytes", {
          signatureMessageFragment: this.signatureMessageFragment
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.address, address_1.Address)) {
        throw new dataError_1.DataError("The address must be set to create transaction trytes", {
          address: this.address
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.obsoleteTag, tag_1.Tag)) {
        throw new dataError_1.DataError("The obsoleteTag must be set to create transaction trytes", {
          obsoleteTag: this.obsoleteTag
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.bundle, hash_1.Hash)) {
        throw new dataError_1.DataError("The bundle must be set to create transaction trytes", {
          bundle: this.bundle
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.trunkTransaction, hash_1.Hash)) {
        throw new dataError_1.DataError("The trunkTransaction must be set to create transaction trytes", {
          trunkTransaction: this.trunkTransaction
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.branchTransaction, hash_1.Hash)) {
        throw new dataError_1.DataError("The branchTransaction must be set to create transaction trytes", {
          branchTransaction: this.branchTransaction
        });
      }

      if (!objectHelper_1.ObjectHelper.isType(this.nonce, tag_1.Tag)) {
        throw new dataError_1.DataError("The nonce must be set to create transaction trytes", {
          nonce: this.nonce
        });
      }

      var trytes = this.signatureMessageFragment.toTrytes().toString() + this.address.toTrytes().toString() + (this.value || Transaction.EMPTY_11).toTrytes().toString() + Transaction.CHECK_VALUE + this.obsoleteTag.toTrytes().toString() + (this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.bundle.toTrytes().toString() + this.trunkTransaction.toTrytes().toString() + this.branchTransaction.toTrytes().toString() + (this.tag || this.obsoleteTag).toTrytes().toString() + (this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.nonce.toTrytes().toString();
      var length = trytes.length;

      if (length !== Transaction.LENGTH) {
        throw new dataError_1.DataError("The trytes must be ".concat(Transaction.LENGTH, " in length ").concat(length), {
          length: length
        });
      }

      return trytes_1.Trytes.fromString(trytes);
    }
    /**
     * Get the string view of the object.
     * @returns string view of the object.
     */

  }, {
    key: "toString",
    value: function toString() {
      return "{\n\tsignatureMessageFragment: \"".concat((this.signatureMessageFragment || signatureMessageFragment_1.SignatureMessageFragment.EMPTY).toTrytes().toString(), "\"\n\taddress: \"").concat((this.address || address_1.Address.EMPTY).toTrytes().toString(), "\"\n\tvalue: ").concat((this.value || Transaction.EMPTY_11).toNumber(), "\n\tobsoleteTag: \"").concat((this.obsoleteTag || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n\ttimestamp: ").concat((this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tcurrentIndex: ").concat((this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tlastIndex: ").concat((this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tbundle: \"").concat((this.bundle || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\ttrunkTransaction: \"").concat((this.trunkTransaction || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\tbranchTransaction: \"").concat((this.branchTransaction || hash_1.Hash.EMPTY).toTrytes().toString(), "\"\n\ttag: \"").concat((this.tag || this.obsoleteTag || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n\tattachmentTimestamp: ").concat((this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tattachmentTimestampLowerBound: ").concat((this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tattachmentTimestampUpperBound: ").concat((this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toNumber(), "\n\tnonce: \"").concat((this.nonce || tag_1.Tag.EMPTY).toTrytes().toString(), "\"\n}");
    }
  }], [{
    key: "fromParams",
    value: function fromParams(signatureMessageFragment, address, value, obsoleteTag, timestamp, currentIndex, lastIndex, bundle, trunkTransaction, branchTransaction, tag, attachmentTimestamp, attachmentTimestampLowerBound, attachmentTimestampUpperBound, nonce) {
      var tx = new Transaction();
      tx.signatureMessageFragment = signatureMessageFragment;
      tx.address = address;
      tx.value = tryteNumber_1.TryteNumber.fromNumber(value, 11);
      tx.obsoleteTag = obsoleteTag;
      tx.timestamp = tryteNumber_1.TryteNumber.fromNumber(timestamp);
      tx.currentIndex = tryteNumber_1.TryteNumber.fromNumber(currentIndex);
      tx.lastIndex = tryteNumber_1.TryteNumber.fromNumber(lastIndex);
      tx.bundle = bundle;
      tx.trunkTransaction = trunkTransaction;
      tx.branchTransaction = branchTransaction;
      tx.tag = tag;
      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestamp);
      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampLowerBound);
      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampUpperBound);
      tx.nonce = nonce;
      return tx;
    }
    /**
     * Create instance of transaction from trytes.
     * @param trytes The trytes for the this.
     * @returns An instance of this.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(trytes) {
      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The trytes should be a valid Trytes object");
      }

      var length = trytes.length();

      if (length !== Transaction.LENGTH) {
        throw new dataError_1.DataError("The trytes must be ".concat(Transaction.LENGTH, " in length"), {
          length: length
        });
      }

      var checkIndexStart = 2279;
      var checkIndexLength = 16;
      var check = trytes.sub(checkIndexStart, checkIndexLength).toString();

      if (check !== Transaction.CHECK_VALUE) {
        throw new dataError_1.DataError("The trytes between ".concat(checkIndexStart, " and ").concat(checkIndexStart + checkIndexLength, " should be all 9s"), {
          check: check
        });
      }

      var tx = new Transaction();
      var startPos = 0;
      tx.signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes.sub(startPos, signatureMessageFragment_1.SignatureMessageFragment.LENGTH));
      startPos += signatureMessageFragment_1.SignatureMessageFragment.LENGTH;
      tx.address = address_1.Address.fromTrytes(trytes.sub(startPos, address_1.Address.LENGTH));
      startPos += address_1.Address.LENGTH;
      tx.value = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, 11), 11);
      startPos += 11;
      startPos += Transaction.CHECK_VALUE_LENGTH;
      tx.obsoleteTag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      startPos += tag_1.Tag.LENGTH;
      tx.timestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.currentIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.lastIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.bundle = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.trunkTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.branchTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));
      startPos += hash_1.Hash.LENGTH;
      tx.tag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      startPos += tag_1.Tag.LENGTH;
      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));
      startPos += tryteNumber_1.TryteNumber.LENGTH_9;
      tx.nonce = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));
      return tx;
    }
  }]);

  return Transaction;
}();
/**
 * The length of a valid transaction (2673).
 */


Transaction.LENGTH = 2673;
/**
 * The length of a valid check value (16).
 */

Transaction.CHECK_VALUE_LENGTH = 16;
/**
 * The check value for bundles all 9s.
 */

Transaction.CHECK_VALUE = "9".repeat(Transaction.CHECK_VALUE_LENGTH);
/* @internal */

Transaction.EMPTY_11 = tryteNumber_1.TryteNumber.fromNumber(0, 11);
exports.Transaction = Transaction;

/***/ }),

/***/ "../iota-pico-data/dist/data/transfer.js":
/*!***********************************************!*\
  !*** ../iota-pico-data/dist/data/transfer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var address_1 = __webpack_require__(/*! ./address */ "../iota-pico-data/dist/data/address.js");

var tag_1 = __webpack_require__(/*! ./tag */ "../iota-pico-data/dist/data/tag.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling transfers.
 */


var Transfer =
/*#__PURE__*/
function () {
  /* @internal */
  function Transfer() {
    _classCallCheck(this, Transfer);
  }
  /**
   * Create instance of transfer from parameters.
   * @param address The address.
   * @param value The value.
   * @param messsage The message for the transfer.
   * @param tag The tag.
   * @returns New instance of Transfer.
   */


  _createClass(Transfer, null, [{
    key: "fromParams",
    value: function fromParams(address, value, message, tag) {
      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new dataError_1.DataError("The address should be a valid Address object");
      }

      if (!numberHelper_1.NumberHelper.isInteger(value) || value < 0) {
        throw new dataError_1.DataError("The value should be a number >= 0");
      }

      if (!objectHelper_1.ObjectHelper.isEmpty(message) && !objectHelper_1.ObjectHelper.isType(message, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The message should be a valid Trytes object");
      }

      if (!objectHelper_1.ObjectHelper.isEmpty(tag) && !objectHelper_1.ObjectHelper.isType(tag, tag_1.Tag)) {
        throw new dataError_1.DataError("The tag should be a valid Tag object");
      }

      var transfer = new Transfer();
      transfer.address = address;
      transfer.value = value;
      transfer.message = message;
      transfer.tag = tag;
      return transfer;
    }
  }]);

  return Transfer;
}();

exports.Transfer = Transfer;

/***/ }),

/***/ "../iota-pico-data/dist/data/trits.js":
/*!********************************************!*\
  !*** ../iota-pico-data/dist/data/trits.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../iota-pico-core/dist/helpers/arrayHelper.js");

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling trits.
 */


var Trits =
/*#__PURE__*/
function () {
  /* @internal */
  function Trits(trits) {
    _classCallCheck(this, Trits);

    this._trits = trits;
  }
  /**
   * Create instance of trits from Int8Array array.
   * @param value Trytes used to create trits.
   * @returns An instance of Trits.
   */


  _createClass(Trits, [{
    key: "toArray",

    /**
     * Get the value of the trits array.
     * @returns Array representation of the trits.
     */
    value: function toArray() {
      return this._trits;
    }
    /**
     * Get the value of the trits array as a number array.
     * @returns Array representation of the trits.
     */

  }, {
    key: "toNumberArray",
    value: function toNumberArray() {
      return Array.from(this._trits);
    }
    /**
     * Get the trits as trytes.
     * @returns Instance of Trytes.
     */

  }, {
    key: "toTrytes",
    value: function toTrytes() {
      var trytes = "";

      for (var i = 0; i < this._trits.length; i += 3) {
        // Iterate over all possible tryte values to find correct trit representation
        for (var j = 0; j < trytes_1.Trytes.ALPHABET.length; j++) {
          if (Trits.TRYTES_TRITS[j][0] === this._trits[i] && Trits.TRYTES_TRITS[j][1] === this._trits[i + 1] && Trits.TRYTES_TRITS[j][2] === this._trits[i + 2]) {
            trytes += trytes_1.Trytes.ALPHABET.charAt(j);
            break;
          }
        }
      }

      return trytes_1.Trytes.fromString(trytes);
    }
    /**
     * Get the trits as a number.
     * @returns The trits converted to a number.
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      var returnValue = 0;

      for (var i = this._trits.length - 1; i >= 0; i--) {
        returnValue = returnValue * 3 + this._trits[i];
      }

      return returnValue;
    }
    /**
     * What is the length of the trits.
     * @returns Length of the trits.
     */

  }, {
    key: "length",
    value: function length() {
      return this._trits.length;
    }
    /**
     * Get a sub of the trits.
     * @param start The start position to get the sub.
     * @param length The length of the sub.
     * @returns The trits sub.
     */

  }, {
    key: "sub",
    value: function sub(start, length) {
      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {
        throw new dataError_1.DataError("The start must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trits.length) {
        throw new dataError_1.DataError("The start + length must <= ".concat(this._trits.length));
      }

      return Trits.fromArray(this._trits.slice(start, start + length));
    }
  }], [{
    key: "fromArray",
    value: function fromArray(value) {
      if (!objectHelper_1.ObjectHelper.isType(value, Int8Array)) {
        throw new dataError_1.DataError("The value does not contain valid trits");
      }

      return new Trits(value);
    }
    /**
     * Create instance of trits from number array.
     * @param value Trytes used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromNumberArray",
    value: function fromNumberArray(value) {
      if (!arrayHelper_1.ArrayHelper.isTyped(value, Number)) {
        throw new dataError_1.DataError("The value does not contain valid trits");
      }

      return new Trits(new Int8Array(value));
    }
    /**
     * Create instance of trits from trytes.
     * @param value Trytes used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(value) {
      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The value should be a valid Trytes object");
      }

      var trytesString = value.toString();
      var trits = new Int8Array(trytesString.length * 3);

      for (var i = 0; i < trytesString.length; i++) {
        var idx = trytes_1.Trytes.ALPHABET.indexOf(trytesString.charAt(i));
        trits[i * 3] = Trits.TRYTES_TRITS[idx][0];
        trits[i * 3 + 1] = Trits.TRYTES_TRITS[idx][1];
        trits[i * 3 + 2] = Trits.TRYTES_TRITS[idx][2];
      }

      return new Trits(trits);
    }
    /**
     * Create instance of trits from number
     * @param value Number used to create trits.
     * @returns An instance of Trits.
     */

  }, {
    key: "fromNumber",
    value: function fromNumber(value) {
      if (!numberHelper_1.NumberHelper.isInteger(value)) {
        throw new dataError_1.DataError("The value is not an integer");
      }

      var trits = [];
      var absoluteValue = value < 0 ? -value : value;

      while (absoluteValue > 0) {
        var remainder = absoluteValue % 3;
        absoluteValue = Math.floor(absoluteValue / 3);

        if (remainder > 1) {
          remainder = -1;
          absoluteValue++;
        }

        trits[trits.length] = remainder;
      }

      if (value < 0) {
        for (var i = 0; i < trits.length; i++) {
          trits[i] = -trits[i];
        }
      }

      return new Trits(new Int8Array(trits));
    }
    /**
     * Add two trits together.
     * @param first The first trit.
     * @param second The second trit.
     * @returns New trit which is the addition of the a + b.
     */

  }, {
    key: "add",
    value: function add(first, second) {
      if (!objectHelper_1.ObjectHelper.isType(first, Trits)) {
        throw new dataError_1.DataError("The first should be a valid Trits object");
      }

      if (!objectHelper_1.ObjectHelper.isType(second, Trits)) {
        throw new dataError_1.DataError("The seconds should be a valid Trits object");
      }

      var out = new Int8Array(Math.max(first._trits.length, second._trits.length));
      var carry = 0;
      var iA;
      var iB;

      for (var i = 0; i < out.length; i++) {
        iA = i < first._trits.length ? first._trits[i] : 0;
        iB = i < second._trits.length ? second._trits[i] : 0;
        var fA = Trits.fullAdd(iA, iB, carry);
        out[i] = fA[0];
        carry = fA[1];
      }

      return Trits.fromArray(out);
    }
    /* @internal */

  }, {
    key: "fullAdd",
    value: function fullAdd(a, b, c) {
      var sA = Trits.sum(a, b);
      var cA = Trits.cons(a, b);
      var cB = Trits.cons(sA, c);
      var cOut = Trits.any(cA, cB);
      var sOUt = Trits.sum(sA, c);
      return new Int8Array([sOUt, cOut]);
    }
    /* @internal */

  }, {
    key: "sum",
    value: function sum(a, b) {
      var s = a + b;

      switch (s) {
        case 2:
          return -1;

        case -2:
          return 1;

        default:
          return s;
      }
    }
    /* @internal */

  }, {
    key: "cons",
    value: function cons(a, b) {
      if (a === b) {
        return a;
      }

      return 0;
    }
    /* @internal */

  }, {
    key: "any",
    value: function any(a, b) {
      var s = a + b;

      if (s > 0) {
        return 1;
      } else if (s < 0) {
        return -1;
      }

      return 0;
    }
  }]);

  return Trits;
}();
/* @internal */


Trits.TRYTES_TRITS = [new Int8Array([0, 0, 0]), new Int8Array([1, 0, 0]), new Int8Array([-1, 1, 0]), new Int8Array([0, 1, 0]), new Int8Array([1, 1, 0]), new Int8Array([-1, -1, 1]), new Int8Array([0, -1, 1]), new Int8Array([1, -1, 1]), new Int8Array([-1, 0, 1]), new Int8Array([0, 0, 1]), new Int8Array([1, 0, 1]), new Int8Array([-1, 1, 1]), new Int8Array([0, 1, 1]), new Int8Array([1, 1, 1]), new Int8Array([-1, -1, -1]), new Int8Array([0, -1, -1]), new Int8Array([1, -1, -1]), new Int8Array([-1, 0, -1]), new Int8Array([0, 0, -1]), new Int8Array([1, 0, -1]), new Int8Array([-1, 1, -1]), new Int8Array([0, 1, -1]), new Int8Array([1, 1, -1]), new Int8Array([-1, -1, 0]), new Int8Array([0, -1, 0]), new Int8Array([1, -1, 0]), new Int8Array([-1, 0, 0])];
exports.Trits = Trits;

/***/ }),

/***/ "../iota-pico-data/dist/data/tryteNumber.js":
/*!**************************************************!*\
  !*** ../iota-pico-data/dist/data/tryteNumber.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");

var trits_1 = __webpack_require__(/*! ./trits */ "../iota-pico-data/dist/data/trits.js");

var trytes_1 = __webpack_require__(/*! ./trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * A class for handling tryte number.
 */


var TryteNumber =
/*#__PURE__*/
function () {
  /* @internal */
  function TryteNumber(trytes) {
    _classCallCheck(this, TryteNumber);

    this._trytes = trytes;
  }
  /**
   * Create tryte number from number.
   * @param value The number value to create the object from.
   * @param length The tryte length to pad the number with.
   * @returns An instance of TryteNumber.
   */


  _createClass(TryteNumber, [{
    key: "toTrytes",

    /**
     * Convert the tryte number to trytes.
     * @returns Trytes version of the tryte number.
     */
    value: function toTrytes() {
      return trytes_1.Trytes.fromString(this._trytes);
    }
    /**
     * Convert the tryte number to number.
     * @returns number value of the tryte number.
     */

  }, {
    key: "toNumber",
    value: function toNumber() {
      return trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(this._trytes)).toNumber();
    }
    /**
     * Get the string view of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "toString",
    value: function toString() {
      return this._trytes;
    }
    /**
     * Get the value of the object.
     * @returns string of the trytes.
     */

  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.toNumber();
    }
  }], [{
    key: "fromNumber",
    value: function fromNumber(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;
      var trytes;

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new dataError_1.DataError("The length should be a number > 0", {
          length: length
        });
      }

      if (objectHelper_1.ObjectHelper.isEmpty(value)) {
        trytes = "9".repeat(length);
      } else {
        if (!numberHelper_1.NumberHelper.isInteger(value)) {
          throw new dataError_1.DataError("The value is not an integer", {
            value: value
          });
        }

        var trits = trits_1.Trits.fromNumber(value).toNumberArray();

        while (trits.length < length * 3) {
          trits.push(0);
        }

        trytes = trits_1.Trits.fromNumberArray(trits).toTrytes().toString();
      }

      return new TryteNumber(trytes);
    }
    /**
     * Create tryte number from trytes.
     * @param value The number value to create the object from.
     * @param length The tryte length to pad the number with.
     * @returns An instance of TryteNumber.
     */

  }, {
    key: "fromTrytes",
    value: function fromTrytes(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;

      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {
        throw new dataError_1.DataError("The value should be a valid Trytes object");
      }

      var tryteString = value.toString();

      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {
        throw new dataError_1.DataError("The length should be a number > 0", {
          length: length
        });
      }

      if (tryteString.length > length) {
        throw new dataError_1.DataError("The value contains too many characters", {
          length: tryteString.length
        });
      }

      while (tryteString.length < length) {
        tryteString += "9";
      }

      return new TryteNumber(tryteString);
    }
  }]);

  return TryteNumber;
}();
/**
 * Length of a number that uses 9 trytes.
 */


TryteNumber.LENGTH_9 = 9;
/**
 * An empty 9 length tryte number.
 */

TryteNumber.EMPTY_9 = TryteNumber.fromNumber(0, TryteNumber.LENGTH_9);
exports.TryteNumber = TryteNumber;

/***/ }),

/***/ "../iota-pico-data/dist/data/trytes.js":
/*!*********************************************!*\
  !*** ../iota-pico-data/dist/data/trytes.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ "../iota-pico-core/dist/helpers/stringHelper.js");

var dataError_1 = __webpack_require__(/*! ../error/dataError */ "../iota-pico-data/dist/error/dataError.js");
/**
 * A class for handling trytes.
 */


var Trytes =
/*#__PURE__*/
function () {
  /* @internal */
  function Trytes(trytes) {
    _classCallCheck(this, Trytes);

    this._trytes = trytes;
  }
  /**
   * Create trytes from a string.
   * @param value A string to create the trytes from.
   * @param length An optional validation length for the trytes, 0 means ignore length.
   * @returns An instance of Trytes.
   */


  _createClass(Trytes, [{
    key: "toString",

    /**
     * Convert the trytes to a string.
     * @returns String representation of the trytes.
     */
    value: function toString() {
      return this._trytes;
    }
    /**
     * Get the length of the trytes.
     * @returns The length of the trytes.
     */

  }, {
    key: "length",
    value: function length() {
      return this._trytes.length;
    }
    /**
     * Get a sub of the trytes.
     * @param start The start position to get the sub.
     * @param length The length of the sub.
     * @returns The trytes sub.
     */

  }, {
    key: "sub",
    value: function sub(start, length) {
      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {
        throw new dataError_1.DataError("The start must be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trytes.length) {
        throw new dataError_1.DataError("The start + length must <= ".concat(this._trytes.length));
      }

      return Trytes.fromString(this._trytes.substr(start, length));
    }
  }], [{
    key: "fromString",
    value: function fromString(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!stringHelper_1.StringHelper.isString(value)) {
        throw new dataError_1.DataError("The value must be a non empty string");
      }

      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {
        throw new dataError_1.DataError("The length must be >= 0");
      }

      if (!Trytes.isValid(value, length)) {
        throw new dataError_1.DataError("The value and length do not contain valid trytes", {
          value: value,
          length: length
        });
      }

      return new Trytes(value);
    }
    /**
     * Does the value contain valid trytes.
     * @param value A string to validate as trytes.
     * @param length An optional validation length for the trytes, 0 means ignore length.
     * @returns True if the input was valid trytes.
     */

  }, {
    key: "isValid",
    value: function isValid(value) {
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!stringHelper_1.StringHelper.isString(value)) {
        return false;
      } else {
        return new RegExp("^[9A-Z]{".concat(length ? length : "0,", "}$")).test(value);
      }
    }
  }]);

  return Trytes;
}();
/**
 * All the characters that can be used in trytes.
 */


Trytes.ALPHABET = "9ABCDEFGHIJKLMNOPQRSTUVWXYZ";
exports.Trytes = Trytes;

/***/ }),

/***/ "../iota-pico-data/dist/error/dataError.js":
/*!*************************************************!*\
  !*** ../iota-pico-data/dist/error/dataError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ "../iota-pico-core/dist/error/coreError.js");
/**
 * A data implementation of an error.
 */


var DataError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(DataError, _coreError_1$CoreErro);

  /**
   * Create an instance of DataError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function DataError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, DataError);

    _this = _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message, additional, innerError));
    _this.domain = "Data";
    return _this;
  }

  return DataError;
}(coreError_1.CoreError);

exports.DataError = DataError;

/***/ }),

/***/ "./dist/error/businessError.js":
/*!*************************************!*\
  !*** ./dist/error/businessError.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ "../iota-pico-core/dist/error/coreError.js");
/**
 * A business implementation of an error.
 */


var BusinessError =
/*#__PURE__*/
function (_coreError_1$CoreErro) {
  _inherits(BusinessError, _coreError_1$CoreErro);

  /**
   * Create an instance of BusinessError.
   * @param message The message for the error.
   * @param additional Additional details about the error.
   * @param innerError Add information from inner error if there was one.
   */
  function BusinessError(message, additional, innerError) {
    var _this;

    _classCallCheck(this, BusinessError);

    _this = _possibleConstructorReturn(this, (BusinessError.__proto__ || Object.getPrototypeOf(BusinessError)).call(this, message, additional, innerError));
    _this.domain = "Business";
    return _this;
  }

  return BusinessError;
}(coreError_1.CoreError);

exports.BusinessError = BusinessError;

/***/ }),

/***/ "./dist/helpers/addressHelper.js":
/*!***************************************!*\
  !*** ./dist/helpers/addressHelper.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ "../iota-pico-crypto/dist/factories/spongeFactory.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");
/**
 * Helper class for address signing.
 * Original https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js
 * @internal
 */


var AddressHelper =
/*#__PURE__*/
function () {
  function AddressHelper() {
    _classCallCheck(this, AddressHelper);
  }

  _createClass(AddressHelper, null, [{
    key: "createChecksum",

    /**
     * Create a checksum for the trits.
     * @param trits The trits to create the checksum for.
     * @param checksumLength The length of the checksum.
     * @returns the checksum as trytes.
     */
    value: function createChecksum(trits, checksumLength) {
      var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
      kerl.initialize();
      kerl.absorb(trits, 0, trits.length);
      var checksumTrits = new Int8Array(kerl.getConstant("HASH_LENGTH"));
      kerl.squeeze(checksumTrits, 0, checksumTrits.length);
      return trits_1.Trits.fromArray(checksumTrits).toTrytes().toString().substring(81 - checksumLength, 81);
    }
  }]);

  return AddressHelper;
}();

exports.AddressHelper = AddressHelper;

/***/ }),

/***/ "./dist/helpers/bundleHelper.js":
/*!**************************************!*\
  !*** ./dist/helpers/bundleHelper.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../iota-pico-core/dist/helpers/arrayHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ "../iota-pico-crypto/dist/factories/spongeFactory.js");

var iss_1 = __webpack_require__(/*! @iota-pico/crypto/dist/hash/iss */ "../iota-pico-crypto/dist/hash/iss.js");

var address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ "../iota-pico-data/dist/data/address.js");

var bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ "../iota-pico-data/dist/data/bundle.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../iota-pico-data/dist/data/hash.js");

var signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ "../iota-pico-data/dist/data/signatureMessageFragment.js");

var tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ "../iota-pico-data/dist/data/tag.js");

var transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ "../iota-pico-data/dist/data/transaction.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");

var tryteNumber_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tryteNumber */ "../iota-pico-data/dist/data/tryteNumber.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../iota-pico-data/dist/data/trytes.js");

var hmacCurl_1 = __webpack_require__(/*! ../sign/hmacCurl */ "./dist/sign/hmacCurl.js");
/**
 * Helper class for signing bundles.
 * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js
 */


var BundleHelper =
/*#__PURE__*/
function () {
  function BundleHelper() {
    _classCallCheck(this, BundleHelper);
  }

  _createClass(BundleHelper, null, [{
    key: "isValid",

    /**
     * Is the bundle valid.
     * @param bundle The bundle to check for validity.
     * @returns True if the bundle is valid.
     */
    value: function isValid(bundle) {
      var isValid = false;

      if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {
        var totalSum = 0;
        var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
        kerl.initialize(); // Prepare for signature validation

        var signaturesToValidate = [];
        isValid = true;

        for (var t = 0; t < bundle.transactions.length && isValid; t++) {
          var bundleTx = bundle.transactions[t];
          totalSum += bundleTx.value.toNumber(); // currentIndex has to be equal to the index in the array

          if (bundleTx.currentIndex.toNumber() !== t) {
            isValid = false;
          } else {
            // Get the transaction trytes
            var thisTxTrytes = bundleTx.toTrytes(); // Absorb bundle hash + value + timestamp + lastIndex + currentIndex trytes.

            var thisTxTrits = trits_1.Trits.fromTrytes(thisTxTrytes.sub(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, 162)).toArray();
            kerl.absorb(thisTxTrits, 0, thisTxTrits.length); // Check if input transaction

            if (bundleTx.value.toNumber() < 0) {
              var newSignatureToValidate = {
                address: bundleTx.address,
                signatureMessageFragments: [bundleTx.signatureMessageFragment]
              }; // Find the subsequent txs with the remaining signature fragment

              for (var i = t; i < bundle.transactions.length - 1; i++) {
                var newBundleTx = bundle.transactions[i + 1]; // Check if new tx is part of the signature fragment

                if (newBundleTx.address.toTrytes().toString() === bundleTx.address.toTrytes().toString() && newBundleTx.value.toNumber() === 0) {
                  newSignatureToValidate.signatureMessageFragments.push(newBundleTx.signatureMessageFragment);
                }
              }

              signaturesToValidate.push(newSignatureToValidate);
            }
          }
        } // Check for total sum, if not equal 0 return error


        if (totalSum !== 0) {
          isValid = false;
        } else {
          // get the bundle hash from the bundle transactions
          var bundleFromTxs = new Int8Array(kerl.getConstant("HASH_LENGTH"));
          kerl.squeeze(bundleFromTxs, 0, bundleFromTxs.length);
          var bundleFromTxsTrytes = trits_1.Trits.fromArray(bundleFromTxs).toTrytes().toString(); // Check if bundle hash is the same as returned by tx object

          var bundleHash = bundle.transactions[0].bundle;

          if (bundleFromTxsTrytes !== bundleHash.toTrytes().toString()) {
            isValid = false;
          } else {
            // Last tx in the bundle should have currentIndex === lastIndex
            if (bundle.transactions[bundle.transactions.length - 1].currentIndex.toNumber() !== bundle.transactions[bundle.transactions.length - 1].lastIndex.toNumber()) {
              isValid = false;
            } else {
              // Validate the signatures
              for (var _i = 0; _i < signaturesToValidate.length && isValid; _i++) {
                var isValidSignature = iss_1.ISS.validateSignatures(signaturesToValidate[_i].address, signaturesToValidate[_i].signatureMessageFragments, bundleHash);

                if (!isValidSignature) {
                  isValid = false;
                }
              }
            }
          }
        }
      }

      return isValid;
    }
    /**
     * Validate signatures for each of the co-signers in the multi-signature to independently verify that a generated
     * transaction with the corresponding signatures of the co-signers is valid.
     * @param signedBundle The signed bundle to check the signatures.
     * @param inputAddress The address used to initiate the transfer.
     * @returns True is the signatures are valid.
     */

  }, {
    key: "validateSignatures",
    value: function validateSignatures(signedBundle, inputAddress) {
      var isValid = false;

      if (objectHelper_1.ObjectHelper.isType(signedBundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(signedBundle.transactions, transaction_1.Transaction) && objectHelper_1.ObjectHelper.isType(inputAddress, address_1.Address)) {
        var bundleHash;
        var signatureFragments = [];
        var inputAddressTrytes = inputAddress.toTrytes().toString();

        for (var i = 0; i < signedBundle.transactions.length; i++) {
          if (signedBundle.transactions[i].address.toTrytes().toString() === inputAddressTrytes) {
            bundleHash = signedBundle.transactions[i].bundle; // if we reached remainder bundle

            if (signedBundle.transactions[i].signatureMessageFragment.toTrytes().toString() === signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {
              break;
            }

            signatureFragments.push(signedBundle.transactions[i].signatureMessageFragment);
          }
        }

        if (bundleHash) {
          isValid = iss_1.ISS.validateSignatures(inputAddress, signatureFragments, bundleHash);
        }
      }

      return isValid;
    }
    /**
     * Prepare a bundle.
     * @param timeService To use for stamping the transactions.
     * @param transfers The transfers to add to the bundle.
     */

  }, {
    key: "prepareBundle",
    value: function prepareBundle(timeService, transfers) {
      var bundle = new bundle_1.Bundle();
      var lastTag;
      var totalValue = 0;
      var signatureMessageFragments = []; //  Iterate over all transfers, get totalValue
      //  and prepare the Messages, message and tag

      for (var i = 0; i < transfers.length; i++) {
        var signatureMessageLength = 1; // If message longer than 2187 trytes, increase signatureMessageLength (add 2nd transaction)

        var messageString = transfers[i].message.toString();

        if (messageString.length > signatureMessageFragment_1.SignatureMessageFragment.LENGTH) {
          // Get total length, message / maxLength (2187 trytes)
          signatureMessageLength += Math.floor(messageString.length / signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
          var msgCopy = messageString; // While there is still a message, copy it

          while (msgCopy) {
            var fragment = msgCopy.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
            msgCopy = msgCopy.slice(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, msgCopy.length); // Pad remainder of fragment

            for (var j = 0; fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; j++) {
              fragment += "9";
            }

            signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(fragment)));
          }
        } else {
          // Else, get single fragment with 2187 of 9's trytes
          var _fragment = "";

          if (messageString) {
            _fragment = messageString.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
          }

          for (var _j = 0; _fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; _j++) {
            _fragment += "9";
          }

          signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(_fragment)));
        } // get current timestamp in seconds


        var timestamp = Math.floor(timeService.msSinceEpoch() / 1000);
        lastTag = transfers[i].tag; // Add first entries to the bundle

        bundle.addTransactions(signatureMessageLength, transfers[i].address, transfers[i].value, transfers[i].tag, timestamp); // Sum up total value

        totalValue += transfers[i].value;
      }

      return {
        bundle: bundle,
        totalValue: totalValue,
        lastTag: lastTag,
        signatureMessageFragments: signatureMessageFragments
      };
    }
    /**
     * Sign the input of the bundle.
     * @param seed The seed to use for signing.
     * @param bundle The bundle to sign.
     * @param transferOptions Additional transfer options.
     * @param signatureMessageFragments The signature message fragemtns.
     * @param inputs The input for use.
     * @param addedHMAC Has an HMAC been added.
     */

  }, {
    key: "signInputs",
    value: function signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC) {
      BundleHelper.finalizeBundle(bundle);
      bundle.addSignatureMessageFragments(signatureMessageFragments); //  Here we do the actual signing of the inputs
      //  Iterate over all bundle transactions, find the inputs
      //  Get the corresponding private key and calculate the signatureMessageFragment

      for (var i = 0; i < bundle.transactions.length; i++) {
        if (bundle.transactions[i].value.toNumber() < 0) {
          var addressTrytes = bundle.transactions[i].address.toTrytes().toString(); // Get the corresponding keyIndex and security of the address

          var keyIndex = void 0;
          var keySecurity = void 0;

          for (var k = 0; k < inputs.length; k++) {
            if (inputs[k].address.toTrytes().toString() === addressTrytes) {
              keyIndex = inputs[k].keyIndex;
              keySecurity = inputs[k].security ? inputs[k].security : transferOptions.security;
              break;
            }
          } // Get corresponding private key of address


          var key = iss_1.ISS.key(seed, keyIndex, keySecurity);
          BundleHelper.signTransactions(bundle, i, 0, key, addressTrytes, keySecurity);
        }
      }

      if (addedHMAC) {
        var hmac = new hmacCurl_1.HmacCurl(transferOptions.hmacKey);
        hmac.addHMAC(bundle);
      }
    }
    /**
     * Sign the trsnactions
     * @param bundle The bundle of transactions to sign.
     * @param index The index to start.
     * @param firstUnsignedIndex The first unsigned index.
     * @param keyTrits The key trits.
     * @param addressTrytes The address trytes.
     * @param security The security level.
     */

  }, {
    key: "signTransactions",
    value: function signTransactions(bundle, index, firstUnsignedIndex, keyTrits, addressTrytes, security) {
      var bundleHash = bundle.transactions[index].bundle; //  Get the normalized bundle hash

      var normalizedBundleHash = iss_1.ISS.normalizedBundle(bundleHash);
      var normalizedBundleFragments = []; // Split hash into 3 fragments

      for (var l = 0; l < 3; l++) {
        normalizedBundleFragments[l] = normalizedBundleHash.slice(l * 27, (l + 1) * 27);
      } //  First 6561 trits for the firstFragment


      var firstFragment = keyTrits.slice(0, 6561); //  First bundle fragment uses the first 27 trytes

      var firstBundleFragment = normalizedBundleFragments[firstUnsignedIndex]; //  Calculate the new signatureMessageFragment with the first bundle fragment

      var firstSignedFragment = iss_1.ISS.signatureMessageFragment(firstBundleFragment, firstFragment); //  Convert signature to trytes and assign the new signatureMessageFragment

      bundle.transactions[index].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(firstSignedFragment).toTrytes()); // if user chooses higher than 27-tryte security
      // for each security level, add an additional signature

      for (var j = 1; j < security; j++) {
        //  Because the signature is > 2187 trytes, we need to
        //  find the subsequent transaction to add the remainder of the signature
        //  Same address as well as value = 0 (as we already spent the input)
        if (bundle.transactions[index + j].address.toTrytes().toString() === addressTrytes && bundle.transactions[index + j].value.toNumber() === 0) {
          // Use the next 6561 trits
          var nextFragment = keyTrits.slice(6561 * j, (j + 1) * 6561);
          var nextBundleFragment = normalizedBundleFragments[j]; //  Calculate the new signature

          var nextSignedFragment = iss_1.ISS.signatureMessageFragment(nextBundleFragment, nextFragment); //  Convert signature to trytes and assign it again to this bundle entry

          bundle.transactions[index + j].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(nextSignedFragment).toTrytes());
        }
      }
    }
    /**
     * Finalize a bundle.
     * @param bundle The bundle to finalize.
     */

  }, {
    key: "finalizeBundle",
    value: function finalizeBundle(bundle) {
      if (bundle.transactions.length > 0) {
        var validBundle = false;

        while (!validBundle) {
          var kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
          kerl.initialize();

          for (var i = 0; i < bundle.transactions.length; i++) {
            bundle.transactions[i].currentIndex = tryteNumber_1.TryteNumber.fromNumber(i);
            bundle.transactions[i].lastIndex = tryteNumber_1.TryteNumber.fromNumber(bundle.transactions.length - 1);
            var bundleEssence = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(bundle.transactions[i].address.toTrytes().toString() + bundle.transactions[i].value.toTrytes().toString() + transaction_1.Transaction.CHECK_VALUE + bundle.transactions[i].obsoleteTag.toTrytes().toString() + bundle.transactions[i].timestamp.toTrytes().toString() + bundle.transactions[i].currentIndex.toTrytes().toString() + bundle.transactions[i].lastIndex.toTrytes().toString())).toArray();
            kerl.absorb(bundleEssence, 0, bundleEssence.length);
          }

          var hashTrits = new Int8Array(kerl.getConstant("HASH_LENGTH"));
          kerl.squeeze(hashTrits, 0, hashTrits.length);
          var hash = hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());

          for (var _i2 = 0; _i2 < bundle.transactions.length; _i2++) {
            bundle.transactions[_i2].bundle = hash;
          }

          var normalizedHash = iss_1.ISS.normalizedBundle(hash);

          if (normalizedHash.indexOf(13
          /* = M */
          ) !== -1) {
            // Insecure bundle. Increment Tag and recompute bundle hash.
            var increasedTag = trits_1.Trits.add(trits_1.Trits.fromTrytes(bundle.transactions[0].obsoleteTag.toTrytes()), trits_1.Trits.fromNumberArray([1]));
            bundle.transactions[0].obsoleteTag = tag_1.Tag.fromTrytes(increasedTag.toTrytes());
          } else {
            validBundle = true;
          }
        }
      }
    }
  }]);

  return BundleHelper;
}();

BundleHelper.NUMBER_OF_FRAGMENT_CHUNKS = 27;
exports.BundleHelper = BundleHelper;

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
  for (var p in m) {
    if (!exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Combined index of all the modules.
 */

__export(__webpack_require__(/*! ./error/businessError */ "./dist/error/businessError.js"));

__export(__webpack_require__(/*! ./helpers/addressHelper */ "./dist/helpers/addressHelper.js"));

__export(__webpack_require__(/*! ./helpers/bundleHelper */ "./dist/helpers/bundleHelper.js"));

__export(__webpack_require__(/*! ./multiSig/multiSigAddress */ "./dist/multiSig/multiSigAddress.js"));

__export(__webpack_require__(/*! ./multiSig/multiSigClient */ "./dist/multiSig/multiSigClient.js"));

__export(__webpack_require__(/*! ./sign/hmacCurl */ "./dist/sign/hmacCurl.js"));

__export(__webpack_require__(/*! ./transactions/transactionClient */ "./dist/transactions/transactionClient.js"));

/***/ }),

/***/ "./dist/multiSig/multiSigAddress.js":
/*!******************************************!*\
  !*** ./dist/multiSig/multiSigAddress.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../iota-pico-core/dist/helpers/arrayHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ "../iota-pico-crypto/dist/factories/spongeFactory.js");

var address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ "../iota-pico-data/dist/data/address.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../iota-pico-data/dist/data/trytes.js");

var businessError_1 = __webpack_require__(/*! ../error/businessError */ "./dist/error/businessError.js");
/**
 * Address using multiple signatures.
 */


var MultiSigAddress =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the MultiSigAddress.
   */
  function MultiSigAddress() {
    _classCallCheck(this, MultiSigAddress);

    this._kerl = spongeFactory_1.SpongeFactory.instance().create("kerl");
    this._hashLength = this._kerl.getConstant("HASH_LENGTH");

    this._kerl.initialize();
  }
  /**
   * Absorb key digests.
   * @param digests The digests hashes to absorb.
   */


  _createClass(MultiSigAddress, [{
    key: "absorb",
    value: function absorb(digests) {
      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {
        throw new businessError_1.BusinessError("The digests should be an array of type Trytes");
      }

      for (var i = 0; i < digests.length; i++) {
        var digestTrits = trits_1.Trits.fromTrytes(digests[i]).toArray();

        this._kerl.absorb(digestTrits, 0, digestTrits.length);
      }
    }
    /**
     * Finalizes and returns the multisig address in trytes.
     * @param digests The final digests hashes to absorb.
     * @returns The multi signature address.
     */

  }, {
    key: "finalize",
    value: function finalize(digests) {
      if (!objectHelper_1.ObjectHelper.isEmpty(digests)) {
        this.absorb(digests);
      }

      var addressTrits = new Int8Array(this._hashLength);

      this._kerl.squeeze(addressTrits, 0, addressTrits.length);

      return address_1.Address.fromTrytes(trits_1.Trits.fromArray(addressTrits).toTrytes());
    }
  }]);

  return MultiSigAddress;
}();

exports.MultiSigAddress = MultiSigAddress;

/***/ }),

/***/ "./dist/multiSig/multiSigClient.js":
/*!*****************************************!*\
  !*** ./dist/multiSig/multiSigClient.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../iota-pico-core/dist/helpers/arrayHelper.js");

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var timeService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/timeService */ "../iota-pico-core/dist/services/timeService.js");

var iss_1 = __webpack_require__(/*! @iota-pico/crypto/dist/hash/iss */ "../iota-pico-crypto/dist/hash/iss.js");

var address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ "../iota-pico-data/dist/data/address.js");

var bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ "../iota-pico-data/dist/data/bundle.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../iota-pico-data/dist/data/hash.js");

var signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ "../iota-pico-data/dist/data/signatureMessageFragment.js");

var tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ "../iota-pico-data/dist/data/tag.js");

var transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ "../iota-pico-data/dist/data/transaction.js");

var transfer_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transfer */ "../iota-pico-data/dist/data/transfer.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../iota-pico-data/dist/data/trytes.js");

var businessError_1 = __webpack_require__(/*! ../error/businessError */ "./dist/error/businessError.js");

var bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ "./dist/helpers/bundleHelper.js");

var multiSigAddress_1 = __webpack_require__(/*! ./multiSigAddress */ "./dist/multiSig/multiSigAddress.js");
/**
 * Multiple signatures.
 * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/multisig/multisig.js
 */


var MultiSigClient =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the MultiSigClient.
   * @param apiClient An API Client to communicate through.
   * @param timeService A class which can provide the time.
   */
  function MultiSigClient(apiClient) {
    var timeService = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new timeService_1.TimeService();

    _classCallCheck(this, MultiSigClient);

    this._apiClient = apiClient;
    this._timeService = timeService;
  }
  /**
   * Get the key value of a seed.
   * @param seed The seed to get the key for.
   * @param index The address index to use.
   * @param security The security level to use.
   * @returns The trytes for the key.
   */


  _createClass(MultiSigClient, [{
    key: "prepareTransfer",

    /**
     * Initiates the creation of a new transfer by generating an empty bundle with the correct number
     * of bundle entries to be later used for the signing process.
     * @param address Address which has sufficient balance and is controlled by the co-signers.
     * @param securitySum the sum of the security levels from all cosigners chosen during the private key generation (getKey / getDigest)
     * @param balance The balance available for the transfer, if 0 will call getBalances to lookup available.
     * @param transfers The transfers to perform.
     * @param remainderAddress If there is a remainder after the transfer then send the amount to this address.
     */
    value: function () {
      var _prepareTransfer = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(address, securitySum, balance, transfers, remainderAddress) {
        var emptyTrytes, prepared, totalBalance, request, response, timestamp;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
                  _context.next = 2;
                  break;
                }

                throw new businessError_1.BusinessError("The address should be an object of type Address");

              case 2:
                if (!(!numberHelper_1.NumberHelper.isInteger(securitySum) || securitySum < 0)) {
                  _context.next = 4;
                  break;
                }

                throw new businessError_1.BusinessError("The securitySum should be a number >= 0");

              case 4:
                if (!(!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0)) {
                  _context.next = 6;
                  break;
                }

                throw new businessError_1.BusinessError("The balance should be a number >= 0");

              case 6:
                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {
                  _context.next = 8;
                  break;
                }

                throw new businessError_1.BusinessError("The transfers should be an array of type Transfer");

              case 8:
                if (!(!objectHelper_1.ObjectHelper.isEmpty(remainderAddress) && !objectHelper_1.ObjectHelper.isType(remainderAddress, address_1.Address))) {
                  _context.next = 10;
                  break;
                }

                throw new businessError_1.BusinessError("The remainderAddress should be an object of type Address");

              case 10:
                emptyTrytes = trytes_1.Trytes.fromString(""); // If message or tag is not supplied, provide it

                transfers.forEach(function (transfer) {
                  transfer.message = transfer.message ? transfer.message : emptyTrytes;
                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;
                });
                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);

                if (!(prepared.totalValue === 0)) {
                  _context.next = 17;
                  break;
                }

                throw new businessError_1.BusinessError("The total transfer value is 0, the transfer does not require a signature");

              case 17:
                totalBalance = balance;

                if (!(totalBalance === 0)) {
                  _context.next = 24;
                  break;
                }

                request = {
                  addresses: [address.toTrytes().toString()],
                  threshold: 100
                };
                _context.next = 22;
                return this._apiClient.getBalances(request);

              case 22:
                response = _context.sent;
                totalBalance = parseInt(response.balances[0], 10);

              case 24:
                if (!(prepared.totalValue > totalBalance)) {
                  _context.next = 26;
                  break;
                }

                throw new businessError_1.BusinessError("Not enough balance to satisfy the value", {
                  totalValue: prepared.totalValue,
                  totalBalance: totalBalance
                });

              case 26:
                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry
                // Only a single entry, signatures will be added later

                prepared.bundle.addTransactions(securitySum, address, -totalBalance, prepared.lastTag, timestamp); // If there is a remainder value
                // Add extra output to send remaining funds to

                if (!(totalBalance > prepared.totalValue)) {
                  _context.next = 32;
                  break;
                }

                if (!objectHelper_1.ObjectHelper.isEmpty(remainderAddress)) {
                  _context.next = 31;
                  break;
                }

                throw new businessError_1.BusinessError("Transfer has remainder but no remainder address was provided");

              case 31:
                prepared.bundle.addTransactions(1, remainderAddress, totalBalance - prepared.totalValue, prepared.lastTag, timestamp);

              case 32:
                bundleHelper_1.BundleHelper.finalizeBundle(prepared.bundle);
                prepared.bundle.addSignatureMessageFragments(prepared.signatureMessageFragments);

              case 34:
                return _context.abrupt("return", prepared.bundle);

              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function prepareTransfer(_x, _x2, _x3, _x4, _x5) {
        return _prepareTransfer.apply(this, arguments);
      };
    }()
  }], [{
    key: "getKey",
    value: function getKey(seed, index, security) {
      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
        throw new businessError_1.BusinessError("The seed should be an object of type Hash");
      }

      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {
        throw new businessError_1.BusinessError("The index should be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {
        throw new businessError_1.BusinessError("The security must be between 1 and 3", {
          security: security
        });
      }

      return trits_1.Trits.fromArray(iss_1.ISS.key(seed, index, security)).toTrytes();
    }
    /**
     * Get the digest value of a seed.
     * @param seed The seed to get the digest for.
     * @param index The address index to use.
     * @param security The security level to use.
     * @returns The trytes for the digest.
     */

  }, {
    key: "getDigest",
    value: function getDigest(seed, index, security) {
      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
        throw new businessError_1.BusinessError("The seed should be an object of type Hash");
      }

      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {
        throw new businessError_1.BusinessError("The index should be a number >= 0");
      }

      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {
        throw new businessError_1.BusinessError("The security must be between 1 and 3", {
          security: security
        });
      }

      var key = iss_1.ISS.key(seed, index, security);
      return trits_1.Trits.fromArray(iss_1.ISS.digests(key)).toTrytes();
    }
    /**
     * Validate address.
     * @param address The address to validate against the digests.
     * @param digests The digests to use to validate the address.
     * @returns True if the address matches the digests.
     */

  }, {
    key: "validateAddress",
    value: function validateAddress(address, digests) {
      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new businessError_1.BusinessError("The address should be an object of type Address");
      }

      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {
        throw new businessError_1.BusinessError("The digests should be an array of type Trytes");
      }

      return address.toTrytes().toString() === new multiSigAddress_1.MultiSigAddress().finalize(digests).toTrytes().toString();
    }
    /**
     * Adds the cosigner signatures to the corresponding bundle transactions.
     * @param bundle The bundle to sign.
     * @param address The address to match the transactions.
     * @param key The key to sign the transactions with.
     */

  }, {
    key: "addSignature",
    value: function addSignature(bundle, address, key) {
      if (!objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {
        throw new businessError_1.BusinessError("The bundle should be an object of type Bundle");
      }

      if (!arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {
        throw new businessError_1.BusinessError("The bundle.transactions should be an array of type Transaction");
      }

      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {
        throw new businessError_1.BusinessError("The address should be an object of type Address");
      }

      if (!objectHelper_1.ObjectHelper.isType(key, trytes_1.Trytes)) {
        throw new businessError_1.BusinessError("The key should be an object of type Trytes");
      }

      var keyTrits = trits_1.Trits.fromTrytes(key).toArray(); // Get the security used for the private key
      // 1 security level = 2187 trytes

      var security = keyTrits.length / 3 / 2187; // First get the total number of already signed transactions
      // use that for the bundle hash calculation as well as knowing
      // where to add the signature

      var numSignedTxs = 0;
      var addressTrytes = address.toTrytes().toString();

      for (var i = 0; i < bundle.transactions.length; i++) {
        if (bundle.transactions[i].address.toTrytes().toString() === addressTrytes) {
          if (bundle.transactions[i].signatureMessageFragment.toTrytes().toString() !== signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {
            // If transaction is already signed, increase counter
            numSignedTxs++;
          } else {
            bundleHelper_1.BundleHelper.signTransactions(bundle, i, numSignedTxs % 3, keyTrits, addressTrytes, security);
            break;
          }
        }
      }
    }
  }]);

  return MultiSigClient;
}();

exports.MultiSigClient = MultiSigClient;

/***/ }),

/***/ "./dist/sign/hmacCurl.js":
/*!*******************************!*\
  !*** ./dist/sign/hmacCurl.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ "../iota-pico-crypto/dist/factories/spongeFactory.js");

var signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ "../iota-pico-data/dist/data/signatureMessageFragment.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../iota-pico-data/dist/data/trytes.js");
/**
 * Hashed Message Authentication Code using Curl.
 */


var HmacCurl =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the HmacCurl.
   * @param key The key to seed with.
   */
  function HmacCurl(key) {
    _classCallCheck(this, HmacCurl);

    this._keyTrits = trits_1.Trits.fromTrytes(key).toArray();
  }
  /**
   * Add bundle to the HMAC.
   */


  _createClass(HmacCurl, [{
    key: "addHMAC",
    value: function addHMAC(bundle) {
      var curl = spongeFactory_1.SpongeFactory.instance().create("curl", HmacCurl.HMAC_ROUNDS);
      var hashLength = curl.getConstant("HASH_LENGTH");
      var key = this._keyTrits;

      for (var i = 0; i < bundle.transactions.length; i++) {
        if (bundle.transactions[i].value.toNumber() > 0) {
          var bundleHashTrits = trits_1.Trits.fromTrytes(bundle.transactions[i].bundle.toTrytes()).toArray();
          var hmac = new Int8Array(hashLength);
          curl.initialize();
          curl.absorb(key, 0, key.length);
          curl.absorb(bundleHashTrits, 0, bundleHashTrits.length);
          curl.squeeze(hmac, 0, hmac.length);
          var hmacTrytes = trits_1.Trits.fromArray(hmac).toTrytes().toString();
          var rest = bundle.transactions[i].signatureMessageFragment.toTrytes().toString().substring(81, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);
          bundle.transactions[i].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(hmacTrytes + rest));
        }
      }
    }
  }]);

  return HmacCurl;
}();
/* @internal */


HmacCurl.HMAC_ROUNDS = 27;
exports.HmacCurl = HmacCurl;

/***/ }),

/***/ "./dist/transactions/proofOfWorkApi.js":
/*!*********************************************!*\
  !*** ./dist/transactions/proofOfWorkApi.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../iota-pico-core/dist/helpers/arrayHelper.js");

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ "../iota-pico-crypto/dist/error/cryptoError.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../iota-pico-data/dist/data/hash.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../iota-pico-data/dist/data/trytes.js");

var businessError_1 = __webpack_require__(/*! ../error/businessError */ "./dist/error/businessError.js");
/**
 * ProofOfWork implementation using API.
 */


var ProofOfWorkApi =
/*#__PURE__*/
function () {
  /**
   * Create an instance of ProofOfWork.
   * @param apiClient The API client to send the request through.
   */
  function ProofOfWorkApi(apiClient) {
    _classCallCheck(this, ProofOfWorkApi);

    if (objectHelper_1.ObjectHelper.isEmpty(apiClient)) {
      throw new businessError_1.BusinessError("The apiClient must not be empty");
    }

    this._apiClient = apiClient;
  }
  /**
   * Allow the proof of work to perform any initialization.
   * Will throw an exception if the implementation is not supported.
   */


  _createClass(ProofOfWorkApi, [{
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve());

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function initialize() {
        return _initialize.apply(this, arguments);
      };
    }()
    /**
     * Perform a proof of work on the data.
     * @param trunkTransaction The trunkTransaction to use for the pow.
     * @param branchTransaction The branchTransaction to use for the pow.
     * @param trytes The trytes to perform the pow on.
     * @param minWeightMagnitude The minimum weight magnitude.
     * @returns The trytes produced by the proof of work.
     */

  }, {
    key: "pow",
    value: function () {
      var _pow = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {
        var attachToTangleRequest, attachToTangleResponse;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {
                  _context2.next = 2;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trunkTransaction must be an object of type Hash");

              case 2:
                if (objectHelper_1.ObjectHelper.isType(branchTransaction, hash_1.Hash)) {
                  _context2.next = 4;
                  break;
                }

                throw new cryptoError_1.CryptoError("The branchTransaction must be an object of type Hash");

              case 4:
                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {
                  _context2.next = 6;
                  break;
                }

                throw new cryptoError_1.CryptoError("The trytes must be an array of type Trytes");

              case 6:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context2.next = 8;
                  break;
                }

                throw new cryptoError_1.CryptoError("The minWeightMagnitude must be > 0");

              case 8:
                attachToTangleRequest = {
                  trunkTransaction: trunkTransaction.toString(),
                  branchTransaction: branchTransaction.toString(),
                  minWeightMagnitude: minWeightMagnitude,
                  trytes: trytes.map(function (t) {
                    return t.toString();
                  })
                };
                _context2.next = 11;
                return this._apiClient.attachToTangle(attachToTangleRequest);

              case 11:
                attachToTangleResponse = _context2.sent;

                if (!(objectHelper_1.ObjectHelper.isEmpty(attachToTangleResponse) || arrayHelper_1.ArrayHelper.isEmpty(attachToTangleResponse.trytes))) {
                  _context2.next = 16;
                  break;
                }

                throw new cryptoError_1.CryptoError("The attachToTangleRequest did not return any trytes");

              case 16:
                return _context2.abrupt("return", attachToTangleResponse.trytes.map(function (returnTrytes) {
                  return trytes_1.Trytes.fromString(returnTrytes);
                }));

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function pow(_x, _x2, _x3, _x4) {
        return _pow.apply(this, arguments);
      };
    }()
  }]);

  return ProofOfWorkApi;
}();

exports.ProofOfWorkApi = ProofOfWorkApi;

/***/ }),

/***/ "./dist/transactions/transactionClient.js":
/*!************************************************!*\
  !*** ./dist/transactions/transactionClient.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ "../iota-pico-core/dist/helpers/arrayHelper.js");

var numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ "../iota-pico-core/dist/helpers/numberHelper.js");

var objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ "../iota-pico-core/dist/helpers/objectHelper.js");

var nullLogger_1 = __webpack_require__(/*! @iota-pico/core/dist/loggers/nullLogger */ "../iota-pico-core/dist/loggers/nullLogger.js");

var backgroundTaskService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/backgroundTaskService */ "../iota-pico-core/dist/services/backgroundTaskService.js");

var timeService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/timeService */ "../iota-pico-core/dist/services/timeService.js");

var iss_1 = __webpack_require__(/*! @iota-pico/crypto/dist/hash/iss */ "../iota-pico-crypto/dist/hash/iss.js");

var transactionHelper_1 = __webpack_require__(/*! @iota-pico/crypto/dist/helpers/transactionHelper */ "../iota-pico-crypto/dist/helpers/transactionHelper.js");

var address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ "../iota-pico-data/dist/data/address.js");

var addressSecurity_1 = __webpack_require__(/*! @iota-pico/data/dist/data/addressSecurity */ "../iota-pico-data/dist/data/addressSecurity.js");

var bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ "../iota-pico-data/dist/data/bundle.js");

var hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ "../iota-pico-data/dist/data/hash.js");

var input_1 = __webpack_require__(/*! @iota-pico/data/dist/data/input */ "../iota-pico-data/dist/data/input.js");

var tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ "../iota-pico-data/dist/data/tag.js");

var transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ "../iota-pico-data/dist/data/transaction.js");

var transfer_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transfer */ "../iota-pico-data/dist/data/transfer.js");

var trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ "../iota-pico-data/dist/data/trits.js");

var trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ "../iota-pico-data/dist/data/trytes.js");

var businessError_1 = __webpack_require__(/*! ../error/businessError */ "./dist/error/businessError.js");

var addressHelper_1 = __webpack_require__(/*! ../helpers/addressHelper */ "./dist/helpers/addressHelper.js");

var bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ "./dist/helpers/bundleHelper.js");

var proofOfWorkApi_1 = __webpack_require__(/*! ./proofOfWorkApi */ "./dist/transactions/proofOfWorkApi.js");
/**
 * Default implementation of the ITransactionClient.
 */


var TransactionClient =
/*#__PURE__*/
function () {
  /**
   * Create a new instance of the TransactionClient.
   * @param apiClient An API Client to communicate through.
   * @param proofOfWork Proof of work module to use, if undefined will use remote.
   * @param timeService A class which can provide the time.
   * @param backgroundTaskService A class which can provide background tasks.
   * @param logger Logger to send transaction info to.
   */
  function TransactionClient(apiClient, proofOfWork, timeService, backgroundTaskService, logger) {
    _classCallCheck(this, TransactionClient);

    if (objectHelper_1.ObjectHelper.isEmpty(apiClient)) {
      throw new businessError_1.BusinessError("The apiClient must not be empty");
    }

    this._apiClient = apiClient;
    this._proofOfWork = proofOfWork || new proofOfWorkApi_1.ProofOfWorkApi(apiClient);
    this._timeService = timeService || new timeService_1.TimeService();
    this._backgroundTaskService = backgroundTaskService || new backgroundTaskService_1.BackgroundTaskService();
    this._logger = logger || new nullLogger_1.NullLogger();
  }
  /**
   * Returns the list of transaction in progress.
   * @returns Promise which resolves to a list of hashes or rejects with error.
   */


  _createClass(TransactionClient, [{
    key: "getTransactionsInProgress",
    value: function () {
      var _getTransactionsInProgress = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var response, resp;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._logger.info("===> TransactionClient::getTransactionsInProgress");

                _context.next = 3;
                return this._apiClient.getTips();

              case 3:
                response = _context.sent;

                if (!(response && response.hashes)) {
                  _context.next = 10;
                  break;
                }

                resp = response.hashes.map(function (hash) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));
                });

                this._logger.info("<=== TransactionClient::getTransactionsInProgress", resp);

                return _context.abrupt("return", resp);

              case 10:
                this._logger.info("<=== TransactionClient::getTransactionsInProgress", []);

                return _context.abrupt("return", []);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function getTransactionsInProgress() {
        return _getTransactionsInProgress.apply(this, arguments);
      };
    }()
    /**
     * Find the transactions which match the specified input and return. All input values are lists,
     * for which a list of return values (transaction hashes), in the same order, is returned for all
     * individual elements. Using multiple of these input fields returns the intersection of the values.
     * @param bundles Bundles to lookup transaction hashes for.
     * @param addresses Addresses to lookup transaction hashes for.
     * @param tags Tags to lookup transaction hashes for.
     * @param approvees Approvees to lookup transaction hashes for.
     * @returns Promise which resolves with a list of hashes or rejects with error.
     */

  }, {
    key: "findTransactions",
    value: function () {
      var _findTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(bundles, addresses, tags, approvees) {
        var hasBundle, hasAddresses, hasTags, hasApprovees, request, response, resp;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this._logger.info("===> TransactionClient::findTransactions", bundles, addresses, tags, approvees);

                hasBundle = bundles !== undefined && bundles !== null && bundles.length > 0;
                hasAddresses = addresses !== undefined && addresses !== null && addresses.length > 0;
                hasTags = tags !== undefined && tags !== null && tags.length > 0;
                hasApprovees = approvees !== undefined && approvees !== null && approvees.length > 0;

                if (!(hasBundle && !arrayHelper_1.ArrayHelper.isTyped(bundles, hash_1.Hash))) {
                  _context2.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The bundles must be an array of type Hash");

              case 7:
                if (!(hasAddresses && !arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address))) {
                  _context2.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The addresses must be an array of type Address");

              case 9:
                if (!(hasTags && !arrayHelper_1.ArrayHelper.isTyped(tags, tag_1.Tag))) {
                  _context2.next = 11;
                  break;
                }

                throw new businessError_1.BusinessError("The tags must be an array of type Tag");

              case 11:
                if (!(hasApprovees && !arrayHelper_1.ArrayHelper.isTyped(approvees, hash_1.Hash))) {
                  _context2.next = 13;
                  break;
                }

                throw new businessError_1.BusinessError("The approvees must be an array of type Hash");

              case 13:
                if (!(!hasBundle && !hasAddresses && !hasTags && !hasApprovees)) {
                  _context2.next = 15;
                  break;
                }

                throw new businessError_1.BusinessError("You must provide bundles, addresses, tags or approvees");

              case 15:
                request = {
                  bundles: hasBundle ? bundles.map(function (bundle) {
                    return bundle.toTrytes().toString();
                  }) : undefined,
                  addresses: hasAddresses ? addresses.map(function (address) {
                    return address.toTrytes().toString();
                  }) : undefined,
                  tags: hasTags ? tags.map(function (tag) {
                    return tag.toTrytes().toString();
                  }) : undefined,
                  approvees: hasApprovees ? approvees.map(function (approvee) {
                    return approvee.toTrytes().toString();
                  }) : undefined
                };
                _context2.next = 18;
                return this._apiClient.findTransactions(request);

              case 18:
                response = _context2.sent;

                if (!(response && response.hashes)) {
                  _context2.next = 25;
                  break;
                }

                resp = response.hashes.map(function (hash) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));
                });

                this._logger.info("<=== TransactionClient::findTransactions", resp);

                return _context2.abrupt("return", resp);

              case 25:
                this._logger.info("<=== TransactionClient::findTransactions", []);

                return _context2.abrupt("return", []);

              case 27:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function findTransactions(_x, _x2, _x3, _x4) {
        return _findTransactions.apply(this, arguments);
      };
    }()
    /**
     * Get the transaction details of specific transactions.
     * @returns Promise which resolves to the list of transactions or rejects with error.
     */

  }, {
    key: "getTransactionsObjects",
    value: function () {
      var _getTransactionsObjects = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(transactionHashes) {
        var request, response, resp;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._logger.info("===> TransactionClient::getTransactionsObjects", transactionHashes);

                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {
                  _context3.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionHashes must be an array of type Hash");

              case 3:
                request = {
                  hashes: transactionHashes.map(function (hash) {
                    return hash.toTrytes().toString();
                  })
                };
                _context3.next = 6;
                return this._apiClient.getTrytes(request);

              case 6:
                response = _context3.sent;

                if (!(response && response.trytes)) {
                  _context3.next = 13;
                  break;
                }

                resp = response.trytes.map(function (trytes) {
                  return transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes));
                });

                this._logger.info("<=== TransactionClient::getTransactionsObjects", resp);

                return _context3.abrupt("return", resp);

              case 13:
                this._logger.info("<=== TransactionClient::getTransactionsObjects", []);

                return _context3.abrupt("return", []);

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function getTransactionsObjects(_x5) {
        return _getTransactionsObjects.apply(this, arguments);
      };
    }()
    /**
     * Get the inclusion states of a list of transaction hashes.
     * @returns Promise which resolves to the list of inclusion states or rejects with error.
     */

  }, {
    key: "getLatestInclusion",
    value: function () {
      var _getLatestInclusion = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(transactionHashes) {
        var nodeInfo, request, response;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._logger.info("===> TransactionClient::transactionHashes");

                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {
                  _context4.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionHashes must be an array of type Hash");

              case 3:
                _context4.next = 5;
                return this._apiClient.getNodeInfo();

              case 5:
                nodeInfo = _context4.sent;

                if (!(nodeInfo && numberHelper_1.NumberHelper.isInteger(nodeInfo.latestSolidSubtangleMilestone))) {
                  _context4.next = 20;
                  break;
                }

                request = {
                  transactions: transactionHashes.map(function (hash) {
                    return hash.toTrytes().toString();
                  }),
                  tips: [nodeInfo.latestSolidSubtangleMilestone]
                };
                _context4.next = 10;
                return this._apiClient.getInclusionStates(request);

              case 10:
                response = _context4.sent;

                if (!(response && response.states)) {
                  _context4.next = 16;
                  break;
                }

                this._logger.info("<=== TransactionClient::transactionHashes", response.states);

                return _context4.abrupt("return", response.states);

              case 16:
                this._logger.info("<=== TransactionClient::transactionHashes", []);

                return _context4.abrupt("return", []);

              case 18:
                _context4.next = 21;
                break;

              case 20:
                throw new businessError_1.BusinessError("The node could not provide the latestSolidSubtangleMilestone");

              case 21:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function getLatestInclusion(_x6) {
        return _getLatestInclusion.apply(this, arguments);
      };
    }()
    /**
     * Generates addresses with index-based or using apis.
     * @param seed The seed to generate the addresses from.
     * @param startIndex The start index to generate addresses.
     * @param endIndex The end index to generate addresses.
     * @param includeChecksum Includes the checksum on addresses.
     * @param security The security level at which to create the addresses.
     * @returns Promise which resolves to the list of addresses or rejects with error.
     */

  }, {
    key: "getNewAddress",
    value: function () {
      var _getNewAddress = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(seed, startIndex, endIndex, includeChecksum, security) {
        var localStartIndex, hasEndIndex, localSecurity, addresses, total;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._logger.info("===> TransactionClient::getNewAddress", seed, startIndex, endIndex, includeChecksum, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context5.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!objectHelper_1.ObjectHelper.isEmpty(startIndex) && !objectHelper_1.ObjectHelper.isType(startIndex, Number))) {
                  _context5.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be an integer", {
                  startIndex: startIndex
                });

              case 5:
                localStartIndex = startIndex || 0;

                if (!(localStartIndex < 0)) {
                  _context5.next = 8;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be >= 0", {
                  localStartIndex: localStartIndex
                });

              case 8:
                hasEndIndex = numberHelper_1.NumberHelper.isInteger(endIndex);
                localSecurity = security || addressSecurity_1.AddressSecurity.medium;

                if (!hasEndIndex) {
                  _context5.next = 21;
                  break;
                }

                if (!(!numberHelper_1.NumberHelper.isInteger(endIndex) || endIndex < 0)) {
                  _context5.next = 13;
                  break;
                }

                throw new businessError_1.BusinessError("The endIndex must be a number >= 0", {
                  endIndex: endIndex
                });

              case 13:
                total = endIndex - startIndex + 1;

                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {
                  _context5.next = 16;
                  break;
                }

                throw new businessError_1.BusinessError("The total must be > 0 and <= ".concat(TransactionClient.MAX_INPUTS), {
                  total: total
                });

              case 16:
                _context5.next = 18;
                return this.getAddressesByIndex(seed, startIndex, endIndex, includeChecksum, localSecurity);

              case 18:
                addresses = _context5.sent;
                _context5.next = 24;
                break;

              case 21:
                _context5.next = 23;
                return this.getAddressesToUnused(seed, startIndex, includeChecksum, localSecurity);

              case 23:
                addresses = _context5.sent;

              case 24:
                this._logger.info("<=== TransactionClient::getNewAddress", addresses);

                return _context5.abrupt("return", addresses);

              case 26:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function getNewAddress(_x7, _x8, _x9, _x10, _x11) {
        return _getNewAddress.apply(this, arguments);
      };
    }()
    /**
     * Generates new addresses index-based.
     * @param seed The seed to generate the addresses from.
     * @param startIndex The start index to generate addresses.
     * @param endIndex The end index to generate addresses.
     * @param includeChecksum Includes the checksum on addresses.
     * @param security The security level at which to create the addresses.
     * @returns Promise which resolves to the list of addresses or rejects with error.
     */

  }, {
    key: "getAddressesByIndex",
    value: function () {
      var _getAddressesByIndex = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6(seed, startIndex, endIndex, includeChecksum, security) {
        var total, addresses, i;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this._logger.info("===> TransactionClient::getAddressesByIndex", seed, startIndex, endIndex, includeChecksum, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context6.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {
                  _context6.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be a number >= 0", {
                  startIndex: startIndex
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(endIndex) || endIndex < 0)) {
                  _context6.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The endIndex must be a number >= 0", {
                  endIndex: endIndex
                });

              case 7:
                total = endIndex - startIndex + 1;

                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {
                  _context6.next = 10;
                  break;
                }

                throw new businessError_1.BusinessError("The total must be > 0 and <= ".concat(TransactionClient.MAX_INPUTS), {
                  total: total
                });

              case 10:
                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {
                  _context6.next = 12;
                  break;
                }

                throw new businessError_1.BusinessError("The security must be between 1 and 3", {
                  security: security
                });

              case 12:
                addresses = [];

                for (i = 0; i < total; i++) {
                  addresses.push(this.generateAddress(seed, startIndex + i, security, includeChecksum));
                }

                this._logger.info("<=== TransactionClient::getAddressesByIndex", addresses);

                return _context6.abrupt("return", Promise.resolve(addresses));

              case 16:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function getAddressesByIndex(_x12, _x13, _x14, _x15, _x16) {
        return _getAddressesByIndex.apply(this, arguments);
      };
    }()
    /**
     * Generates new address which havent been used using apis.
     * @param seed The seed to generate the addresses from.
     * @param startIndex The start index to generate addresses.
     * @param includeChecksum Includes the checksum on addresses.
     * @param security The security level at which to create the addresses.
     * @returns Promise which resolves to an addresses list, the first unused address is the last in the list or rejects with error.
     */

  }, {
    key: "getAddressesToUnused",
    value: function () {
      var _getAddressesToUnused = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(seed, startIndex, includeChecksum, security) {
        var localStartIndex, isUsed, addresses, address, addressNoChecksum, spentFromRequest, spentFromResponse, findTransactionsRequest, findResponse;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._logger.info("===> TransactionClient::getAddressesToUnused", seed, startIndex, includeChecksum, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context7.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {
                  _context7.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be a number >= 0", {
                  startIndex: startIndex
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {
                  _context7.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The security must be between 1 and 3", {
                  security: security
                });

              case 7:
                localStartIndex = startIndex;
                addresses = [];

              case 9:
                address = this.generateAddress(seed, localStartIndex++, security, includeChecksum);
                addresses.push(address);
                addressNoChecksum = address.toTrytes().toString();
                spentFromRequest = {
                  addresses: [addressNoChecksum]
                };
                _context7.next = 15;
                return this._apiClient.wereAddressesSpentFrom(spentFromRequest);

              case 15:
                spentFromResponse = _context7.sent;
                isUsed = spentFromResponse && spentFromResponse.states && spentFromResponse.states.length > 0 ? spentFromResponse.states[0] : false;

                if (isUsed) {
                  _context7.next = 23;
                  break;
                }

                findTransactionsRequest = {
                  addresses: [addressNoChecksum]
                };
                _context7.next = 21;
                return this._apiClient.findTransactions(findTransactionsRequest);

              case 21:
                findResponse = _context7.sent;
                isUsed = findResponse && findResponse.hashes && findResponse.hashes.length > 0;

              case 23:
                if (isUsed) {
                  _context7.next = 9;
                  break;
                }

              case 24:
                this._logger.info("<=== TransactionClient::getAddressesToUnused", addresses);

                return _context7.abrupt("return", Promise.resolve(addresses));

              case 26:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function getAddressesToUnused(_x17, _x18, _x19, _x20) {
        return _getAddressesToUnused.apply(this, arguments);
      };
    }()
    /**
     * Get the input data for a range of addresses.
     * @param seed The seed to get the input data for.
     * @param startIndex The start index to get the addresses.
     * @param endIndex The end index to get the addresses.
     * @param security The security level used to create the addresses.
     * @param totalRequired The threshold at which total balance to stop gathering addresses.
     * @returns Promise which resolves to the inputs for each address or rejects with error.
     */

  }, {
    key: "getInputs",
    value: function () {
      var _getInputs = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8(seed, startIndex, endIndex, security, totalRequired) {
        var addresses, request, response, inputs, totalBalance, i, balance, resp;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this._logger.info("===> TransactionClient::getInputs", seed, startIndex, endIndex, security, totalRequired);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context8.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {
                  _context8.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The startIndex must be a number >= 0", {
                  startIndex: startIndex
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {
                  _context8.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The security must be between 1 and 3", {
                  security: security
                });

              case 7:
                if (!(!numberHelper_1.NumberHelper.isInteger(totalRequired) || totalRequired < 0)) {
                  _context8.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The totalRequired must be >= 0", {
                  totalRequired: totalRequired
                });

              case 9:
                _context8.next = 11;
                return this.getNewAddress(seed, startIndex, endIndex, false, security);

              case 11:
                addresses = _context8.sent;
                request = {
                  addresses: addresses.map(function (add) {
                    return add.toTrytes().toString();
                  }),
                  threshold: 100
                };
                _context8.next = 15;
                return this._apiClient.getBalances(request);

              case 15:
                response = _context8.sent;
                inputs = [];
                totalBalance = 0;

                if (!response) {
                  _context8.next = 30;
                  break;
                }

                i = 0;

              case 20:
                if (!(i < addresses.length)) {
                  _context8.next = 30;
                  break;
                }

                balance = parseInt(response.balances[i], 10);

                if (!(balance > 0)) {
                  _context8.next = 27;
                  break;
                }

                inputs.push(input_1.Input.fromParams(addresses[i], security, startIndex + i, balance));
                totalBalance += balance;

                if (!(totalRequired > 0 && totalBalance >= totalRequired)) {
                  _context8.next = 27;
                  break;
                }

                return _context8.abrupt("break", 30);

              case 27:
                i++;
                _context8.next = 20;
                break;

              case 30:
                resp = {
                  inputs: inputs,
                  totalBalance: totalBalance
                };

                this._logger.info("<=== TransactionClient::getInputs", resp);

                if (!(totalRequired > 0 && totalBalance < totalRequired)) {
                  _context8.next = 34;
                  break;
                }

                throw new businessError_1.BusinessError("Not enough combined balance in the addresses to satisfy the total required", {
                  totalRequired: totalRequired,
                  totalBalance: totalBalance
                });

              case 34:
                return _context8.abrupt("return", resp);

              case 35:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function getInputs(_x21, _x22, _x23, _x24, _x25) {
        return _getInputs.apply(this, arguments);
      };
    }()
    /**
     * Prepares transfer by generating bundle, finding and signing inputs.
     * @param seed The seed to prepare the transfer for.
     * @param transfers The transfers to prepare.
     * @param transferOptions
     *      @property inputs List of inputs used for funding the transfer.
     *      @property security Security level to be used for the private key / addresses.
     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.
     *      @property hmacKey Hmac key to sign the bundle.
     *      @property reference The transaction to reference.
     * @returns Promise which resolves to the array of Trytes for the transfer or rejects with error.
     */

  }, {
    key: "prepareTransfers",
    value: function () {
      var _prepareTransfers = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(seed, transfers, transferOptions) {
        var localTransferOptions, emptyTrytes, addHMAC, addedHMAC, prepared, bundle, lastTag, totalValue, signatureMessageFragments, request, balances, confirmedInputs, totalBalance, i, balance, inputsResponse;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this._logger.info("===> TransactionClient::prepareTransfers", seed, transfers, transferOptions);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context9.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {
                  _context9.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The transfers must be an array of Transfer objects");

              case 5:
                localTransferOptions = transferOptions || {};
                localTransferOptions.security = localTransferOptions.security || addressSecurity_1.AddressSecurity.medium;
                emptyTrytes = trytes_1.Trytes.fromString("");
                addHMAC = !objectHelper_1.ObjectHelper.isEmpty(localTransferOptions.hmacKey);
                addedHMAC = false; // If message or tag is not supplied, provide it

                transfers.forEach(function (transfer) {
                  transfer.message = transfer.message ? transfer.message : emptyTrytes;
                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;

                  if (addHMAC && transfer.value > 0) {
                    transfer.message = trytes_1.Trytes.fromString(TransactionClient.NULL_HASH_TRYTES + transfer.message.toString());
                    addedHMAC = true;
                  }
                }); // Create a new bundle

                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);
                bundle = prepared.bundle;
                lastTag = prepared.lastTag;
                totalValue = prepared.totalValue;
                signatureMessageFragments = prepared.signatureMessageFragments; // Get inputs if we are sending tokens

                if (!(totalValue > 0)) {
                  _context9.next = 49;
                  break;
                }

                if (!localTransferOptions.inputs) {
                  _context9.next = 42;
                  break;
                }

                request = {
                  addresses: localTransferOptions.inputs.map(function (input) {
                    return input.address.toTrytes().toString();
                  }),
                  threshold: 100
                };
                _context9.next = 21;
                return this._apiClient.getBalances(request);

              case 21:
                balances = _context9.sent;
                confirmedInputs = [];
                totalBalance = 0;
                i = 0;

              case 25:
                if (!(i < balances.balances.length)) {
                  _context9.next = 36;
                  break;
                }

                balance = parseInt(balances.balances[i], 10); // If input has balance, add it to confirmedInputs

                if (!(balance > 0)) {
                  _context9.next = 33;
                  break;
                }

                totalBalance += balance;
                localTransferOptions.inputs[i].balance = balance;
                confirmedInputs.push(localTransferOptions.inputs[i]); // if we've already reached the intended input value, break out of loop

                if (!(totalBalance >= totalValue)) {
                  _context9.next = 33;
                  break;
                }

                return _context9.abrupt("break", 36);

              case 33:
                i++;
                _context9.next = 25;
                break;

              case 36:
                if (!(totalValue > totalBalance)) {
                  _context9.next = 38;
                  break;
                }

                throw new businessError_1.BusinessError("Not enough balance in the input addresses to satisfy the total for the transfer");

              case 38:
                _context9.next = 40;
                return this.addRemainder(seed, bundle, localTransferOptions, confirmedInputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);

              case 40:
                _context9.next = 47;
                break;

              case 42:
                _context9.next = 44;
                return this.getInputs(seed, 0, undefined, localTransferOptions.security, totalValue);

              case 44:
                inputsResponse = _context9.sent;
                _context9.next = 47;
                return this.addRemainder(seed, bundle, localTransferOptions, inputsResponse.inputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);

              case 47:
                _context9.next = 51;
                break;

              case 49:
                // If no input required, don't sign and simply finalize the bundle
                bundleHelper_1.BundleHelper.finalizeBundle(bundle);
                bundle.addSignatureMessageFragments(signatureMessageFragments);

              case 51:
                bundle.transactions = bundle.transactions.reverse();

                this._logger.info("<=== TransactionClient::prepareTransfers", bundle);

                return _context9.abrupt("return", bundle);

              case 54:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      return function prepareTransfers(_x26, _x27, _x28) {
        return _prepareTransfers.apply(this, arguments);
      };
    }()
    /**
     * Attach the transactions to the tangle by doing proof of work.
     * @param bundle The bundle of transactions to attach.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param reference The reference to send with the transactions.
     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.
     */

  }, {
    key: "attachToTangle",
    value: function () {
      var _attachToTangle = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(bundle, depth, minWeightMagnitude, reference) {
        var transactionsToApproveRequest, transactionsToApprove, allTrytes, powTransactions, newBundle;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this._logger.info("===> TransactionClient::attachToTangle", bundle, depth, minWeightMagnitude, reference);

                if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {
                  _context10.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The bundle must be an array of type Bundle");

              case 3:
                if (arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {
                  _context10.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The bundle.transactions must be an array of type Transaction");

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {
                  _context10.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The depth must be a number > 0", {
                  depth: depth
                });

              case 7:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context10.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The minWeightMagnitude must be a number > 0", {
                  minWeightMagnitude: minWeightMagnitude
                });

              case 9:
                transactionsToApproveRequest = {
                  depth: depth,
                  reference: reference ? reference.toTrytes().toString() : undefined
                };
                _context10.next = 12;
                return this._apiClient.getTransactionsToApprove(transactionsToApproveRequest);

              case 12:
                transactionsToApprove = _context10.sent;
                _context10.next = 15;
                return this._proofOfWork.pow(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.trunkTransaction)), hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.branchTransaction)), bundle.transactions.map(function (t) {
                  return t.toTrytes();
                }), minWeightMagnitude);

              case 15:
                allTrytes = _context10.sent;
                powTransactions = allTrytes.map(function (returnTrytes) {
                  return transaction_1.Transaction.fromTrytes(returnTrytes);
                });
                newBundle = new bundle_1.Bundle();
                newBundle.transactions = powTransactions;

                this._logger.info("<=== TransactionClient::attachToTangle", newBundle);

                return _context10.abrupt("return", newBundle);

              case 21:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      return function attachToTangle(_x29, _x30, _x31, _x32) {
        return _attachToTangle.apply(this, arguments);
      };
    }()
    /**
     * Wrapper function that does attachToTangle and then stores and broadcasts the transactions.
     * @param bundle The bundle of transactions to send.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param reference The reference to send with the transactions.
     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.
     */

  }, {
    key: "sendTransactions",
    value: function () {
      var _sendTransactions = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11(bundle, depth, minWeightMagnitude, reference) {
        var attachedTransactionsBundle, storeTransactionsRequest, broadcastTransactionsRequest;
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this._logger.info("===> TransactionClient::sendTransactions", bundle, depth, minWeightMagnitude, reference);

                _context11.next = 3;
                return this.attachToTangle(bundle, depth, minWeightMagnitude, reference);

              case 3:
                attachedTransactionsBundle = _context11.sent;
                storeTransactionsRequest = {
                  trytes: attachedTransactionsBundle.transactions.map(function (t) {
                    return t.toTrytes().toString();
                  })
                };
                _context11.next = 7;
                return this._apiClient.storeTransactions(storeTransactionsRequest);

              case 7:
                broadcastTransactionsRequest = {
                  trytes: storeTransactionsRequest.trytes
                };
                _context11.next = 10;
                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);

              case 10:
                this._logger.info("<=== TransactionClient::sendTransactions", attachedTransactionsBundle);

                return _context11.abrupt("return", attachedTransactionsBundle);

              case 12:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      return function sendTransactions(_x33, _x34, _x35, _x36) {
        return _sendTransactions.apply(this, arguments);
      };
    }()
    /**
     * Wrapper function that does prepareTransfers and then sendTransactions.
     * @param seed The seed to send the transfer for.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param transfers The transfers to send.
     * @param transferOptions Additional options for the transfer.
     *      @property inputs List of inputs used for funding the transfer.
     *      @property security Security level to be used for the private key / addresses.
     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.
     *      @property hmacKey Hmac key to sign the bundle.
     * @param reference The reference to send with the transactions.
     * @returns Promise which resolves to the list of transactions created or rejects with an error.
     */

  }, {
    key: "sendTransfer",
    value: function () {
      var _sendTransfer = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee12(seed, depth, minWeightMagnitude, transfers, transferOptions, reference) {
        var transferTrytes, sentBundle;
        return _regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this._logger.info("===> TransactionClient::sendTransfer", seed, depth, minWeightMagnitude, transfers, transferOptions, reference);

                _context12.next = 3;
                return this.prepareTransfers(seed, transfers, transferOptions);

              case 3:
                transferTrytes = _context12.sent;
                _context12.next = 6;
                return this.sendTransactions(transferTrytes, depth, minWeightMagnitude, reference);

              case 6:
                sentBundle = _context12.sent;

                this._logger.info("<=== TransactionClient::sendTransfer", sentBundle);

                return _context12.abrupt("return", sentBundle);

              case 9:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      return function sendTransfer(_x37, _x38, _x39, _x40, _x41, _x42) {
        return _sendTransfer.apply(this, arguments);
      };
    }()
    /**
     * Find out if a transaction is promotable.
     * @param transactionTail The hash of the transaction to be promoted.
     * @returns Promise which resolves to true if the transaction is promotable rejects with an error.
     */

  }, {
    key: "isPromotable",
    value: function () {
      var _isPromotable = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee13(transactionTail) {
        var checkConsistencyRequest, checkConsistencyResponse;
        return _regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this._logger.info("===> TransactionClient::isPromotable", transactionTail);

                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {
                  _context13.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionTail must be an object of type Hash");

              case 3:
                checkConsistencyRequest = {
                  tails: [transactionTail.toTrytes().toString()]
                };
                _context13.next = 6;
                return this._apiClient.checkConsistency(checkConsistencyRequest);

              case 6:
                checkConsistencyResponse = _context13.sent;

                this._logger.info("<=== TransactionClient::isPromotable", checkConsistencyResponse.state);

                return _context13.abrupt("return", checkConsistencyResponse.state);

              case 9:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      return function isPromotable(_x43) {
        return _isPromotable.apply(this, arguments);
      };
    }()
    /**
     * Determines whether you should replay a transaction or make a new one (either with the same input, or a different one).
     * @param addresses Input address you want to have tested.
     * @returns Promise which resolves to true if the addresses are reattachable or rejects with an error.
     */

  }, {
    key: "isReattachable",
    value: function () {
      var _isReattachable = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee14(addresses) {
        var addrsTxsMap, i, addressString, transactions, valueTransactions, results, inclusionStates, _i2;

        return _regenerator.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this._logger.info("===> TransactionClient::isReattachable", addresses);

                if (arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address)) {
                  _context14.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The addresses must be an object of type Address");

              case 3:
                addrsTxsMap = {};

                for (i = 0; i < addresses.length; i++) {
                  addressString = addresses[i].toTrytes().toString();
                  addrsTxsMap[addressString] = [];
                }

                _context14.next = 7;
                return this.findTransactionObjects(undefined, addresses);

              case 7:
                transactions = _context14.sent;
                valueTransactions = [];
                transactions.forEach(function (transaction) {
                  if (transaction.value.toNumber() < 0) {
                    var txAddress = transaction.address;
                    var txHash = transactionHelper_1.TransactionHelper.hash(transaction);
                    addrsTxsMap[txAddress.toTrytes().toString()].push(txHash);
                    valueTransactions.push(txHash);
                  }
                });

                if (!(valueTransactions.length > 0)) {
                  _context14.next = 17;
                  break;
                }

                _context14.next = 13;
                return this.getLatestInclusion(valueTransactions);

              case 13:
                inclusionStates = _context14.sent;
                results = addresses.map(function (address) {
                  var shouldReattach = true;
                  var txs = addrsTxsMap[address.toTrytes().toString()];

                  for (var _i = 0; _i < txs.length; _i++) {
                    var txIndex = valueTransactions.indexOf(txs[_i]);
                    shouldReattach = !inclusionStates[txIndex];

                    if (!shouldReattach) {
                      break;
                    }
                  }

                  return shouldReattach;
                });
                _context14.next = 19;
                break;

              case 17:
                results = [];

                for (_i2 = 0; _i2 < addresses.length; _i2++) {
                  results.push(true);
                }

              case 19:
                this._logger.info("<=== TransactionClient::isReattachable", results);

                return _context14.abrupt("return", results);

              case 21:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      return function isReattachable(_x44) {
        return _isReattachable.apply(this, arguments);
      };
    }()
    /**
     * Promotes a transaction by adding spam on top of it, as long as it is promotable.
     * Will promote by adding transfers on top of the current one with delay interval.
     * Use promoteOptions.interrupt to terminate the promotion.
     * If promoteOptions.delay is set to 0 only one promotion transfer will be sent.
     * @param transactionTail The hash of the transaction to be promoted.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @param transfers The transfers to send.
     * @param promoteOptions Additional options for the promote.
     *      @property delay Delay between promotion transfers
     *      @property interrupt Flag or method to terminate promotion.
     * @returns Promise which resolves to the list of transactions created or rejects with an error.
     */

  }, {
    key: "promoteTransaction",
    value: function () {
      var _promoteTransaction = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee16(transactionTail, depth, minWeightMagnitude, transfers, promoteOptions) {
        var _this = this;

        var localPromoteOptions, isPromotable, sendTransferResponse;
        return _regenerator.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                this._logger.info("===> TransactionClient::promoteTransaction", transactionTail, depth, minWeightMagnitude, transfers, promoteOptions);

                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {
                  _context16.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionTail must be an object of type Hash");

              case 3:
                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {
                  _context16.next = 5;
                  break;
                }

                throw new businessError_1.BusinessError("The depth must be a number > 0", {
                  depth: depth
                });

              case 5:
                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {
                  _context16.next = 7;
                  break;
                }

                throw new businessError_1.BusinessError("The minWeightMagnitude must be a number > 0", {
                  minWeightMagnitude: minWeightMagnitude
                });

              case 7:
                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {
                  _context16.next = 9;
                  break;
                }

                throw new businessError_1.BusinessError("The transfers must an array of Transfer objects");

              case 9:
                localPromoteOptions = promoteOptions || {};

                if (objectHelper_1.ObjectHelper.isEmpty(localPromoteOptions.interrupt)) {
                  localPromoteOptions.interrupt = false;
                }

                if (!(localPromoteOptions.interrupt === false || typeof localPromoteOptions.interrupt === "function" && !localPromoteOptions.interrupt())) {
                  _context16.next = 30;
                  break;
                }

                _context16.next = 14;
                return this.isPromotable(transactionTail);

              case 14:
                isPromotable = _context16.sent;

                if (!isPromotable) {
                  _context16.next = 27;
                  break;
                }

                _context16.next = 18;
                return this.sendTransfer(hash_1.Hash.fromTrytes(transfers[0].address.toTrytes()), depth, minWeightMagnitude, transfers, undefined, transactionTail);

              case 18:
                sendTransferResponse = _context16.sent;

                if (!numberHelper_1.NumberHelper.isInteger(localPromoteOptions.delay)) {
                  _context16.next = 23;
                  break;
                }

                return _context16.abrupt("return", this._backgroundTaskService.create(
                /*#__PURE__*/
                _asyncToGenerator(
                /*#__PURE__*/
                _regenerator.default.mark(function _callee15() {
                  return _regenerator.default.wrap(function _callee15$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          return _context15.abrupt("return", _this.promoteTransaction(transactionTail, depth, minWeightMagnitude, transfers, localPromoteOptions));

                        case 1:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  }, _callee15, this);
                })), localPromoteOptions.delay));

              case 23:
                this._logger.info("<=== TransactionClient::promoteTransaction", sendTransferResponse);

                return _context16.abrupt("return", sendTransferResponse);

              case 25:
                _context16.next = 28;
                break;

              case 27:
                throw new businessError_1.BusinessError("Transaction is not promotable");

              case 28:
                _context16.next = 32;
                break;

              case 30:
                this._logger.info("<=== TransactionClient::promoteTransaction", undefined);

                return _context16.abrupt("return", undefined);

              case 32:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      return function promoteTransaction(_x45, _x46, _x47, _x48, _x49) {
        return _promoteTransaction.apply(this, arguments);
      };
    }()
    /**
     * Gets the associated bundle transactions of a single transaction.
     * Does validation of signatures, total sum as well as bundle order.
     * @param transactionHash Hash of a trunk or a tail transaction of a bundle.
     * @returns Promise which resolves to the bundle transactions or rejects with an error.
     */

  }, {
    key: "getBundle",
    value: function () {
      var _getBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee17(transactionHash) {
        var transactions, bundle, isValid;
        return _regenerator.default.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                this._logger.info("===> TransactionClient::getBundle", transactionHash);

                if (objectHelper_1.ObjectHelper.isType(transactionHash, hash_1.Hash)) {
                  _context17.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The transactionHash must be an object of type Hash");

              case 3:
                _context17.next = 5;
                return this.traverseBundle(transactionHash);

              case 5:
                transactions = _context17.sent;
                bundle = new bundle_1.Bundle();
                bundle.transactions = transactions;
                isValid = bundleHelper_1.BundleHelper.isValid(bundle);

                if (isValid) {
                  _context17.next = 11;
                  break;
                }

                throw new businessError_1.BusinessError("Invalid bundle provided");

              case 11:
                this._logger.info("<=== TransactionClient::getBundle", bundle);

                return _context17.abrupt("return", bundle);

              case 13:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      return function getBundle(_x50) {
        return _getBundle.apply(this, arguments);
      };
    }()
    /**
     * Traverse the Bundle by going down the trunkTransactions until
     * the bundle hash of the transaction is no longer the same.
     * @param trunkTransaction Hash of a trunk or a tail transaction of a bundle.
     * @param bundleHash The bundle hash to match.
     * @returns Promise which resolves to the bundle transactions or rejects with an error.
     */

  }, {
    key: "traverseBundle",
    value: function () {
      var _traverseBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee18(trunkTransaction, bundleHash) {
        var allBundleTransactions, newTrunkTransaction, newBundleHash, getTrytesRequest, getTrytesResponse, trytes, transactionObject, hasHash, localBundleHash;
        return _regenerator.default.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this._logger.info("===> TransactionClient::traverseBundle", trunkTransaction, bundleHash);

                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {
                  _context18.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The trunkTransaction must be an object of type Hash");

              case 3:
                allBundleTransactions = [];
                newTrunkTransaction = trunkTransaction;
                newBundleHash = bundleHash;

              case 6:
                getTrytesRequest = {
                  hashes: [newTrunkTransaction.toTrytes().toString()]
                };
                _context18.next = 9;
                return this._apiClient.getTrytes(getTrytesRequest);

              case 9:
                getTrytesResponse = _context18.sent;
                trytes = !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse) && !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse.trytes) && getTrytesResponse.trytes.length > 0 ? getTrytesResponse.trytes[0] : undefined;

                if (!objectHelper_1.ObjectHelper.isEmpty(trytes)) {
                  _context18.next = 15;
                  break;
                }

                throw new businessError_1.BusinessError("Bundle transactions not visible");

              case 15:
                transactionObject = transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes)); // If first transaction to search is not a tail, return error

                hasHash = !objectHelper_1.ObjectHelper.isEmpty(newBundleHash);

                if (!(!hasHash && transactionObject.currentIndex.toNumber() !== 0)) {
                  _context18.next = 19;
                  break;
                }

                throw new businessError_1.BusinessError("Invalid tail transaction supplied");

              case 19:
                // If no bundle hash, define it
                localBundleHash = hasHash ? newBundleHash : transactionObject.bundle;
                newTrunkTransaction = undefined;
                newBundleHash = undefined; // If same bundle hash continue

                if (localBundleHash.toTrytes().toString() === transactionObject.bundle.toTrytes().toString()) {
                  // Add transaction object to bundle
                  allBundleTransactions.push(transactionObject); // If more than one element then continue

                  if (transactionObject.lastIndex.toNumber() !== 0 || transactionObject.currentIndex.toNumber() !== 0) {
                    newTrunkTransaction = transactionObject.trunkTransaction;
                    newBundleHash = localBundleHash;
                  }
                }

              case 23:
                if (newTrunkTransaction !== undefined) {
                  _context18.next = 6;
                  break;
                }

              case 24:
                this._logger.info("<=== TransactionClient::traverseBundle", allBundleTransactions);

                return _context18.abrupt("return", allBundleTransactions);

              case 26:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      return function traverseBundle(_x51, _x52) {
        return _traverseBundle.apply(this, arguments);
      };
    }()
    /**
     * Wrapper which gets a bundle and then replays a transfer by doing Proof of Work again.
     * @param transactionHash The hash of the transaction to be promoted.
     * @param depth Value that determines how far to go for tip selection.
     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.
     * @returns Promise which resolves to the list of transactions created or rejects with an error.
     */

  }, {
    key: "reattachBundle",
    value: function () {
      var _reattachBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee19(transactionHash, depth, minWeightMagnitude) {
        var bundle, sendTransactionsResponse;
        return _regenerator.default.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                this._logger.info("===> TransactionClient::reattachBundle", transactionHash, depth, minWeightMagnitude);

                _context19.next = 3;
                return this.getBundle(transactionHash);

              case 3:
                bundle = _context19.sent;
                bundle.transactions = bundle.transactions.reverse();
                _context19.next = 7;
                return this.sendTransactions(bundle, depth, minWeightMagnitude);

              case 7:
                sendTransactionsResponse = _context19.sent;

                this._logger.info("<=== TransactionClient::reattachBundle", sendTransactionsResponse);

                return _context19.abrupt("return", sendTransactionsResponse);

              case 10:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      return function reattachBundle(_x53, _x54, _x55) {
        return _reattachBundle.apply(this, arguments);
      };
    }()
    /**
     * Wrapper which gets a bundle and then broadcasts it.
     * @param transactionHash The hash of the transaction to be re-broadcast.
     * @returns Promise which resolves or rejects with an error.
     */

  }, {
    key: "rebroadcastBundle",
    value: function () {
      var _rebroadcastBundle = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee20(transactionHash) {
        var bundle, broadcastTransactionsRequest;
        return _regenerator.default.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                this._logger.info("===> TransactionClient::rebroadcastBundle", transactionHash);

                _context20.next = 3;
                return this.getBundle(transactionHash);

              case 3:
                bundle = _context20.sent;
                broadcastTransactionsRequest = {
                  trytes: bundle.transactions.reverse().map(function (bt) {
                    return bt.toTrytes().toString();
                  })
                };
                _context20.next = 7;
                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);

              case 7:
                this._logger.info("<=== TransactionClient::rebroadcastBundle", bundle);

                return _context20.abrupt("return", bundle);

              case 9:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      return function rebroadcastBundle(_x56) {
        return _rebroadcastBundle.apply(this, arguments);
      };
    }()
    /**
     * Get transaction objects by fist performing a findTransactions call.
     * @param bundles Bundles to lookup transactions for.
     * @param addresses Addresses to lookup transactions for.
     * @param tags Tags to lookup transactions for.
     * @param approvees Approvees to lookup transactions for.
     * @returns Promise which resolves to the list of transactions or rejects with an error.
     */

  }, {
    key: "findTransactionObjects",
    value: function () {
      var _findTransactionObjects = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee21(bundles, addresses, tags, approvees) {
        var transactions, resp;
        return _regenerator.default.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                this._logger.info("===> TransactionClient::findTransactionObjects", bundles, addresses, tags, approvees);

                _context21.next = 3;
                return this.findTransactions(bundles, addresses, tags, approvees);

              case 3:
                transactions = _context21.sent;

                if (!(transactions.length > 0)) {
                  _context21.next = 12;
                  break;
                }

                _context21.next = 7;
                return this.getTransactionsObjects(transactions);

              case 7:
                resp = _context21.sent;

                this._logger.info("<=== TransactionClient::findTransactionObjects", resp);

                return _context21.abrupt("return", resp);

              case 12:
                this._logger.info("<=== TransactionClient::findTransactionObjects", []);

                return _context21.abrupt("return", []);

              case 14:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      return function findTransactionObjects(_x57, _x58, _x59, _x60) {
        return _findTransactionObjects.apply(this, arguments);
      };
    }()
    /**
     * The transfers which are associated with a seed. The transfers are determined by either calculating
     * deterministically which addresses were already used, or by providing a list of indexes to get the
     * addresses and the associated transfers from. The transfers are sorted by their timestamp.
     * @param seed The seed to get the transfers for
     * @param startIndex The start index to get the transfers for.
     * @param endIndex The end index to get the transfers for.
     * @param security The security level for the transfers.
     * @param inclusionStates Do you want inclusion states in the bundles.
     * @returns Promise which resolves to the requested bundles or rejects with an error.
     */

  }, {
    key: "getTransfers",
    value: function () {
      var _getTransfers = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee22(seed, startIndex, endIndex, security, inclusionStates) {
        var localStartIndex, addresses, bundles;
        return _regenerator.default.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this._logger.info("===> TransactionClient::getTransfers", seed, startIndex, endIndex, security, inclusionStates);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context22.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                localStartIndex = startIndex;

                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {
                  localStartIndex = 0;
                }

                _context22.next = 7;
                return this.getNewAddress(seed, localStartIndex, endIndex, false, security);

              case 7:
                addresses = _context22.sent;
                _context22.next = 10;
                return this.bundlesFromAddresses(addresses, inclusionStates);

              case 10:
                bundles = _context22.sent;

                this._logger.info("<=== TransactionClient::getTransfers", bundles);

                return _context22.abrupt("return", bundles);

              case 13:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      return function getTransfers(_x61, _x62, _x63, _x64, _x65) {
        return _getTransfers.apply(this, arguments);
      };
    }()
    /**
     * Similar to getTransfers, just that it returns additional account data.
     * @param seed The seed to get the transfers for
     * @param startIndex The start index to get the transfers for.
     * @param endIndex The end index to get the transfers for.
     * @param security The security level for the transfers.
     * @returns Promise which resolves to the account data or rejects with an error.
     */

  }, {
    key: "getAccountData",
    value: function () {
      var _getAccountData = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee23(seed, startIndex, endIndex, security) {
        var localStartIndex, addresses, bundles, accountData, balanceRequest, balanceResponse, i, balance;
        return _regenerator.default.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this._logger.info("===> TransactionClient::getAccountData", seed, startIndex, endIndex, security);

                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {
                  _context23.next = 3;
                  break;
                }

                throw new businessError_1.BusinessError("The seed must be of type Hash");

              case 3:
                localStartIndex = startIndex;

                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {
                  localStartIndex = 0;
                }

                _context23.next = 7;
                return this.getNewAddress(seed, localStartIndex, endIndex, false, security || addressSecurity_1.AddressSecurity.medium);

              case 7:
                addresses = _context23.sent;
                _context23.next = 10;
                return this.bundlesFromAddresses(addresses, true);

              case 10:
                bundles = _context23.sent;
                accountData = {
                  latestAddress: addresses.pop(),
                  addresses: addresses,
                  transfers: bundles,
                  inputs: [],
                  balance: 0
                };
                balanceRequest = {
                  addresses: accountData.addresses.map(function (add) {
                    return add.toTrytes().toString();
                  }),
                  threshold: 100
                };
                _context23.next = 15;
                return this._apiClient.getBalances(balanceRequest);

              case 15:
                balanceResponse = _context23.sent;

                for (i = 0; i < balanceResponse.balances.length; i++) {
                  balance = parseInt(balanceResponse.balances[i], 10);

                  if (balance > 0) {
                    accountData.inputs.push(input_1.Input.fromParams(accountData.addresses[i], security || addressSecurity_1.AddressSecurity.medium, localStartIndex + i, balance));
                    accountData.balance += balance;
                  }
                }

                this._logger.info("<=== TransactionClient::getAccountData", accountData);

                return _context23.abrupt("return", accountData);

              case 19:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      return function getAccountData(_x66, _x67, _x68, _x69) {
        return _getAccountData.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "bundlesFromAddresses",
    value: function () {
      var _bundlesFromAddresses = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee24(addresses, inclusionStates) {
        var transactionObjects, tailTransactions, nonTailBundleHashes, nonTailBundleTransactions, finalBundles, tailTxArray, tailTxStates, i, bundle;
        return _regenerator.default.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.findTransactionObjects(undefined, addresses, undefined, undefined);

              case 2:
                transactionObjects = _context24.sent;
                // set of tail transactions
                tailTransactions = new Set();
                nonTailBundleHashes = new Set();
                transactionObjects.forEach(function (transaction) {
                  // Sort tail and nonTails
                  if (transaction.currentIndex.toNumber() === 0) {
                    tailTransactions.add(transactionHelper_1.TransactionHelper.hash(transaction).toTrytes().toString());
                  } else {
                    nonTailBundleHashes.add(transaction.bundle.toTrytes().toString());
                  }
                });

                if (!(nonTailBundleHashes.size > 0)) {
                  _context24.next = 11;
                  break;
                }

                _context24.next = 9;
                return this.findTransactionObjects(Array.from(nonTailBundleHashes).map(function (hash) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));
                }));

              case 9:
                nonTailBundleTransactions = _context24.sent;
                nonTailBundleTransactions.forEach(function (transaction) {
                  if (transaction.currentIndex.toNumber() === 0) {
                    tailTransactions.add(transactionHelper_1.TransactionHelper.hash(transaction).toTrytes().toString());
                  }
                });

              case 11:
                finalBundles = [];
                tailTxArray = Array.from(tailTransactions); // If inclusionStates, get the confirmation status
                // of the tail transactions, and thus the bundles

                if (!inclusionStates) {
                  _context24.next = 17;
                  break;
                }

                _context24.next = 16;
                return this.getLatestInclusion(tailTxArray.map(function (tail) {
                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tail));
                }));

              case 16:
                tailTxStates = _context24.sent;

              case 17:
                i = 0;

              case 18:
                if (!(i < tailTxArray.length)) {
                  _context24.next = 27;
                  break;
                }

                _context24.next = 21;
                return this.getBundle(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tailTxArray[i])));

              case 21:
                bundle = _context24.sent;
                bundle.inclusionState = tailTxStates ? tailTxStates[i] : undefined;
                finalBundles.push(bundle);

              case 24:
                i++;
                _context24.next = 18;
                break;

              case 27:
                // Sort bundles by timestamp
                finalBundles.sort(function (a, b) {
                  var x = a.transactions[0].attachmentTimestamp.toNumber();
                  var y = b.transactions[0].attachmentTimestamp.toNumber();
                  return x < y ? -1 : x > y ? 1 : 0;
                });
                return _context24.abrupt("return", finalBundles);

              case 29:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      return function bundlesFromAddresses(_x70, _x71) {
        return _bundlesFromAddresses.apply(this, arguments);
      };
    }()
    /* @internal */

  }, {
    key: "generateAddress",
    value: function generateAddress(seed, index, security, includeChecksum) {
      var key = iss_1.ISS.key(seed, index, security);
      var digests = iss_1.ISS.digests(key);
      var addressTrits = iss_1.ISS.address(digests);
      var addressTrytesString = trits_1.Trits.fromArray(addressTrits).toTrytes().toString();

      if (includeChecksum) {
        addressTrytesString += addressHelper_1.AddressHelper.createChecksum(addressTrits, 9);
      }

      return address_1.Address.fromTrytes(trytes_1.Trytes.fromString(addressTrytesString));
    }
    /* @internal */

  }, {
    key: "addRemainder",
    value: function () {
      var _addRemainder = _asyncToGenerator(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee25(seed, bundle, transferOptions, inputs, signatureMessageFragments, totalValue, tag, addedHMAC) {
        var totalTransferValue, i, timestamp, remainder, startIndex, k, addresses, ts;
        return _regenerator.default.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                totalTransferValue = totalValue;
                i = 0;

              case 2:
                if (!(i < inputs.length)) {
                  _context25.next = 31;
                  break;
                }

                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry

                bundle.addTransactions(inputs[i].security, inputs[i].address, -inputs[i].balance, tag, timestamp); // If there is a remainder value
                // Add extra output to send remaining funds to

                if (!(inputs[i].balance >= totalTransferValue)) {
                  _context25.next = 27;
                  break;
                }

                remainder = inputs[i].balance - totalTransferValue; // If user has provided remainder address use it to send remaining funds to

                if (!(remainder > 0 && !objectHelper_1.ObjectHelper.isEmpty(transferOptions) && objectHelper_1.ObjectHelper.isType(transferOptions.remainderAddress, address_1.Address))) {
                  _context25.next = 12;
                  break;
                }

                // Remainder bundle entry
                bundle.addTransactions(1, transferOptions.remainderAddress, remainder, tag, timestamp); // Final function for signing inputs

                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);
                _context25.next = 25;
                break;

              case 12:
                if (!(remainder > 0)) {
                  _context25.next = 24;
                  break;
                }

                startIndex = 0;

                for (k = 0; k < inputs.length; k++) {
                  startIndex = Math.max(inputs[k].keyIndex, startIndex);
                }

                startIndex++;
                _context25.next = 18;
                return this.getAddressesToUnused(seed, startIndex, false, transferOptions.security);

              case 18:
                addresses = _context25.sent;
                ts = Math.floor(this._timeService.msSinceEpoch() / 1000); // Remainder bundle entry

                bundle.addTransactions(1, addresses[addresses.length - 1], remainder, tag, ts); // Final function for signing inputs

                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);
                _context25.next = 25;
                break;

              case 24:
                // If there is no remainder, do not add transaction to bundle
                // simply sign and return
                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);

              case 25:
                _context25.next = 28;
                break;

              case 27:
                // If multiple inputs provided, subtract the totalTransferValue by
                // the inputs balance
                totalTransferValue -= inputs[i].balance;

              case 28:
                i++;
                _context25.next = 2;
                break;

              case 31:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      return function addRemainder(_x72, _x73, _x74, _x75, _x76, _x77, _x78, _x79) {
        return _addRemainder.apply(this, arguments);
      };
    }()
  }]);

  return TransactionClient;
}();
/* @internal */


TransactionClient.NULL_HASH_TRYTES = "9".repeat(243);
/* @internal */

TransactionClient.MAX_INPUTS = 500;
exports.TransactionClient = TransactionClient;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime-module.js");


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime-module.js":
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ "./node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2Vycm9yL2NvcmVFcnJvci50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9mYWN0b3JpZXMvZmFjdG9yeUJhc2UudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvaGVscGVycy9hcnJheUhlbHBlci50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9oZWxwZXJzL2pzb25IZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvaGVscGVycy9udW1iZXJIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvaGVscGVycy9vYmplY3RIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvaGVscGVycy9zdHJpbmdIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvbG9nZ2Vycy9udWxsTG9nZ2VyLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL3NlcnZpY2VzL2JhY2tncm91bmRUYXNrU2VydmljZS50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9zZXJ2aWNlcy90aW1lU2VydmljZS50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vaW90YS1waWNvLWNvcmUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9kaWdlc3RzL3NoYTMudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvZXJyb3IvY3J5cHRvRXJyb3IudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvaGFzaC9pc3MudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvaGVscGVycy9iaWdJbnRlZ2VySGVscGVyLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2hlbHBlcnMvdHJhbnNhY3Rpb25IZWxwZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvc3Bvbmdlcy9jdXJsLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL3Nwb25nZXMva2VybC50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uL2lvdGEtcGljby1jcnlwdG8vbm9kZV9tb2R1bGVzL2JpZy1pbnRlZ2VyL0JpZ0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvZGF0YS9hZGRyZXNzLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2RhdGEvYWRkcmVzc1NlY3VyaXR5LnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2RhdGEvYnVuZGxlLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2RhdGEvaGFzaC50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9kYXRhL2lucHV0LnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2RhdGEvdGFnLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2RhdGEvdHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvZGF0YS90cmFuc2Zlci50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9kYXRhL3RyaXRzLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2RhdGEvdHJ5dGVOdW1iZXIudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvZGF0YS90cnl0ZXMudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvZXJyb3IvZGF0YUVycm9yLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2Vycm9yL2J1c2luZXNzRXJyb3IudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uLi8uLi9zcmMvaGVscGVycy9hZGRyZXNzSGVscGVyLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL2hlbHBlcnMvYnVuZGxlSGVscGVyLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL211bHRpU2lnL211bHRpU2lnQWRkcmVzcy50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9tdWx0aVNpZy9tdWx0aVNpZ0NsaWVudC50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy9zaWduL2htYWNDdXJsLnRzIiwid2VicGFjazovL0lvdGFQaWNvQnVzaW5lc3MvLi4vLi4vc3JjL3RyYW5zYWN0aW9ucy9wcm9vZk9mV29ya0FwaS50cyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4uLy4uL3NyYy90cmFuc2FjdGlvbnMvdHJhbnNhY3Rpb25DbGllbnQudHMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9Jb3RhUGljb0J1c2luZXNzLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vSW90YVBpY29CdXNpbmVzcy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FB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SSxFQUFHLEtBQUksRUFBSSxNQUFJLEVBQUksTUFBSSxFQUFJLE1BQUksRUFBSztBQUN4QyxhQUFJLEVBQUcsS0FBSSxFQUFJLE1BQUksRUFBSSxNQUFJLEVBQUksTUFBSSxFQUFLO0FBQ3hDLGFBQUksRUFBRyxLQUFJLEVBQUksTUFBSSxFQUFJLE1BQUksRUFBSSxNQUFJLEVBQUs7QUFDeEMsYUFBSSxFQUFHLEtBQUksRUFBSSxNQUFJLEVBQUksTUFBSSxFQUFJLE1BQUksRUFBSztBQUN4QyxhQUFJLEVBQUcsS0FBSSxFQUFJLE1BQUksRUFBSSxNQUFJLEVBQUksTUFBSSxFQUFLO0FBQ3hDLGFBQUksRUFBRyxLQUFJLEVBQUksTUFBSSxFQUFJLE1BQUksRUFBSSxNQUFJLEVBQUs7QUFDeEMsYUFBSSxFQUFHLEtBQUksRUFBSSxNQUFJLEVBQUksTUFBSSxFQUFJLE1BQUksRUFBSztBQUN4QyxhQUFJLEVBQUcsS0FBSSxFQUFJLE1BQUksRUFBSSxNQUFJLEVBQUksTUFBSSxFQUFLO0FBQ3hDLGFBQUksRUFBRyxLQUFJLEVBQUksTUFBSSxFQUFJLE1BQUksRUFBSSxNQUFJLEVBQUs7QUFFekMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsWUFBUSxNQUFJLE1BQVMsQ0FBWixHQUFlLE9BQVU7QUFDbEMsVUFBRyxNQUFNO0FBQ1QsVUFBRyxNQUFNO0FBQ1QsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBQ1YsVUFBSSxPQUFNO0FBRVQsYUFBSSxFQUFJO0FBQ1IsYUFBSSxFQUFJO0FBQ1AsY0FBSyxFQUFJLE9BQVMsQ0FBZixHQUFpQixFQUFJLFFBQVM7QUFDakMsY0FBSyxFQUFJLE9BQVMsQ0FBZixHQUFpQixFQUFJLFFBQVM7QUFDakMsY0FBSyxFQUFJLE9BQVMsQ0FBZixHQUFpQixFQUFJLFFBQVM7QUFDakMsY0FBSyxFQUFJLE9BQVMsQ0FBZixHQUFpQixFQUFJLFFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7Ozs7Ozs7Ozs7OztBQ3R0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImlvdGEtcGljby1idXNpbmVzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiQGlvdGEtcGljby9idXNpbmVzc1wiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJAaW90YS1waWNvL2J1c2luZXNzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIklvdGFQaWNvQnVzaW5lc3NcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZGlzdC9pbmRleC5qc1wiKTtcbiIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QganNvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvanNvbkhlbHBlclwiKTtcclxuY29uc3Qgc3RyaW5nSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdHJpbmdIZWxwZXJcIik7XHJcbi8qKlxyXG4gKiBBIGNvcmUgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBDb3JlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBDb3JlRXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSBmb3IgdGhlIGVycm9yLlxyXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWwgQWRkaXRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBpbm5lckVycm9yIEFkZCBpbmZvcm1hdGlvbiBmcm9tIGlubmVyIGVycm9yIGlmIHRoZXJlIHdhcyBvbmUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGFkZGl0aW9uYWwsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmFkZGl0aW9uYWwgPSBhZGRpdGlvbmFsID8gYWRkaXRpb25hbCA6IHt9O1xyXG4gICAgICAgIHRoaXMuaW5uZXJFcnJvciA9IGlubmVyRXJyb3I7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcIkNvcmVcIjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGNvdWxkIGJlIGEgQ29yZUVycm9yLlxyXG4gICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrIGlmIGl0IGlzIGEgQ29yZUVycm9yLlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBJZiB0aGUgdGVzdGVkIG9iamVjdCBpcyBhIENvcmVFcnJvci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRXJyb3Iob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIFwibWVzc2FnZVwiIGluIG9iaiAmJiBcImFkZGl0aW9uYWxcIiBpbiBvYmo7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdCB0aGUgZXJyb3IgdG8gYSByZWFkYWJsZSB2ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICBmb3JtYXQoKSB7XHJcbiAgICAgICAgbGV0IG91dCA9IFwiXCI7XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eSh0aGlzLmRvbWFpbikpIHtcclxuICAgICAgICAgICAgb3V0ICs9IGAke3RoaXMuZG9tYWlufTogYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eSh0aGlzLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIG91dCArPSBgJHt0aGlzLm1lc3NhZ2V9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuYWRkaXRpb25hbCk7XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG91dCArPSBcIlxcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3V0ICs9IGBcXHQke2tleX06ICR7anNvbkhlbHBlcl8xLkpzb25IZWxwZXIuc3RyaW5naWZ5KHRoaXMuYWRkaXRpb25hbFtrZXldKX1cXG5gO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvcmVFcnJvciA9IENvcmVFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTI5eVpVVnljbTl5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlZ5Y205eUwyTnZjbVZGY25KdmNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc2MwUkJRVzFFTzBGQlEyNUVMREJFUVVGMVJEdEJRVVYyUkRzN1IwRkZSenRCUVVOSUxHVkJRWFZDTEZOQlFWRXNTMEZCU3p0SlFXZENhRU03T3pzN08wOUJTMGM3U1VGRFNDeFpRVUZaTEU5QlFXVXNSVUZCUlN4VlFVRnJReXhGUVVGRkxGVkJRV3RDTzFGQlF5OUZMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU5tTEVsQlFVa3NRMEZCUXl4VlFVRlZMRWRCUVVjc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJRenRSUVVNdlF5eEpRVUZKTEVOQlFVTXNWVUZCVlN4SFFVRkhMRlZCUVZVc1EwRkJRenRSUVVNM1FpeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJRenRKUVVONlFpeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJVVHRSUVVNeFFpeFBRVUZQTEVkQlFVY3NTMEZCU3l4VFFVRlRMRWxCUVVrc1IwRkJSeXhMUVVGTExFbEJRVWtzU1VGQlNTeFBRVUZQTEVkQlFVY3NTMEZCU3l4UlFVRlJMRWxCUVVrc1UwRkJVeXhKUVVGSkxFZEJRVWNzU1VGQlNTeFpRVUZaTEVsQlFVa3NSMEZCUnl4RFFVRkRPMGxCUTI1SUxFTkJRVU03U1VGRlJEczdUMEZGUnp0SlFVTkpMRTFCUVUwN1VVRkRWQ3hKUVVGSkxFZEJRVWNzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZGWWl4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhGUVVGRk8xbEJRM0JETEVkQlFVY3NTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFbEJRVWtzUTBGQlF6dFRRVU0zUWp0UlFVTkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVU3V1VGRGNrTXNSMEZCUnl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzFOQlF6VkNPMUZCUlVRc1RVRkJUU3hKUVVGSkxFZEJRVWNzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRE1VTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUlVGQlJUdFpRVU5xUWl4SlFVRkpMRWRCUVVjc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzJkQ1FVTm9RaXhIUVVGSExFbEJRVWtzU1VGQlNTeERRVUZETzJGQlEyWTdXVUZEUkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTzJkQ1FVTm1MRWRCUVVjc1NVRkJTU3hMUVVGTExFZEJRVWNzUzBGQlN5eDFRa0ZCVlN4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJRenRaUVVOMlJTeERRVUZETEVOQlFVTXNRMEZCUXp0VFFVTk9PMUZCUlVRc1QwRkJUeXhIUVVGSExFTkJRVU03U1VGRFppeERRVUZETzBOQlEwbzdRVUV2UkVRc09FSkJLMFJESW4wPSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEZhY3RvcnkgdG8gZ2VuZXJhdGUgdHlwZXMuXHJcbiAqIEB0eXBlcGFyYW0gVCBUaGUgZ2VuZXJpYyB0eXBlIGZvciB0aGUgb2JqZWN0IHR5cGVzIGluIHRoZSBmYWN0b3J5LlxyXG4gKi9cclxuY2xhc3MgRmFjdG9yeUJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy5fdHlwZXMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgYSBuZXcgdHlwZSB3aXRoIHRoZSBmYWN0b3J5LlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHR5cGUgdG8gcmVnaXN0ZXIuXHJcbiAgICAgKiBAcGFyYW0gdHlwZUNvbnN0cnVjdG9yIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyKG5hbWUsIHR5cGVDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5fdHlwZXNbbmFtZV0gPSB0eXBlQ29uc3RydWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVucmVnaXN0ZXIgYSB0eXBlIGZyb20gdGhlIGZhY3RvcnkuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSB0byB1bnJlZ2lzdGVyLlxyXG4gICAgICovXHJcbiAgICB1bnJlZ2lzdGVyKG5hbWUpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5nZXRJbnN0YW5jZSgpLl90eXBlc1tuYW1lXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRG9lcyB0aGUgZmFjdG9yeSBjb250YWluIGEgc3BlY2lmaWMgdHlwZS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIGxvb2sgZm9yLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHlwZSBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIGV4aXN0cyhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoKS5fdHlwZXNbbmFtZV0gIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTGlzdCB0aGUgdHlwZXMgaW4gdGhlIGZhY3RvcnkuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSB0byBsb29rIGZvci5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHR5cGUgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICB0eXBlcygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXRJbnN0YW5jZSgpLl90eXBlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZmFjdG9yeS5cclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIGNyZWF0ZS5cclxuICAgICAqIEBwYXJhbSBhcmdzIEFueSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHR5cGUgaWYgaXQgZXhpc3RzLCBvciB1bmRlZmluZWQgaWYgaXQgZG9lcyBub3QuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZShuYW1lLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLl90eXBlc1tuYW1lXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuX3R5cGVzW25hbWVdKC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GYWN0b3J5QmFzZSA9IEZhY3RvcnlCYXNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labUZqZEc5eWVVSmhjMlV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZabUZqZEc5eWFXVnpMMlpoWTNSdmNubENZWE5sTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3TzBkQlIwYzdRVUZEU0R0SlFVRkJPMUZCUTBrc1pVRkJaVHRSUVVORkxGZEJRVTBzUjBGQk9FTXNSVUZCUlN4RFFVRkRPMGxCYzBRMVJTeERRVUZETzBsQmNFUkhPenM3TzA5QlNVYzdTVUZEU1N4UlFVRlJMRU5CUVVNc1NVRkJXU3hGUVVGRkxHVkJRWE5ETzFGQlEyaEZMRWxCUVVrc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1pVRkJaU3hEUVVGRE8wbEJRM1JFTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFZRVUZWTEVOQlFVTXNTVUZCV1R0UlFVTXhRaXhQUVVGUExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRE0wTXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1NVRkJXVHRSUVVOMFFpeFBRVUZQTEVsQlFVa3NRMEZCUXl4WFFVRlhMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NVMEZCVXl4RFFVRkRPMGxCUTNwRUxFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzUzBGQlN6dFJRVU5TTEU5QlFVOHNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRiRVFzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRWxCUVZrc1JVRkJSU3hIUVVGSExFbEJRVmM3VVVGRGRFTXNUVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETzFGQlEzQkRMRWxCUVVrc1VVRkJVU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlR0WlFVTjJRaXhQUVVGUExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zUTBGQlF6dFRRVU42UXp0aFFVRk5PMWxCUTBnc1QwRkJUeXhUUVVGVExFTkJRVU03VTBGRGNFSTdTVUZEVEN4RFFVRkRPME5CU1VvN1FVRjRSRVFzYTBOQmQwUkRJbjA9IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL29iamVjdEhlbHBlclwiKTtcclxuLyoqXHJcbiAqIEFycmF5IGhlbHBlciBtZXRob2RzLlxyXG4gKi9cclxuY2xhc3MgQXJyYXlIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYW4gYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQXJyYXkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGZhbHNlIDogQXJyYXkuaXNBcnJheSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIGVtcHR5IGFycmF5LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0LlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBlbXB0eSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW1wdHkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gIUFycmF5SGVscGVyLmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGEgbm9uIGVtcHR5IGFycmF5IG9mIHNwZWNpZmljIHR5cGUuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbiBlbXB0eSBhcnJheSBvZiBhIHNwZWNpZmljIHR5cGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1R5cGVkKHZhbHVlLCB0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuICFBcnJheUhlbHBlci5pc0VtcHR5KHZhbHVlKSAmJlxyXG4gICAgICAgICAgICAhdmFsdWUuaW5jbHVkZXModW5kZWZpbmVkKSAmJlxyXG4gICAgICAgICAgICAhdmFsdWUuaW5jbHVkZXMobnVsbCkgJiZcclxuICAgICAgICAgICAgdmFsdWUuZXZlcnkoKGEpID0+IG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYSwgdHlwZSkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQXJyYXlIZWxwZXIgPSBBcnJheUhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVhKeVlYbElaV3h3WlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YUdWc2NHVnljeTloY25KaGVVaGxiSEJsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzYVVSQlFUaERPMEZCUlRsRE96dEhRVVZITzBGQlEwZzdTVUZEU1RzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGVk8xRkJRelZDTEU5QlFVOHNTMEZCU3l4TFFVRkxMRWxCUVVrc1NVRkJTU3hMUVVGTExFdEJRVXNzVTBGQlV6dFpRVU40UXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRM1pETEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGVk8xRkJRelZDTEU5QlFVOHNRMEZCUXl4WFFVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRemRFTEVOQlFVTTdTVUZGUkRzN096czdUMEZMUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlZTeEZRVUZGTEVsQlFXTTdVVUZETlVNc1QwRkJUeXhEUVVGRExGZEJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRPMWxCUXpsQ0xFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4VFFVRlRMRU5CUVVNN1dVRkRNVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJRenRaUVVOeVFpeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJUU3hGUVVGRkxFVkJRVVVzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTTVSQ3hEUVVGRE8wTkJSVW83UVVGcVEwUXNhME5CYVVOREluMD0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBKc29uIGhlbHBlciBtZXRob2RzLlxyXG4gKi9cclxuY2xhc3MgSnNvbkhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIFN0cmluZ2lmeSBhbiBvYmplY3Qgd2l0aCByZWN1cnNpb24gYnJlYWtpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBKYXZhU2NyaXB0IHZhbHVlLCB1c3VhbGx5IGFuIG9iamVjdCBvciBhcnJheSwgdG8gYmUgY29udmVydGVkLlxyXG4gICAgICogQHBhcmFtIHJlcGxhY2VyIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHRzLlxyXG4gICAgICogQHBhcmFtIHNwYWNlIEFkZHMgaW5kZW50YXRpb24sIHdoaXRlIHNwYWNlLCBhbmQgbGluZSBicmVhayBjaGFyYWN0ZXJzIHRvIHRoZSByZXR1cm4tdmFsdWUgSlNPTiB0ZXh0IHRvIG1ha2UgaXQgZWFzaWVyIHRvIHJlYWQuXHJcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgdmVyc2lvbiBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcclxuICAgICAgICAvLyBlbGltaW5hdGVzIGFueSByZWN1cnNpb24gaW4gdGhlIHN0cmluZ2lmeVxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gW107XHJcbiAgICAgICAgY29uc3QgcmVjdXNpb25SZXBsYWNlciA9IChrZXksIHJlcGxhY2VWYWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiByZXBsYWNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlLmluZGV4T2YocmVwbGFjZVZhbHVlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaXJjdWxhciByZWZlcmVuY2UgZm91bmQsIGRpc2NhcmQga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUucHVzaChyZXBsYWNlVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlciA/IHJlcGxhY2VyKGtleSwgcmVwbGFjZVZhbHVlKSA6IHJlcGxhY2VWYWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVjdXNpb25SZXBsYWNlciwgc3BhY2UpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuSnNvbkhlbHBlciA9IEpzb25IZWxwZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFuTnZia2hsYkhCbGNpNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5b1pXeHdaWEp6TDJwemIyNUlaV3h3WlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCT3p0SFFVVkhPMEZCUTBnN1NVRkRTVHM3T3pzN08wOUJUVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRXRCUVZVc1JVRkJSU3hSUVVFeVF5eEZRVUZGTEV0QlFYVkNPMUZCUTNCSExEUkRRVUUwUXp0UlFVTTFReXhOUVVGTkxFdEJRVXNzUjBGQlZTeEZRVUZGTEVOQlFVTTdVVUZGZUVJc1RVRkJUU3huUWtGQlowSXNSMEZCUnl4RFFVRkRMRWRCUVZjc1JVRkJSU3haUVVGcFFpeEZRVUZGTEVWQlFVVTdXVUZEZUVRc1NVRkJTU3hQUVVGUExGbEJRVmtzUzBGQlN5eFJRVUZSTEVsQlFVa3NTMEZCU3l4TFFVRkxMRWxCUVVrc1NVRkJTU3haUVVGWkxFdEJRVXNzVTBGQlV5eEZRVUZGTzJkQ1FVTnNSaXhKUVVGSkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFVkJRVVU3YjBKQlEzQkRMSGREUVVGM1F6dHZRa0ZEZUVNc1QwRkJUenRwUWtGRFZqdHhRa0ZCVFR0dlFrRkRTQ3hMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRPMmxDUVVNMVFqdGhRVU5LTzFsQlJVUXNUMEZCVHl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGbEJRVmtzUTBGQlF6dFJRVU5xUlN4RFFVRkRMRU5CUVVNN1VVRkZSaXhQUVVGUExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCU3l4RlFVRkZMR2RDUVVGblFpeEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUXpGRUxFTkJRVU03UTBGRFNqdEJRVE5DUkN4blEwRXlRa01pZlE9PSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIE51bWJlciBoZWxwZXIgbWV0aG9kcy5cclxuICovXHJcbmNsYXNzIE51bWJlckhlbHBlciB7XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhbiBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0IGZvciBpdHMgaW50ZWdlcm5lc3MuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBpbnRlZ2VyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIG51bWJlci5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdCBmb3IgaXRzIG51bWJlcnluZXNzLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNOdW1iZXIodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGEgZmxvYXQgbnVtYmVyIGZvcm1hdHRlZCBhcyBhIHN0cmluZywgY2FuIGJlIHVzZWQgZm9yIGJpZyBudW1iZXJzIHRoYXQgd291bGQgb3ZlcmZsb3cgcGFyc2VGbG9hdC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG51bWJlciBpcyBmb3JtYXR0ZWQgY29ycmVjdGx5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNGbG9hdFN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAvXi0/XFxkKlxcLj9cXGQrJC8udGVzdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIGludGVnZXIgbnVtYmVyIGZvcm1hdHRlZCBhcyBhIHN0cmluZywgY2FuIGJlIHVzZWQgZm9yIGJpZyBudW1iZXJzIHRoYXQgd291bGQgb3ZlcmZsb3cgcGFyc2VJbnQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBudW1iZXIgaXMgZm9ybWF0dGVkIGNvcnJlY3RseS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzSW50ZWdlclN0cmluZyh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAvXi0/XFxkKyQvLnRlc3QodmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTnVtYmVySGVscGVyID0gTnVtYmVySGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liblZ0WW1WeVNHVnNjR1Z5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMmhsYkhCbGNuTXZiblZ0WW1WeVNHVnNjR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3UjBGRlJ6dEJRVU5JTzBsQlEwazdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJWVHRSUVVNNVFpeFBRVUZQTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRja1lzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVZVN1VVRkROMElzVDBGQlR5eExRVUZMTEV0QlFVc3NVMEZCVXl4SlFVRkpMRXRCUVVzc1MwRkJTeXhKUVVGSkxFbEJRVWtzVDBGQlR5eExRVUZMTEV0QlFVc3NVVUZCVVN4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzBsQlEyaEpMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlF5eExRVUZoTzFGQlEzSkRMRTlCUVU4c1pVRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0SlFVTjJReXhEUVVGRE8wbEJSVVE3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eGxRVUZsTEVOQlFVTXNTMEZCWVR0UlFVTjJReXhQUVVGUExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRha01zUTBGQlF6dERRVU5LTzBGQmNFTkVMRzlEUVc5RFF5SjkiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBPYmplY3QgaGVscGVyIG1ldGhvZHMuXHJcbiAqL1xyXG5jbGFzcyBPYmplY3RIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgZW1wdHkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW1wdHkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBmYWxzZSA6IHR5cGVvZiAodmFsdWUpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIG9iamVjdCBpZiBnaXZlbiB0eXBlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0LlxyXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG9iamVjdFxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVHlwZSh2YWx1ZSwgdHlwZUNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVDbGFzc05hbWUgPSBPYmplY3RIZWxwZXIuZ2V0Q2xhc3NOYW1lKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWVDbGFzc05hbWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZUNsYXNzTmFtZSA9PT0gT2JqZWN0SGVscGVyLmdldENsYXNzTmFtZSh0eXBlQ29uc3RydWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNsYXNzIG5hbWUgb2YgYW4gb2JqZWN0IGlmIGl0IGhhcyBvbmUuXHJcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZ2V0IHRoZSBjbGFzcyBuYW1lIGZvci5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFzcyBuYW1lIGlmIGl0IGhhcyBvbmUgb3IgdW5kZWZpbmVkIGlmIG5vdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldENsYXNzTmFtZShvYmplY3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIiA/IG9iamVjdC50b1N0cmluZygpIDogb2JqZWN0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25zdHJ1Y3Rvci5tYXRjaCgvXFx3Ky9nKTtcclxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLk9iamVjdEhlbHBlciA9IE9iamVjdEhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYjJKcVpXTjBTR1ZzY0dWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJobGJIQmxjbk12YjJKcVpXTjBTR1ZzY0dWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVRzN1IwRkZSenRCUVVOSU8wbEJRMGs3T3pzN1QwRkpSenRKUVVOSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCVlR0UlFVTTFRaXhQUVVGUExFdEJRVXNzUzBGQlN5eEpRVUZKTEVsQlFVa3NTMEZCU3l4TFFVRkxMRk5CUVZNc1EwRkJRenRKUVVOcVJDeERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJWVHRSUVVNM1FpeFBRVUZQTEV0QlFVc3NTMEZCU3l4SlFVRkpMRWxCUVVrc1MwRkJTeXhMUVVGTExGTkJRVk03V1VGRGVFTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRkZCUVZFc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRkRVVzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGVkxFVkJRVVVzWlVGQmVVSTdVVUZEZEVRc1RVRkJUU3hqUVVGakxFZEJRVWNzV1VGQldTeERRVUZETEZsQlFWa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVONFJDeFBRVUZQTEdOQlFXTXNTMEZCU3l4VFFVRlRMRWxCUVVrc1kwRkJZeXhMUVVGTExGbEJRVmtzUTBGQlF5eFpRVUZaTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNN1NVRkRla2NzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVZjN1VVRkRiRU1zU1VGQlNTeE5RVUZOTEV0QlFVc3NTVUZCU1N4SlFVRkpMRTFCUVUwc1MwRkJTeXhUUVVGVExFVkJRVVU3V1VGRGVrTXNUMEZCVHl4VFFVRlRMRU5CUVVNN1UwRkRjRUk3WVVGQlRUdFpRVU5JTEUxQlFVMHNWMEZCVnl4SFFVRkhMRTlCUVU4c1RVRkJUU3hMUVVGTExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xbEJRM0pITEUxQlFVMHNUMEZCVHl4SFFVRkhMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdXVUZETVVNc1QwRkJUeXhEUVVGRExFOUJRVThzU1VGQlNTeFBRVUZQTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF6dFRRVU51UlR0SlFVTk1MRU5CUVVNN1EwRkRTanRCUVRkRFJDeHZRMEUyUTBNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBTdHJpbmcgaGVscGVyIG1ldGhvZHMuXHJcbiAqL1xyXG5jbGFzcyBTdHJpbmdIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QgZm9yIGl0cyBzdHJpbmd5bmVzcy5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBmYWxzZSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBTdHJpbmddXCI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSB2YWx1ZSBhIHN0cmluZyB0aGF0IGlzIGVtcHR5LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0IGZvciBpdHMgbm8gZW1wdHluZXNzLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW1wdHkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gIVN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB0aGUgc3RyaW5nIGFsbCBBU0NJSSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZyB0byB0ZXN0IGlmIGlzIGlzIEFTQ0lJLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFsbCBBU0NJSS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQXNjaWkodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IGZhbHNlIDogL15bXFx4MDAtXFx4RkZdKiQvLnRlc3QodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGUgbm9uIEFTQ0lJIGNoYXJhY3RlcnMgd2l0aCBjb250cm9sIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyB2YWx1ZSB0byBlc2NhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZXNjYXBlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlbmNvZGVOb25BU0NJSSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZSgvW1xcdTAwN0YtXFx1RkZGRl0vZywgKGNocikgPT4gYFxcXFx1JHsoYDAwMDAke2Noci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX1gKS5zdWJzdHIoLTQpfWApIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGUgY29udHJvbCBjaGFyYWN0ZXJzIHRvIEFTQ0lJLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBlbmNvZGVkIHN0cmluZyB0byBjb252ZXJ0IGJhY2sgdG8gQVNDSUkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvZGVOb25BU0NJSSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZSgvXFxcXHUoW1xcZFxcd117NH0pL2dpLCAobWF0Y2gsIGdycCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChncnAsIDE2KSkpIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3RyaW5nSGVscGVyID0gU3RyaW5nSGVscGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM1J5YVc1blNHVnNjR1Z5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMmhsYkhCbGNuTXZjM1J5YVc1blNHVnNjR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3UjBGRlJ6dEJRVU5JTzBsQlEwazdPenM3VDBGSlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJWVHRSUVVNM1FpeFBRVUZQTEV0QlFVc3NTMEZCU3l4SlFVRkpMRWxCUVVrc1MwRkJTeXhMUVVGTExGTkJRVk03V1VGRGVFTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEdsQ1FVRnBRaXhEUVVGRE8wbEJRemxGTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGVk8xRkJRelZDTEU5QlFVOHNRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJReTlFTEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGaE8xRkJReTlDTEU5QlFVOHNTMEZCU3l4TFFVRkxMRWxCUVVrc1NVRkJTU3hMUVVGTExFdEJRVXNzVTBGQlV6dFpRVU40UXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZETDBNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETEV0QlFXRTdVVUZEZEVNc1QwRkJUeXhaUVVGWkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEd0Q1FVRnJRaXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhIUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4VFFVRlRMRU5CUVVNN1NVRkRMMG9zUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRXRCUVdFN1VVRkRkRU1zVDBGQlR5eFpRVUZaTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMR3RDUVVGclFpeEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRMmhLTEVOQlFVTTdRMEZEU2p0QlFTOURSQ3h2UTBFclEwTWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgSUxvZ2dlciB3aGljaCBpcyBzaWxlbnQuXHJcbiAqL1xyXG5jbGFzcyBOdWxsTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBiYW5uZXIgdG8gdGhlIGxvZ2dlci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cclxuICAgICAqIEBwYXJhbSBhcmdzIEFkZGl0aW9uYWwgcGFyYW1ldGVycyB0byBsb2cuXHJcbiAgICAgKi9cclxuICAgIGJhbm5lcihtZXNzYWdlLCAuLi5hcmdzKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgbG9nIHRvIHRoZSBsb2dnZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBsb2cobWVzc2FnZSwgLi4uYXJncykge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGluZm9ybWF0aW9uIHRvIHRoZSBsb2dnZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICBpbmZvKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCB3YXJuaW5nIHRvIHRoZSBsb2dnZXIuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxyXG4gICAgICovXHJcbiAgICB3YXJuaW5nKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBlcnJvciB0byB0aGUgbG9nZ2VyLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxyXG4gICAgICogQHBhcmFtIGVyciBBbiBlcnJvciBvYmplY3QgdG8gbG9nLlxyXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cclxuICAgICAqL1xyXG4gICAgZXJyb3IobWVzc2FnZSwgZXJyLCAuLi5hcmdzKSB7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5OdWxsTG9nZ2VyID0gTnVsbExvZ2dlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYm5Wc2JFeHZaMmRsY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlzYjJkblpYSnpMMjUxYkd4TWIyZG5aWEl1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVVkJPenRIUVVWSE8wRkJRMGc3U1VGRFNUczdPenRQUVVsSE8wbEJRMGtzVFVGQlRTeERRVUZETEU5QlFXVXNSVUZCUlN4SFFVRkhMRWxCUVZjN1NVRkROME1zUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeEhRVUZITEVOQlFVTXNUMEZCWlN4RlFVRkZMRWRCUVVjc1NVRkJWenRKUVVNeFF5eERRVUZETzBsQlJVUTdPenM3VDBGSlJ6dEpRVU5KTEVsQlFVa3NRMEZCUXl4UFFVRmxMRVZCUVVVc1IwRkJSeXhKUVVGWE8wbEJRek5ETEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NUMEZCVHl4RFFVRkRMRTlCUVdVc1JVRkJSU3hIUVVGSExFbEJRVmM3U1VGRE9VTXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1MwRkJTeXhEUVVGRExFOUJRV1VzUlVGQlJTeEhRVUZUTEVWQlFVVXNSMEZCUnl4SlFVRlhPMGxCUTNaRUxFTkJRVU03UTBGRFNqdEJRWHBEUkN4blEwRjVRME1pZlE9PSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYmFja2dyb3VuZCB0YXNrIHNlcnZpY2UuXHJcbiAqL1xyXG5jbGFzcyBCYWNrZ3JvdW5kVGFza1NlcnZpY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBiYWNrZ3JvdW5kIHRhc2suXHJcbiAgICAgKiBAcGFyYW0gdGFzayBUaGUgdGFzayB0byBydW4gaW4gdGhlIGJhY2tncm91bmQuXHJcbiAgICAgKiBAcGFyYW0gZGVsYXkgVGhlIGRlbGF5IGJlZm9yZSBydW5uaW5nIHRoZSB0YXNrLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBjcmVhdGUodGFzaywgZGVsYXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0YXNrKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYWNrZ3JvdW5kVGFza1NlcnZpY2UgPSBCYWNrZ3JvdW5kVGFza1NlcnZpY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVltRmphMmR5YjNWdVpGUmhjMnRUWlhKMmFXTmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwzTmxjblpwWTJWekwySmhZMnRuY205MWJtUlVZWE5yVTJWeWRtbGpaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlJVRTdPMGRCUlVjN1FVRkRTRHRKUVVOSk96czdPMDlCU1VjN1NVRkRTU3hMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZKTEVsQlFYTkNMRVZCUVVVc1MwRkJZVHRSUVVONFJDeFBRVUZQTEVsQlFVa3NUMEZCVHl4RFFVRkpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFMUJRVTBzUlVGQlJTeEZRVUZGTzFsQlEzUkRMRlZCUVZVc1EwRkJReXhIUVVGSExFVkJRVVU3WjBKQlEwRXNTVUZCU1R0dlFrRkRRU3hQUVVGUExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXp0cFFrRkRia0k3WjBKQlFVTXNUMEZCVHl4SFFVRkhMRVZCUVVVN2IwSkJRMVlzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMmxDUVVObU8xbEJRMHdzUTBGQlF5eEZRVU5HTEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUTNSQ0xFTkJRVU1zUTBGQlF5eERRVUZETzBsQlExQXNRMEZCUXp0RFFVTktPMEZCYkVKRUxITkVRV3RDUXlKOSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjbGFzcyB3aGljaCBjYW4gcHJvdmlkZSB0aGUgdGltZS5cclxuICovXHJcbmNsYXNzIFRpbWVTZXJ2aWNlIHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwLzAxLzAxLlxyXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cclxuICAgICAqL1xyXG4gICAgbXNTaW5jZUVwb2NoKCkge1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuVGltZVNlcnZpY2UgPSBUaW1lU2VydmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEdsdFpWTmxjblpwWTJVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YzJWeWRtbGpaWE12ZEdsdFpWTmxjblpwWTJVdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVVZCT3p0SFFVVkhPMEZCUTBnN1NVRkRTVHM3TzA5QlIwYzdTVUZEU1N4WlFVRlpPMUZCUTJZc1QwRkJUeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTTdTVUZEZEVJc1EwRkJRenREUVVOS08wRkJVa1FzYTBOQlVVTWlmUT09IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcbnZhciBnID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcblxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXCJyZWdlbmVyYXRvclJ1bnRpbWVcIikgPj0gMDtcblxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuXG5pZiAoaGFkUnVudGltZSkge1xuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XG59IGVsc2Uge1xuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxuICB0cnkge1xuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG4vKipcclxuICogU2hhMyBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmNsYXNzIFNoYTMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgU0hBMy5cclxuICAgICAqIEBwYXJhbSBiaXRzIFRoZSBudW1iZXIgb2YgaW5wdXQgYml0cy5cclxuICAgICAqIEBwYXJhbSBwYWRkaW5nIFRoZSBwYWRkaW5nIHRvIHVzZS5cclxuICAgICAqIEBwYXJhbSBvdXRwdXRCaXRzIFRoZSBudW1iZXIgb2Ygb3V0cHV0IGJpdHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcclxuICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcclxuICAgICAgICB0aGlzLl9vdXRwdXRCaXRzID0gb3V0cHV0Qml0cztcclxuICAgICAgICB0aGlzLl9ibG9ja0NvdW50ID0gKDE2MDAgLSAoYml0cyA8PCAxKSkgPj4gNTtcclxuICAgICAgICB0aGlzLl9ieXRlQ291bnQgPSB0aGlzLl9ibG9ja0NvdW50IDw8IDI7XHJcbiAgICAgICAgdGhpcy5fb3V0cHV0QmxvY2tzID0gb3V0cHV0Qml0cyA+PiA1O1xyXG4gICAgICAgIHRoaXMuX2V4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGRpZ2VzdC5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzZXQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2Jsb2NrID0gMDtcclxuICAgICAgICB0aGlzLl9zdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5fYmxvY2tzID0gbmV3IFVpbnQzMkFycmF5KHRoaXMuX2Jsb2NrQ291bnQgKyAxKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBVaW50MzJBcnJheSg1MCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZGlnZXN0LlxyXG4gICAgICogQHBhcmFtIGlucHV0IEFycmF5IG9mIGRhdGEgdG8gdXNlIGluIHRoZSB1cGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShpbnB1dCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShpbnB1dCwgQXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiSW5wdXQgaXMgbm90IG9mIHR5cGUgQXJyYXlCdWZmZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tzWzBdID0gdGhpcy5fYmxvY2s7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5fYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2Nrc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gdGhpcy5fc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCB0aGlzLl9ieXRlQ291bnQ7ICsraW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNoYTMuU0hJRlRbaSsrICYgM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGFzdEJ5dGVJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGlmIChpID49IHRoaXMuX2J5dGVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBpIC0gdGhpcy5fYnl0ZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2sgPSB0aGlzLl9ibG9ja3NbdGhpcy5fYmxvY2tDb3VudF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVbaV0gXj0gdGhpcy5fYmxvY2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWtQZXJtdXRhdGlvbih0aGlzLl9zdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsaXplIGFuZCByZXR1cm4gdGhlIGhhc2ggZm9yIHRoZSBkaWdlc3QsIHdpbGwgYWxzbyByZXNldCB0aGUgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJucyBBcnJheSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0LlxyXG4gICAgICovXHJcbiAgICBkaWdlc3QoKSB7XHJcbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBsZXQgaiA9IDA7XHJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLl9vdXRwdXRCaXRzID4+IDM7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjtcclxuICAgICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xyXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKHRoaXMuX291dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuICAgICAgICB3aGlsZSAoaiA8IHRoaXMuX291dHB1dEJsb2Nrcykge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tDb3VudCAmJiBqIDwgdGhpcy5fb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbal0gPSB0aGlzLl9zdGF0ZVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xyXG4gICAgICAgICAgICBhcnJheVtpXSA9IHRoaXMuX3N0YXRlW2ldO1xyXG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgZmluYWxpemUoKSB7XHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLl9sYXN0Qnl0ZUluZGV4O1xyXG4gICAgICAgIHRoaXMuX2Jsb2Nrc1tpID4+IDJdIHw9IHRoaXMuX3BhZGRpbmdbaSAmIDNdO1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLl9ieXRlQ291bnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmxvY2tzWzBdID0gdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2NrQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5fYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tzW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ibG9ja3NbdGhpcy5fYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Jsb2NrQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVtpXSBePSB0aGlzLl9ibG9ja3NbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMua2VjY2FrUGVybXV0YXRpb24odGhpcy5fc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBrZWNjYWtQZXJtdXRhdGlvbihzKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm9uZS12YXJpYWJsZS1wZXItZGVjbGFyYXRpb25cclxuICAgICAgICBsZXQgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNywgYjE4LCBiMTksIGIyMCwgYjIxLCBiMjIsIGIyMywgYjI0LCBiMjUsIGIyNiwgYjI3LCBiMjgsIGIyOSwgYjMwLCBiMzEsIGIzMiwgYjMzLCBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XHJcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcclxuICAgICAgICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XHJcbiAgICAgICAgICAgIGMxID0gc1sxXSBeIHNbMTFdIF4gc1syMV0gXiBzWzMxXSBeIHNbNDFdO1xyXG4gICAgICAgICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcclxuICAgICAgICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XHJcbiAgICAgICAgICAgIGM0ID0gc1s0XSBeIHNbMTRdIF4gc1syNF0gXiBzWzM0XSBeIHNbNDRdO1xyXG4gICAgICAgICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcclxuICAgICAgICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XHJcbiAgICAgICAgICAgIGM3ID0gc1s3XSBeIHNbMTddIF4gc1syN10gXiBzWzM3XSBeIHNbNDddO1xyXG4gICAgICAgICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcclxuICAgICAgICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XHJcbiAgICAgICAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIHNbMF0gXj0gaDtcclxuICAgICAgICAgICAgc1sxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzEwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzExXSBePSBsO1xyXG4gICAgICAgICAgICBzWzIwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzIxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzMwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzMxXSBePSBsO1xyXG4gICAgICAgICAgICBzWzQwXSBePSBoO1xyXG4gICAgICAgICAgICBzWzQxXSBePSBsO1xyXG4gICAgICAgICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBzWzJdIF49IGg7XHJcbiAgICAgICAgICAgIHNbM10gXj0gbDtcclxuICAgICAgICAgICAgc1sxMl0gXj0gaDtcclxuICAgICAgICAgICAgc1sxM10gXj0gbDtcclxuICAgICAgICAgICAgc1syMl0gXj0gaDtcclxuICAgICAgICAgICAgc1syM10gXj0gbDtcclxuICAgICAgICAgICAgc1szMl0gXj0gaDtcclxuICAgICAgICAgICAgc1szM10gXj0gbDtcclxuICAgICAgICAgICAgc1s0Ml0gXj0gaDtcclxuICAgICAgICAgICAgc1s0M10gXj0gbDtcclxuICAgICAgICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuICAgICAgICAgICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTtcclxuICAgICAgICAgICAgc1s0XSBePSBoO1xyXG4gICAgICAgICAgICBzWzVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMTRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMTVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMjRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMjVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbMzRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbMzVdIF49IGw7XHJcbiAgICAgICAgICAgIHNbNDRdIF49IGg7XHJcbiAgICAgICAgICAgIHNbNDVdIF49IGw7XHJcbiAgICAgICAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7XHJcbiAgICAgICAgICAgIHNbNl0gXj0gaDtcclxuICAgICAgICAgICAgc1s3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzE2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzE3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzI2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzI3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzM2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzM3XSBePSBsO1xyXG4gICAgICAgICAgICBzWzQ2XSBePSBoO1xyXG4gICAgICAgICAgICBzWzQ3XSBePSBsO1xyXG4gICAgICAgICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpO1xyXG4gICAgICAgICAgICBzWzhdIF49IGg7XHJcbiAgICAgICAgICAgIHNbOV0gXj0gbDtcclxuICAgICAgICAgICAgc1sxOF0gXj0gaDtcclxuICAgICAgICAgICAgc1sxOV0gXj0gbDtcclxuICAgICAgICAgICAgc1syOF0gXj0gaDtcclxuICAgICAgICAgICAgc1syOV0gXj0gbDtcclxuICAgICAgICAgICAgc1szOF0gXj0gaDtcclxuICAgICAgICAgICAgc1szOV0gXj0gbDtcclxuICAgICAgICAgICAgc1s0OF0gXj0gaDtcclxuICAgICAgICAgICAgc1s0OV0gXj0gbDtcclxuICAgICAgICAgICAgYjAgPSBzWzBdO1xyXG4gICAgICAgICAgICBiMSA9IHNbMV07XHJcbiAgICAgICAgICAgIGIzMiA9IChzWzExXSA8PCA0KSB8IChzWzEwXSA+Pj4gMjgpO1xyXG4gICAgICAgICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTtcclxuICAgICAgICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XHJcbiAgICAgICAgICAgIGIxNSA9IChzWzIxXSA8PCAzKSB8IChzWzIwXSA+Pj4gMjkpO1xyXG4gICAgICAgICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTtcclxuICAgICAgICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XHJcbiAgICAgICAgICAgIGIyOCA9IChzWzQwXSA8PCAxOCkgfCAoc1s0MV0gPj4+IDE0KTtcclxuICAgICAgICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpO1xyXG4gICAgICAgICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XHJcbiAgICAgICAgICAgIGIyMSA9IChzWzNdIDw8IDEpIHwgKHNbMl0gPj4+IDMxKTtcclxuICAgICAgICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7XHJcbiAgICAgICAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xyXG4gICAgICAgICAgICBiMzQgPSAoc1syMl0gPDwgMTApIHwgKHNbMjNdID4+PiAyMik7XHJcbiAgICAgICAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTtcclxuICAgICAgICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xyXG4gICAgICAgICAgICBiMTcgPSAoc1szMl0gPDwgMTMpIHwgKHNbMzNdID4+PiAxOSk7XHJcbiAgICAgICAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApO1xyXG4gICAgICAgICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcclxuICAgICAgICAgICAgYjQwID0gKHNbNV0gPDwgMzApIHwgKHNbNF0gPj4+IDIpO1xyXG4gICAgICAgICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7XHJcbiAgICAgICAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xyXG4gICAgICAgICAgICBiMjMgPSAoc1sxNV0gPDwgNikgfCAoc1sxNF0gPj4+IDI2KTtcclxuICAgICAgICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7XHJcbiAgICAgICAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xyXG4gICAgICAgICAgICBiMzYgPSAoc1szNF0gPDwgMTUpIHwgKHNbMzVdID4+PiAxNyk7XHJcbiAgICAgICAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTtcclxuICAgICAgICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XHJcbiAgICAgICAgICAgIGIxOSA9IChzWzQ0XSA8PCAyOSkgfCAoc1s0NV0gPj4+IDMpO1xyXG4gICAgICAgICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7XHJcbiAgICAgICAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcclxuICAgICAgICAgICAgYjQyID0gKHNbMTddIDw8IDIzKSB8IChzWzE2XSA+Pj4gOSk7XHJcbiAgICAgICAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpO1xyXG4gICAgICAgICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcclxuICAgICAgICAgICAgYjI1ID0gKHNbMjddIDw8IDI1KSB8IChzWzI2XSA+Pj4gNyk7XHJcbiAgICAgICAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpO1xyXG4gICAgICAgICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcclxuICAgICAgICAgICAgYjM4ID0gKHNbNDddIDw8IDI0KSB8IChzWzQ2XSA+Pj4gOCk7XHJcbiAgICAgICAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpO1xyXG4gICAgICAgICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XHJcbiAgICAgICAgICAgIGIzMSA9IChzWzldIDw8IDI3KSB8IChzWzhdID4+PiA1KTtcclxuICAgICAgICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpO1xyXG4gICAgICAgICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XHJcbiAgICAgICAgICAgIGI0NCA9IChzWzI5XSA8PCA3KSB8IChzWzI4XSA+Pj4gMjUpO1xyXG4gICAgICAgICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTtcclxuICAgICAgICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XHJcbiAgICAgICAgICAgIGIyNyA9IChzWzM5XSA8PCA4KSB8IChzWzM4XSA+Pj4gMjQpO1xyXG4gICAgICAgICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTtcclxuICAgICAgICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XHJcbiAgICAgICAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XHJcbiAgICAgICAgICAgIHNbMV0gPSBiMSBeICh+YjMgJiBiNSk7XHJcbiAgICAgICAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xyXG4gICAgICAgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcclxuICAgICAgICAgICAgc1syMF0gPSBiMjAgXiAofmIyMiAmIGIyNCk7XHJcbiAgICAgICAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xyXG4gICAgICAgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcclxuICAgICAgICAgICAgc1szMV0gPSBiMzEgXiAofmIzMyAmIGIzNSk7XHJcbiAgICAgICAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xyXG4gICAgICAgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcclxuICAgICAgICAgICAgc1syXSA9IGIyIF4gKH5iNCAmIGI2KTtcclxuICAgICAgICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcclxuICAgICAgICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XHJcbiAgICAgICAgICAgIHNbMTNdID0gYjEzIF4gKH5iMTUgJiBiMTcpO1xyXG4gICAgICAgICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcclxuICAgICAgICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XHJcbiAgICAgICAgICAgIHNbMzJdID0gYjMyIF4gKH5iMzQgJiBiMzYpO1xyXG4gICAgICAgICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcclxuICAgICAgICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XHJcbiAgICAgICAgICAgIHNbNDNdID0gYjQzIF4gKH5iNDUgJiBiNDcpO1xyXG4gICAgICAgICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xyXG4gICAgICAgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xyXG4gICAgICAgICAgICBzWzE0XSA9IGIxNCBeICh+YjE2ICYgYjE4KTtcclxuICAgICAgICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XHJcbiAgICAgICAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xyXG4gICAgICAgICAgICBzWzI1XSA9IGIyNSBeICh+YjI3ICYgYjI5KTtcclxuICAgICAgICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XHJcbiAgICAgICAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xyXG4gICAgICAgICAgICBzWzQ0XSA9IGI0NCBeICh+YjQ2ICYgYjQ4KTtcclxuICAgICAgICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XHJcbiAgICAgICAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XHJcbiAgICAgICAgICAgIHNbN10gPSBiNyBeICh+YjkgJiBiMSk7XHJcbiAgICAgICAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xyXG4gICAgICAgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcclxuICAgICAgICAgICAgc1syNl0gPSBiMjYgXiAofmIyOCAmIGIyMCk7XHJcbiAgICAgICAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xyXG4gICAgICAgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcclxuICAgICAgICAgICAgc1szN10gPSBiMzcgXiAofmIzOSAmIGIzMSk7XHJcbiAgICAgICAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xyXG4gICAgICAgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcclxuICAgICAgICAgICAgc1s4XSA9IGI4IF4gKH5iMCAmIGIyKTtcclxuICAgICAgICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcclxuICAgICAgICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XHJcbiAgICAgICAgICAgIHNbMTldID0gYjE5IF4gKH5iMTEgJiBiMTMpO1xyXG4gICAgICAgICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcclxuICAgICAgICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XHJcbiAgICAgICAgICAgIHNbMzhdID0gYjM4IF4gKH5iMzAgJiBiMzIpO1xyXG4gICAgICAgICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcclxuICAgICAgICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XHJcbiAgICAgICAgICAgIHNbNDldID0gYjQ5IF4gKH5iNDEgJiBiNDMpO1xyXG4gICAgICAgICAgICBzWzBdIF49IFNoYTMuUk9VTkRfQ09OU1RBTlRTW25dO1xyXG4gICAgICAgICAgICBzWzFdIF49IFNoYTMuUk9VTkRfQ09OU1RBTlRTW24gKyAxXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyogUGFkZGluZyB0byB1c2UgZm9yIEtlY2NhayAqL1xyXG5TaGEzLktFQ0NBS19QQURESU5HID0gbmV3IFVpbnQzMkFycmF5KFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl0pO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuU2hhMy5TSElGVCA9IG5ldyBVaW50OEFycmF5KFswLCA4LCAxNiwgMjRdKTtcclxuLyogQGludGVybmFsICovXHJcblNoYTMuUk9VTkRfQ09OU1RBTlRTID0gbmV3IFVpbnQzMkFycmF5KFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxyXG4gICAgMCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI3NzcsIDIxNDc0ODM2NDgsIDEzOCwgMCwgMTM2LCAwLCAyMTQ3NTE2NDI1LCAwLFxyXG4gICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXHJcbiAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcclxuICAgIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XSk7XHJcbmV4cG9ydHMuU2hhMyA9IFNoYTM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWMyaGhNeTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWthV2RsYzNSekwzTm9ZVE11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRFJGUVVGNVJUdEJRVU42UlN4elJFRkJiVVE3UVVGRmJrUTdPMGRCUlVjN1FVRkRTRHRKUVhGRFNUczdPenM3VDBGTFJ6dEpRVU5JTEZsQlFWa3NTVUZCV1N4RlFVRkZMRTlCUVc5Q0xFVkJRVVVzVlVGQmEwSTdVVUZET1VRc1NVRkJTU3hEUVVGRExGRkJRVkVzUjBGQlJ5eFBRVUZQTEVOQlFVTTdVVUZEZUVJc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eFZRVUZWTEVOQlFVTTdVVUZET1VJc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEVsQlFVa3NSMEZCUnl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTTNReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4WFFVRlhMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM2hETEVsQlFVa3NRMEZCUXl4aFFVRmhMRWRCUVVjc1ZVRkJWU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU55UXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFTkJRVU1zVlVGQlZTeEhRVUZITEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVVeFF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1NVRkRha0lzUTBGQlF6dEpRVVZFT3p0UFFVVkhPMGxCUTBrc1MwRkJTenRSUVVOU0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTI1Q0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVkQlFVY3NTVUZCU1N4WFFVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlSQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEVsQlFVa3NWMEZCVnl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRM1JETEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNTMEZCYTBJN1VVRkROVUlzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNSVUZCUlR0WlFVTXhReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4clEwRkJhME1zUTBGQlF5eERRVUZETzFOQlF6ZEVPMUZCUTBRc1RVRkJUU3hQUVVGUExFZEJRV1VzU1VGQlNTeFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRiRVFzVFVGQlRTeE5RVUZOTEVkQlFVY3NUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVNNVFpeEpRVUZKTEV0QlFVc3NSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRaQ3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVVZPTEU5QlFVOHNTMEZCU3l4SFFVRkhMRTFCUVUwc1JVRkJSVHRaUVVOdVFpeEpRVUZKTEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVN1owSkJRMklzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNN1owSkJRM0JDTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0blFrRkRPVUlzUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEhRVUZITEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSVHR2UWtGRGRrTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdhVUpCUTNaQ08yRkJRMG83V1VGRFJDeExRVUZMTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzUlVGQlJTeExRVUZMTEVWQlFVVTdaMEpCUTJ4RkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhKUVVGSkxFOUJRVThzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMkZCUTJwRk8xbEJRMFFzU1VGQlNTeERRVUZETEdOQlFXTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRlRUlzU1VGQlNTeERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSVHRuUWtGRGRFSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXp0blFrRkRiRU1zU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXp0blFrRkROME1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RlFVRkZPMjlDUVVOdVF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2FVSkJRM0pETzJkQ1FVTkVMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEzQkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETzJGQlEzUkNPMmxDUVVGTk8yZENRVU5JTEVsQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRE8yRkJRMjVDTzFOQlEwbzdTVUZEVEN4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NUVUZCVFR0UlFVTlVMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFJRVVZvUWl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRFZpeEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRWaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOd1F5eEpRVUZKTEUxQlFVMHNRMEZCUXp0UlFVTllMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJUdFpRVU5zUWl4TlFVRk5MRWRCUVVjc1NVRkJTU3hYUVVGWExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNZVUZCWVN4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFOQlF6TkVPMkZCUVUwN1dVRkRTQ3hOUVVGTkxFZEJRVWNzU1VGQlNTeFhRVUZYTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1UwRkRia003VVVGRFJDeE5RVUZOTEV0QlFVc3NSMEZCUnl4SlFVRkpMRmRCUVZjc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU4wUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU1zWVVGQllTeEZRVUZGTzFsQlF6TkNMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1NVRkJTU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEdGQlFXRXNSVUZCUlN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlJUdG5Ra0ZEYkVVc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRE4wSTdVMEZEU2p0UlFVTkVMRWxCUVVrc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJUdFpRVU5zUWl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNeFFpeE5RVUZOTEVkQlFVY3NUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdVMEZEYmtNN1VVRkRSQ3hKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdVVUZGWWl4UFFVRlBMRTFCUVUwc1EwRkJRenRKUVVOc1FpeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRkZCUVZFN1VVRkRXaXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRPMUZCUXpWQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemRETEVsQlFVa3NTVUZCU1N4RFFVRkRMR05CUVdNc1MwRkJTeXhKUVVGSkxFTkJRVU1zVlVGQlZTeEZRVUZGTzFsQlEzcERMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdXVUZEYWtRc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNSVUZCUlR0blFrRkRka01zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03WVVGRGRrSTdVMEZEU2p0UlFVTkVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hWUVVGVkxFTkJRVU03VVVGRGFrUXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRVZCUVVVc1EwRkJReXhGUVVGRk8xbEJRMjVETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVOeVF6dFJRVU5FTEVsQlFVa3NRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRlRU1zUTBGQlF6dEpRVVZFTEdWQlFXVTdTVUZEVUN4cFFrRkJhVUlzUTBGQlF5eERRVUZqTzFGQlEzQkRMSGRFUVVGM1JEdFJRVU40UkN4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZETDBNc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRVZCUVVVc1JVRkJSU3hGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUXpsRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZET1VVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETzFGQlEyNUdMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSVUZCUlN4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRVVU3V1VGRGVFSXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZETVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRE1VTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZETVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRE1VTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZETVVNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRE1VTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdXVUZGTVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia01zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5XTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFZpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTI1RExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRWaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFZc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExWXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5XTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYmtNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia01zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOV0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRWaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEV0N4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExZ3NRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMjVETEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVml4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlExWXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5ZTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMWdzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOWUxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRXQ3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTFnc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZGV0N4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExWXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5XTEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY2tNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRMnhETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTnNReXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU55UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRja01zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzSkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY0VNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnNReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU53UXl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY2tNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRjRU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOd1F5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY0VNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndReXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4RExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5zUXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVsQlFVa3NSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRja01zUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzSkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVOd1F5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEY0VNc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM0JETEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTndReXhGUVVGRkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGNFTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMWxCUlhCRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFVkJRVVVzUjBGQlJ5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEZGtJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNc1EwRkJReXhGUVVGRkxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEZGtJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzWkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlEzWkNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU4yUWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRE0wSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU4yUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGRrSXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRek5DTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGRrSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJRM1pDTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJRenRaUVVNelFpeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTXpRaXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTTdXVUZETTBJc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlF6TkNMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU16UWl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRk0wSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTNaRE8wbEJRMHdzUTBGQlF6czdRVUZvVmtRc0swSkJRU3RDTzBGQlExSXNiVUpCUVdNc1IwRkJaMElzU1VGQlNTeFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTJoSExHVkJRV1U3UVVGRFV5eFZRVUZMTEVkQlFXVXNTVUZCU1N4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRek5GTEdWQlFXVTdRVUZEVXl4dlFrRkJaU3hIUVVGblFpeEpRVUZKTEZkQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNSVUZCUlN4TFFVRkxMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFZRVUZWTEVWQlFVVXNTMEZCU3l4RlFVRkZMRU5CUVVNc1JVRkJSU3hWUVVGVk8wbEJRMjVLTEVOQlFVTXNSVUZCUlN4VlFVRlZMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFdEJRVXNzUlVGQlJTeFZRVUZWTEVWQlFVVXNSMEZCUnl4RlFVRkZMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzUTBGQlF5eEZRVUZGTEZWQlFWVXNSVUZCUlN4RFFVRkRPMGxCUXpORkxGVkJRVlVzUlVGQlJTeERRVUZETEVWQlFVVXNWVUZCVlN4RlFVRkZMRU5CUVVNc1JVRkJSU3hIUVVGSExFVkJRVVVzVlVGQlZTeEZRVUZGTEV0QlFVc3NSVUZCUlN4VlFVRlZMRVZCUVVVc1MwRkJTenRKUVVOMlJTeFZRVUZWTEVWQlFVVXNTMEZCU3l4RlFVRkZMRlZCUVZVc1JVRkJSU3hIUVVGSExFVkJRVVVzVlVGQlZTeEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlU3U1VGRGFFWXNWVUZCVlN4RlFVRkZMRlZCUVZVc1JVRkJSU3hMUVVGTExFVkJRVVVzVlVGQlZTeEZRVUZGTEZWQlFWVXNSVUZCUlN4RFFVRkRMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZXTTBZc2IwSkJhMVpESW4wPSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgY29yZUVycm9yXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvZXJyb3IvY29yZUVycm9yXCIpO1xyXG4vKipcclxuICogQSBjcnlwdG8gaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBDcnlwdG9FcnJvciBleHRlbmRzIGNvcmVFcnJvcl8xLkNvcmVFcnJvciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBDcnlwdG9FcnJvci5cclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGZvciB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxyXG4gICAgICogQHBhcmFtIGlubmVyRXJyb3IgQWRkIGluZm9ybWF0aW9uIGZyb20gaW5uZXIgZXJyb3IgaWYgdGhlcmUgd2FzIG9uZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIGFkZGl0aW9uYWwsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gXCJDcnlwdG9cIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNyeXB0b0Vycm9yID0gQ3J5cHRvRXJyb3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkzSjVjSFJ2UlhKeWIzSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpYSnliM0l2WTNKNWNIUnZSWEp5YjNJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTEc5RlFVRnBSVHRCUVVWcVJUczdSMEZGUnp0QlFVTklMR2xDUVVGNVFpeFRRVUZSTEhGQ1FVRlRPMGxCUTNSRE96czdPenRQUVV0SE8wbEJRMGdzV1VGQldTeFBRVUZsTEVWQlFVVXNWVUZCYTBNc1JVRkJSU3hWUVVGclFqdFJRVU12UlN4TFFVRkxMRU5CUVVNc1QwRkJUeXhGUVVGRkxGVkJRVlVzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVTjJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEZGQlFWRXNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wTkJRMG83UVVGWVJDeHJRMEZYUXlKOSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgZmFjdG9yeUJhc2VfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9mYWN0b3JpZXMvZmFjdG9yeUJhc2VcIik7XHJcbmNvbnN0IGN1cmxfMSA9IHJlcXVpcmUoXCIuLi9zcG9uZ2VzL2N1cmxcIik7XHJcbmNvbnN0IGtlcmxfMSA9IHJlcXVpcmUoXCIuLi9zcG9uZ2VzL2tlcmxcIik7XHJcbi8qKlxyXG4gKiBGYWN0b3J5IHRvIGdlbmVyYXRlIHNwb25nZXMuXHJcbiAqL1xyXG5jbGFzcyBTcG9uZ2VGYWN0b3J5IGV4dGVuZHMgZmFjdG9yeUJhc2VfMS5GYWN0b3J5QmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIERvbid0IGFsbG93IG1hbnVhbCBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZhY3RvcnkuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBpbnN0YW5jZSBvZiB0aGUgZmFjdG9yeS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBmYWN0b3J5IGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW5zdGFuY2UoKSB7XHJcbiAgICAgICAgaWYgKCFTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZSA9IG5ldyBTcG9uZ2VGYWN0b3J5KCk7XHJcbiAgICAgICAgICAgIFNwb25nZUZhY3RvcnkuX2luc3RhbmNlLnJlZ2lzdGVyKFwiY3VybFwiLCAoLi4uYXJncykgPT4gbmV3IGN1cmxfMS5DdXJsKC4uLmFyZ3MpKTtcclxuICAgICAgICAgICAgU3BvbmdlRmFjdG9yeS5faW5zdGFuY2UucmVnaXN0ZXIoXCJjdXJsODFcIiwgKC4uLmFyZ3MpID0+IG5ldyBjdXJsXzEuQ3VybCg4MSkpO1xyXG4gICAgICAgICAgICBTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZS5yZWdpc3RlcihcImN1cmwyN1wiLCAoLi4uYXJncykgPT4gbmV3IGN1cmxfMS5DdXJsKDI3KSk7XHJcbiAgICAgICAgICAgIFNwb25nZUZhY3RvcnkuX2luc3RhbmNlLnJlZ2lzdGVyKFwia2VybFwiLCAoLi4uYXJncykgPT4gbmV3IGtlcmxfMS5LZXJsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3BvbmdlRmFjdG9yeS5faW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiBTcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TcG9uZ2VGYWN0b3J5ID0gU3BvbmdlRmFjdG9yeTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzNCdmJtZGxSbUZqZEc5eWVTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5bVlXTjBiM0pwWlhNdmMzQnZibWRsUm1GamRHOXllUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNORVZCUVhsRk8wRkJSWHBGTERCRFFVRjFRenRCUVVOMlF5d3dRMEZCZFVNN1FVRkZka003TzBkQlJVYzdRVUZEU0N4dFFrRkJNa0lzVTBGQlVTeDVRa0ZCYjBJN1NVRkpia1E3T3p0UFFVZEhPMGxCUTBnN1VVRkRTU3hMUVVGTExFVkJRVVVzUTBGQlF6dEpRVU5hTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNVVUZCVVR0UlFVTnNRaXhKUVVGSkxFTkJRVU1zWVVGQllTeERRVUZETEZOQlFWTXNSVUZCUlR0WlFVTXhRaXhoUVVGaExFTkJRVU1zVTBGQlV5eEhRVUZITEVsQlFVa3NZVUZCWVN4RlFVRkZMRU5CUVVNN1dVRkRPVU1zWVVGQllTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVWQlFVVXNSVUZCUlN4RFFVRkRMRWxCUVVrc1YwRkJTU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZSU3hoUVVGaExFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhIUVVGSExFbEJRVWtzUlVGQlJTeEZRVUZGTEVOQlFVTXNTVUZCU1N4WFFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4wUlN4aFFVRmhMRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1JVRkJSU3hGUVVGRkxFTkJRVU1zU1VGQlNTeFhRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMFJTeGhRVUZoTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCUlN4RlFVRkZMRU5CUVVNc1NVRkJTU3hYUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlEzSkZPMUZCUTBRc1QwRkJUeXhoUVVGaExFTkJRVU1zVTBGQlV5eERRVUZETzBsQlEyNURMRU5CUVVNN1NVRkZSQ3hsUVVGbE8wbEJRMHdzVjBGQlZ6dFJRVU5xUWl4UFFVRlBMR0ZCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dEpRVU53UXl4RFFVRkRPME5CUTBvN1FVRXZRa1FzYzBOQkswSkRJbjA9IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYWRkcmVzc1wiKTtcclxuY29uc3QgYWRkcmVzc1NlY3VyaXR5XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzU2VjdXJpdHlcIik7XHJcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2hhc2hcIik7XHJcbmNvbnN0IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XCIpO1xyXG5jb25zdCB0cml0c18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHNcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCBzcG9uZ2VGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi4vZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnlcIik7XHJcbi8qKlxyXG4gKiBJU1MgSGFzaGluZyBmdW5jdGlvbnMuXHJcbiAqIENvbnZlcnRlZCBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pcmkvc3JjL21haW4vamF2YS9jb20vaW90YS9pcmkvaGFzaC9JU1MuamF2YVxyXG4gKi9cclxuY2xhc3MgSVNTIHtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdWJzZWVkIGZvciB0aGUgc2VlZCBhbmQgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZC5cclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggZm9yIHRoZSBzZWVkLlxyXG4gICAgICogQHBhcmFtIHNwb25nZVR5cGUgVGhlIHNwb25nZSB0eXBlIHRvIHVzZSBmb3Igb3BlcmF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzdWJzZWVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc3Vic2VlZChzZWVkLCBpbmRleCwgc3BvbmdlVHlwZSA9IFwiY3VybDI3XCIpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgSW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihpbmRleCkgfHwgaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIGluZGV4IG11c3QgYmUgYW4gaW50ZWdlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuZXhpc3RzKHNwb25nZVR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc3BvbmdlVHlwZSBtdXN0IGJlIG9uZSBvZiBbJHtzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLnR5cGVzKCkuam9pbihcIiwgXCIpfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3BvbmdlID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoc3BvbmdlVHlwZSk7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IHNwb25nZS5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIHNwb25nZS5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgY29uc3Qgc3Vic2VlZFByZWltYWdlID0gc2VlZC5zbGljZSgpO1xyXG4gICAgICAgIGxldCBsb2NhbEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgd2hpbGUgKGxvY2FsSW5kZXgtLSA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzZWVkUHJlaW1hZ2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICgrK3N1YnNlZWRQcmVpbWFnZVtpXSA+IElTUy5NQVhfVFJJVF9WQUxVRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNlZWRQcmVpbWFnZVtpXSA9IElTUy5NSU5fVFJJVF9WQUxVRTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN1YnNlZWQgPSBuZXcgSW50OEFycmF5KGhhc2hMZW5ndGgpO1xyXG4gICAgICAgIHNwb25nZS5hYnNvcmIoc3Vic2VlZFByZWltYWdlLCAwLCBzdWJzZWVkUHJlaW1hZ2UubGVuZ3RoKTtcclxuICAgICAgICBzcG9uZ2Uuc3F1ZWV6ZShzdWJzZWVkLCAwLCBzdWJzZWVkLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHN1YnNlZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUga2V5IGZvciB0aGUgc2VlZC5cclxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGNyZWF0ZSB0aGUga2V5IGZvci5cclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggdG8gdXNlIGZvciB0aGUgc2VlZC5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIHNlY3VyaXR5IGxldmVsIHRvIGNyZWF0ZSB0aGUga2V5LlxyXG4gICAgICogQHBhcmFtIHNwb25nZVR5cGUgVGhlIHNwb25nZSB0eXBlIHRvIHVzZSBmb3Igb3BlcmF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIHRoZSBrZXkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBrZXkoc2VlZCwgaW5kZXgsIHNlY3VyaXR5LCBzcG9uZ2VUeXBlID0gXCJrZXJsXCIpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihpbmRleCkgfHwgaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIGluZGV4IG11c3QgYmUgYW4gaW50ZWdlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5LmxvdyB8fCBzZWN1cml0eSA+IGFkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc2VjdXJpdHkgbXVzdCBiZSBhbiBpbnRlZ2VyID49IDEgYW5kIDw9IDNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmV4aXN0cyhzcG9uZ2VUeXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgVGhlIHNwb25nZVR5cGUgbXVzdCBiZSBvbmUgb2YgWyR7c3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS50eXBlcygpLmpvaW4oXCIsIFwiKX1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZWRUcml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyhzZWVkLnRvVHJ5dGVzKCkpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4VHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21OdW1iZXIoaW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IHN1YnNlZWQgPSB0cml0c18xLlRyaXRzLmFkZChzZWVkVHJpdHMsIGluZGV4VHJpdHMpLnRvQXJyYXkoKTtcclxuICAgICAgICBjb25zdCBzdWJzZWVkTGVuZ3RoID0gc3Vic2VlZC5sZW5ndGg7XHJcbiAgICAgICAgY29uc3Qgc3BvbmdlID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoc3BvbmdlVHlwZSk7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IHNwb25nZS5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIHNwb25nZS5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgc3BvbmdlLmFic29yYihzdWJzZWVkLCAwLCBzdWJzZWVkTGVuZ3RoKTtcclxuICAgICAgICBzcG9uZ2Uuc3F1ZWV6ZShzdWJzZWVkLCAwLCBzdWJzZWVkTGVuZ3RoKTtcclxuICAgICAgICBzcG9uZ2UucmVzZXQoKTtcclxuICAgICAgICBzcG9uZ2UuYWJzb3JiKHN1YnNlZWQsIDAsIHN1YnNlZWRMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBJbnQ4QXJyYXkoSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1MgKiBoYXNoTGVuZ3RoICogc2VjdXJpdHkpO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBJbnQ4QXJyYXkoc3Vic2VlZExlbmd0aCk7XHJcbiAgICAgICAgbGV0IGxvY2FsTGVuZ3RoID0gc2VjdXJpdHk7XHJcbiAgICAgICAgd2hpbGUgKGxvY2FsTGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3BvbmdlLnNxdWVlemUoYnVmZmVyLCAwLCBzdWJzZWVkTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGFzaExlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5W29mZnNldCsrXSA9IGJ1ZmZlcltqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhlIGRpZ2VzdHMgZm9yIHRoZSBnaXZlbiBzdWJzZWVkLlxyXG4gICAgICogQHBhcmFtIHN1YnNlZWQgVG8gY3JlYXRlIHRoZSBkaWdlc3RzIGZvci5cclxuICAgICAqIEBwYXJhbSBzcG9uZ2VUeXBlIFRoZSBzcG9uZ2UgdHlwZSB0byB1c2UgZm9yIG9wZXJhdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlnZXN0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRpZ2VzdHMoc3Vic2VlZCwgc3BvbmdlVHlwZSA9IFwia2VybFwiKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHN1YnNlZWQsIEludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgc3Vic2VlZCBtdXN0IGJlIG9mIHR5cGUgSW50OEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuZXhpc3RzKHNwb25nZVR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc3BvbmdlVHlwZSBtdXN0IGJlIG9uZSBvZiBbJHtzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLnR5cGVzKCkuam9pbihcIiwgXCIpfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3BvbmdlID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoc3BvbmdlVHlwZSk7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IHNwb25nZS5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50TGVuZ3RoID0gaGFzaExlbmd0aCAqIElTUy5OVU1CRVJfT0ZfRlJBR01FTlRfQ0hVTktTO1xyXG4gICAgICAgIGlmIChzdWJzZWVkLmxlbmd0aCAlIGZyYWdtZW50TGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc3Vic2VlZCBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7ZnJhZ21lbnRMZW5ndGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyeXRlUmFuZ2UgPSBJU1MuTUFYX1RSWVRFX1ZBTFVFIC0gSVNTLk1JTl9UUllURV9WQUxVRTtcclxuICAgICAgICBjb25zdCBrZXlMZW5EaXYgPSBzdWJzZWVkLmxlbmd0aCAvIGZyYWdtZW50TGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGRpZ2VzdHMgPSBuZXcgSW50OEFycmF5KGtleUxlbkRpdiAqIGhhc2hMZW5ndGgpO1xyXG4gICAgICAgIGxldCBidWZmZXI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlMZW5EaXY7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpTXVsID0gaSAqIGZyYWdtZW50TGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBrZXlGcmFnbWVudCA9IHN1YnNlZWQuc2xpY2UoaU11bCwgaU11bCArIGZyYWdtZW50TGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBJU1MuTlVNQkVSX09GX0ZSQUdNRU5UX0NIVU5LUzsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqTXVsID0gaiAqIGhhc2hMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBrZXlGcmFnbWVudC5zbGljZShqTXVsLCBqTXVsICsgaGFzaExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRyeXRlUmFuZ2U7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwb25nZS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwb25nZS5hYnNvcmIoYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBzcG9uZ2Uuc3F1ZWV6ZShidWZmZXIsIDAsIGhhc2hMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBoYXNoTGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlGcmFnbWVudFtqTXVsICsga10gPSBidWZmZXJba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3BvbmdlLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHNwb25nZS5hYnNvcmIoa2V5RnJhZ21lbnQsIDAsIGtleUZyYWdtZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHNwb25nZS5zcXVlZXplKGJ1ZmZlciwgMCwgaGFzaExlbmd0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGlNdWwyID0gaSAqIGhhc2hMZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGFzaExlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBkaWdlc3RzW2lNdWwyICsgal0gPSBidWZmZXJbal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpZ2VzdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSB0aGUgYWRkcmVzcyBmb3IgdGhlIGRpZ2VzdHMuXHJcbiAgICAgKiBAcGFyYW0gZGlnZXN0cyBUaGUgZGlnZXN0cyB0byBjcmVhdGUgdGhlIGFkZHJlc3MgZm9yLlxyXG4gICAgICogQHBhcmFtIHNwb25nZVR5cGUgVGhlIHNwb25nZSB0eXBlIHRvIHVzZSBmb3Igb3BlcmF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIHRoZSBhZGRyZXNzIHRyaXRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYWRkcmVzcyhkaWdlc3RzLCBzcG9uZ2VUeXBlID0gXCJrZXJsXCIpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoZGlnZXN0cywgSW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBkaWdlc3RzIG11c3QgYmUgb2YgdHlwZSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5leGlzdHMoc3BvbmdlVHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYFRoZSBzcG9uZ2VUeXBlIG11c3QgYmUgb25lIG9mIFske3Nwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkudHlwZXMoKS5qb2luKFwiLCBcIil9XWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzcG9uZ2UgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShzcG9uZ2VUeXBlKTtcclxuICAgICAgICBjb25zdCBoYXNoTGVuZ3RoID0gc3BvbmdlLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIik7XHJcbiAgICAgICAgaWYgKGRpZ2VzdHMubGVuZ3RoICUgaGFzaExlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgSW52YWxpZCBkaWdlc3RzIGxlbmd0aCwgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aGFzaExlbmd0aH1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3BvbmdlLmluaXRpYWxpemUoKTtcclxuICAgICAgICBzcG9uZ2UuYWJzb3JiKGRpZ2VzdHMsIDAsIGRpZ2VzdHMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBhZGRyZXNzVHJpdHMgPSBuZXcgSW50OEFycmF5KGhhc2hMZW5ndGgpO1xyXG4gICAgICAgIHNwb25nZS5zcXVlZXplKGFkZHJlc3NUcml0cywgMCwgYWRkcmVzc1RyaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGFkZHJlc3NUcml0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGRpZ2VzdCBvZiB0aGUgbm9ybWFsaXplZCBidW5kbGUgZnJhZ21lbnQuXHJcbiAgICAgKiBAcGFyYW0gbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50IFRoZSBmcmFnbWVudCB0byBjcmVhdGUgZGlnZXN0LlxyXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBUaGUgdHJpdHMgZm9yIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50LlxyXG4gICAgICogQHBhcmFtIHNwb25nZVR5cGUgVGhlIHNwb25nZSB0eXBlIHRvIHVzZSBmb3Igb3BlcmF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkaWdlc3Qgb2YgdGhlIGJ1bmRsZSBhbmQgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkaWdlc3Qobm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50LCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQsIHNwb25nZVR5cGUgPSBcImtlcmxcIikge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShub3JtYWxpemVkQnVuZGxlRnJhZ21lbnQsIEludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50IG11c3QgYmUgb2YgdHlwZSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQsIEludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IG11c3QgYmUgb2YgdHlwZSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5leGlzdHMoc3BvbmdlVHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYFRoZSBzcG9uZ2VUeXBlIG11c3QgYmUgb25lIG9mIFske3Nwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkudHlwZXMoKS5qb2luKFwiLCBcIil9XWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IHNwb25nZSA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKHNwb25nZVR5cGUpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hMZW5ndGggPSBzcG9uZ2UuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKTtcclxuICAgICAgICBzcG9uZ2UuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1M7IGkrKykge1xyXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgSW50OEFycmF5KHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5zbGljZShpICogaGFzaExlbmd0aCwgKGkgKyAxKSAqIGhhc2hMZW5ndGgpKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudFtpXSAtIElTUy5NSU5fVFJZVEVfVkFMVUU7IGogPiAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNwb25nZTIgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShzcG9uZ2VUeXBlKTtcclxuICAgICAgICAgICAgICAgIHNwb25nZTIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgc3BvbmdlMi5hYnNvcmIoYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHNwb25nZTIuc3F1ZWV6ZShidWZmZXIsIDAsIHNwb25nZTIuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3BvbmdlLmFic29yYihidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzcG9uZ2Uuc3F1ZWV6ZShidWZmZXIsIDAsIHNwb25nZS5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpKTtcclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRpZ2VzdCBmb3IgdGhlIHN1YnNlZWQuXHJcbiAgICAgKiBAcGFyYW0gc3Vic2VlZCBUaGUgc3Vic2VlZCB0byBnZXQgdGhlIGRpZ2VzdCBmb3IuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsLlxyXG4gICAgICogQHBhcmFtIHNwb25nZVR5cGUgVGhlIHNwb25nZSB0eXBlIHRvIHVzZSBmb3Igb3BlcmF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkaWdlc3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzdWJzZWVkVG9EaWdlc3Qoc3Vic2VlZCwgc2VjdXJpdHksIHNwb25nZVR5cGUgPSBcImN1cmwyN1wiKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHN1YnNlZWQsIEludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgc3Vic2VlZCBtdXN0IGJlIG9mIHR5cGUgSW50OEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5LmxvdyB8fCBzZWN1cml0eSA+IGFkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc2VjdXJpdHkgbXVzdCBiZSBhbiBpbnRlZ2VyID49IDEgYW5kIDw9IDNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmV4aXN0cyhzcG9uZ2VUeXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgVGhlIHNwb25nZVR5cGUgbXVzdCBiZSBvbmUgb2YgWyR7c3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS50eXBlcygpLmpvaW4oXCIsIFwiKX1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGMxID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoc3BvbmdlVHlwZSk7XHJcbiAgICAgICAgY29uc3QgYzIgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShzcG9uZ2VUeXBlKTtcclxuICAgICAgICBjb25zdCBjMyA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKHNwb25nZVR5cGUpO1xyXG4gICAgICAgIGMxLmluaXRpYWxpemUoKTtcclxuICAgICAgICBjMi5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgYzMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hMZW5ndGggPSBjMS5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIGNvbnN0IGtleUxlbmd0aCA9ICgoaGFzaExlbmd0aCAvIDMpIC8gSVNTLlJBRElYKSAqIGhhc2hMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc2VjdXJpdHkgKiBrZXlMZW5ndGggLyBoYXNoTGVuZ3RoO1xyXG4gICAgICAgIGxldCBvdXQgPSBuZXcgSW50OEFycmF5KGhhc2hMZW5ndGgpO1xyXG4gICAgICAgIGMxLmFic29yYihzdWJzZWVkLCAwLCBzdWJzZWVkLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjMS5zcXVlZXplKG91dCwgMCwgb3V0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgKElTUy5NQVhfVFJZVEVfVkFMVUUgLSBJU1MuTUlOX1RSWVRFX1ZBTFVFICsgMSk7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYzIucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGMyLmFic29yYihvdXQsIDAsIG91dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgb3V0ID0gYzIuZ2V0U3RhdGUoKS5zbGljZSgwLCBoYXNoTGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjMy5hYnNvcmIob3V0LCAwLCBvdXQubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYzMuc3F1ZWV6ZShvdXQsIDAsIG91dC5sZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5vcm1hbGl6ZWQgYnVuZGxlLlxyXG4gICAgICogQHBhcmFtIGJ1bmRsZUhhc2ggVGhlIGhhc2ggb2YgdGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSBzcG9uZ2VUeXBlIFRoZSBzcG9uZ2UgdHlwZSB0byB1c2UgZm9yIG9wZXJhdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCBidW5kbGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBub3JtYWxpemVkQnVuZGxlKGJ1bmRsZUhhc2gsIHNwb25nZVR5cGUgPSBcImN1cmw4MVwiKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJ1bmRsZUhhc2gsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBidW5kbGVIYXNoIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuZXhpc3RzKHNwb25nZVR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc3BvbmdlVHlwZSBtdXN0IGJlIG9uZSBvZiBbJHtzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLnR5cGVzKCkuam9pbihcIiwgXCIpfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3BvbmdlID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoc3BvbmdlVHlwZSk7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IHNwb25nZS5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRCdW5kbGUgPSBuZXcgSW50OEFycmF5KElTUy5OVU1CRVJfT0ZfRlJBR01FTlRfQ0hVTktTICogSVNTLk5VTUJFUl9PRl9TRUNVUklUWV9MRVZFTFMpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hTdHJpbmcgPSBidW5kbGVIYXNoLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggPSBoYXNoTGVuZ3RoIC8gSVNTLlRSWVRFX1dJRFRIIC8gSVNTLk5VTUJFUl9PRl9TRUNVUklUWV9MRVZFTFM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJU1MuTlVNQkVSX09GX1NFQ1VSSVRZX0xFVkVMUzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbGl6ZWRGcmFnbWVudExlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoQ2hhciA9IGhhc2hTdHJpbmcuY2hhckF0KGkgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhoYXNoQ2hhcikpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQnVuZGxlW2kgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIHN1bSArPSB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN1bSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3VtLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZEJ1bmRsZVtpICogbm9ybWFsaXplZEZyYWdtZW50TGVuZ3RoICsgal0gPiBJU1MuTUlOX1RSWVRFX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkQnVuZGxlW2kgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqXS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3VtKysgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZEJ1bmRsZVtpICogbm9ybWFsaXplZEZyYWdtZW50TGVuZ3RoICsgal0gPCBJU1MuTUFYX1RSWVRFX1ZBTFVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkQnVuZGxlW2kgKiBub3JtYWxpemVkRnJhZ21lbnRMZW5ndGggKyBqXSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRCdW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBzaWduYXR1cmUgZnJhZ21lbnRzIGZyb20gdGhlIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0gZXhwZWN0ZWRBZGRyZXNzIFRoZSBhZGRyZXNzLlxyXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMgVGhlIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50cy5cclxuICAgICAqIEBwYXJhbSBidW5kbGVIYXNoIFRoZSBoYXNoIGZvciB0aGUgYnVuZGxlLlxyXG4gICAgICogQHBhcmFtIHNwb25nZVR5cGUgVGhlIHNwb25nZSB0eXBlIHRvIHVzZSBmb3Igb3BlcmF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50IGFyZSBzaWduZWQgYnkgdGhlIGV4cGVjdGVkIGFkZHJlc3MuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB2YWxpZGF0ZVNpZ25hdHVyZXMoZXhwZWN0ZWRBZGRyZXNzLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCBidW5kbGVIYXNoLCBzcG9uZ2VUeXBlID0gXCJrZXJsXCIpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoZXhwZWN0ZWRBZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgZXhwZWN0ZWRBZGRyZXNzIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJ1bmRsZUhhc2gsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBidW5kbGVIYXNoIG11c3QgYmUgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuZXhpc3RzKHNwb25nZVR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBUaGUgc3BvbmdlVHlwZSBtdXN0IGJlIG9uZSBvZiBbJHtzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLnR5cGVzKCkuam9pbihcIiwgXCIpfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRCdW5kbGVIYXNoID0gSVNTLm5vcm1hbGl6ZWRCdW5kbGUoYnVuZGxlSGFzaCk7XHJcbiAgICAgICAgY29uc3Qgc3BvbmdlID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoc3BvbmdlVHlwZSk7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IHNwb25nZS5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIGZvciAobGV0IGYgPSAwOyBmIDwgMzsgZisrKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudHNbZl0gPSBub3JtYWxpemVkQnVuZGxlSGFzaC5zbGljZShmICogSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1MsIChmICsgMSkgKiBJU1MuTlVNQkVSX09GX0ZSQUdNRU5UX0NIVU5LUyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRpZ2VzdHMgPSBuZXcgSW50OEFycmF5KHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMubGVuZ3RoICogaGFzaExlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdEJ1ZmZlciA9IElTUy5kaWdlc3Qobm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50c1tpICUgM10sIHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzW2ldLnRvVHJ5dGVzKCkpLnRvQXJyYXkoKSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGFzaExlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBkaWdlc3RzW2kgKiBoYXNoTGVuZ3RoICsgal0gPSBkaWdlc3RCdWZmZXJbal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkQWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KElTUy5hZGRyZXNzKGRpZ2VzdHMpKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIHNpZ25lZCBzaWduYXR1cmUgbWVzc2FnZSBmcmFnbWVudC5cclxuICAgICAqIEBwYXJhbSBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnQgVGhlIGZyYWdtZW50IHRvIHNpZ24uXHJcbiAgICAgKiBAcGFyYW0ga2V5RnJhZ21lbnQgVGhlIGtleSBmcmFnbWVudCB0byBzaWduIHdpdGguXHJcbiAgICAgKiBAcGFyYW0gc3BvbmdlVHlwZSBUaGUgc3BvbmdlIHR5cGUgdG8gdXNlIGZvciBvcGVyYXRpb25zLlxyXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25lZCBmcmFnbWVudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudChub3JtYWxpemVkQnVuZGxlRnJhZ21lbnQsIGtleUZyYWdtZW50LCBzcG9uZ2VUeXBlID0gXCJrZXJsXCIpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUobm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50LCBJbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudCBtdXN0IGJlIG9mIHR5cGUgSW50OEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoa2V5RnJhZ21lbnQsIEludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUga2V5RnJhZ21lbnQgbXVzdCBiZSBvZiB0eXBlIEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmV4aXN0cyhzcG9uZ2VUeXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgVGhlIHNwb25nZVR5cGUgbXVzdCBiZSBvbmUgb2YgWyR7c3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS50eXBlcygpLmpvaW4oXCIsIFwiKX1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9IGtleUZyYWdtZW50LnNsaWNlKCk7XHJcbiAgICAgICAgbGV0IGhhc2g7XHJcbiAgICAgICAgY29uc3Qga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKHNwb25nZVR5cGUpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hMZW5ndGggPSBrZXJsLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGhhc2ggPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuc2xpY2UoaSAqIGhhc2hMZW5ndGgsIChpICsgMSkgKiBoYXNoTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAxMyAtIG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudFtpXTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBrZXJsLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIGtlcmwucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGtlcmwuYWJzb3JiKGhhc2gsIDAsIGhhc2hMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAga2VybC5zcXVlZXplKGhhc2gsIDAsIGhhc2hMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaGFzaExlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRbaSAqIGhhc2hMZW5ndGggKyBqXSA9IGhhc2hbal07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudDtcclxuICAgIH1cclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuSVNTLk5VTUJFUl9PRl9GUkFHTUVOVF9DSFVOS1MgPSAyNztcclxuLyogQGludGVybmFsICovXHJcbklTUy5OVU1CRVJfT0ZfU0VDVVJJVFlfTEVWRUxTID0gMztcclxuLyogQGludGVybmFsICovXHJcbklTUy5UUllURV9XSURUSCA9IDM7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5JU1MuTUlOX1RSWVRFX1ZBTFVFID0gLTEzO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuSVNTLk1BWF9UUllURV9WQUxVRSA9IDEzO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuSVNTLk1JTl9UUklUX1ZBTFVFID0gLTE7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5JU1MuTUFYX1RSSVRfVkFMVUUgPSAxO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuSVNTLlJBRElYID0gMztcclxuZXhwb3J0cy5JU1MgPSBJU1M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFYTnpMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyaGhjMmd2YVhOekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3d1JVRkJkVVU3UVVGRGRrVXNORVZCUVhsRk8wRkJRM3BGTERSRlFVRjVSVHRCUVVONlJTd3JSRUZCTkVRN1FVRkROVVFzSzBWQlFUUkZPMEZCUXpWRkxIbEVRVUZ6UkR0QlFVTjBSQ3hwUjBGQk9FWTdRVUZET1VZc01rUkJRWGRFTzBGQlEzaEVMRFpFUVVFd1JEdEJRVU14UkN4elJFRkJiVVE3UVVGRGJrUXNPRVJCUVRKRU8wRkJSVE5FT3pzN1IwRkhSenRCUVVOSU8wbEJhMEpKT3pzN096czdUMEZOUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlpTeEZRVUZGTEV0QlFXRXNSVUZCUlN4aFFVRnhRaXhSUVVGUk8xRkJReTlGTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNVMEZCVXl4RFFVRkRMRVZCUVVVN1dVRkRka01zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2IwTkJRVzlETEVOQlFVTXNRMEZCUXp0VFFVTXZSRHRSUVVWRUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeExRVUZMTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUXpkRExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRzFEUVVGdFF5eERRVUZETEVOQlFVTTdVMEZET1VRN1VVRkZSQ3hKUVVGSkxFTkJRVU1zTmtKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVWQlFVVTdXVUZET1VNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNhME5CUVd0RExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRUUVVNelJ6dFJRVVZFTEUxQlFVMHNUVUZCVFN4SFFVRkhMRFpDUVVGaExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xRkJRek5FTEUxQlFVMHNWVUZCVlN4SFFVRkhMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zWVVGQllTeERRVUZETEVOQlFVTTdVVUZEY2tRc1RVRkJUU3hEUVVGRExGVkJRVlVzUlVGQlJTeERRVUZETzFGQlJYQkNMRTFCUVUwc1pVRkJaU3hIUVVGSExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXp0UlFVTnlReXhKUVVGSkxGVkJRVlVzUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZGZGtJc1QwRkJUeXhWUVVGVkxFVkJRVVVzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZEY2tJc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMR1ZCUVdVc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdaMEpCUXpkRExFbEJRVWtzUlVGQlJTeGxRVUZsTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExHTkJRV01zUlVGQlJUdHZRa0ZETTBNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4alFVRmpMRU5CUVVNN2FVSkJRek5ETzNGQ1FVRk5PMjlDUVVOSUxFMUJRVTA3YVVKQlExUTdZVUZEU2p0VFFVTktPMUZCUlVRc1RVRkJUU3hQUVVGUExFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkZNVU1zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4bFFVRmxMRVZCUVVVc1EwRkJReXhGUVVGRkxHVkJRV1VzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTXhSQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRMRVZCUVVVc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlJUTkRMRTlCUVU4c1QwRkJUeXhEUVVGRE8wbEJRMjVDTEVOQlFVTTdTVUZGUkRzN096czdPenRQUVU5SE8wbEJRMGtzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRlZMRVZCUVVVc1MwRkJZU3hGUVVGRkxGRkJRWGxDTEVWQlFVVXNZVUZCY1VJc1RVRkJUVHRSUVVNdlJpeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeEZRVUZGTEZkQlFVa3NRMEZCUXl4RlFVRkZPMWxCUTJ4RExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMQ3RDUVVFclFpeERRVUZETEVOQlFVTTdVMEZETVVRN1VVRkZSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUzBGQlN5eEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTTNReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4dFEwRkJiVU1zUTBGQlF5eERRVUZETzFOQlF6bEVPMUZCUlVRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxGRkJRVkVzUjBGQlJ5eHBRMEZCWlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hSUVVGUkxFZEJRVWNzYVVOQlFXVXNRMEZCUXl4SlFVRkpMRVZCUVVVN1dVRkRlRWNzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc0swTkJRU3RETEVOQlFVTXNRMEZCUXp0VFFVTXhSVHRSUVVWRUxFbEJRVWtzUTBGQlF5dzJRa0ZCWVN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNSVUZCUlR0WlFVTTVReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4clEwRkJhME1zTmtKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xTkJRek5ITzFGQlJVUXNUVUZCVFN4VFFVRlRMRWRCUVVjc1lVRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVOd1JDeE5RVUZOTEZWQlFWVXNSMEZCUnl4aFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlF6TkRMRTFCUVUwc1QwRkJUeXhIUVVGSExHRkJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNVMEZCVXl4RlFVRkZMRlZCUVZVc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzFGQlF6TkVMRTFCUVUwc1lVRkJZU3hIUVVGSExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZGY2tNc1RVRkJUU3hOUVVGTkxFZEJRVWNzTmtKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTTdVVUZETTBRc1RVRkJUU3hWUVVGVkxFZEJRVWNzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVWeVJDeE5RVUZOTEVOQlFVTXNWVUZCVlN4RlFVRkZMRU5CUVVNN1VVRkRjRUlzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhGUVVGRkxHRkJRV0VzUTBGQlF5eERRVUZETzFGQlEzcERMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTXNSVUZCUlN4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVVeFF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1VVRkRaaXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRMRVZCUVVVc1lVRkJZU3hEUVVGRExFTkJRVU03VVVGRmVrTXNUVUZCVFN4SFFVRkhMRWRCUVVjc1NVRkJTU3hUUVVGVExFTkJRVU1zUjBGQlJ5eERRVUZETEhsQ1FVRjVRaXhIUVVGSExGVkJRVlVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCUXp0UlFVTnFSaXhKUVVGSkxFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZEWml4TlFVRk5MRTFCUVUwc1IwRkJSeXhKUVVGSkxGTkJRVk1zUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXp0UlFVTTFReXhKUVVGSkxGZEJRVmNzUjBGQlJ5eFJRVUZSTEVOQlFVTTdVVUZGTTBJc1QwRkJUeXhYUVVGWExFVkJRVVVzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZEZEVJc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJReXg1UWtGQmVVSXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRuUWtGRGNFUXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEdGQlFXRXNRMEZCUXl4RFFVRkRPMmRDUVVONlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVlVGQlZTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMjlDUVVOcVF5eEhRVUZITEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdhVUpCUXpkQ08yRkJRMG83VTBGRFNqdFJRVU5FTEU5QlFVOHNSMEZCUnl4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRnJRaXhGUVVGRkxHRkJRWEZDTEUxQlFVMDdVVUZEYWtVc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hUUVVGVExFTkJRVU1zUlVGQlJUdFpRVU14UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eDFRMEZCZFVNc1EwRkJReXhEUVVGRE8xTkJRMnhGTzFGQlJVUXNTVUZCU1N4RFFVRkRMRFpDUVVGaExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhGUVVGRk8xbEJRemxETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHdERRVUZyUXl3MlFrRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdVMEZETTBjN1VVRkZSQ3hOUVVGTkxFMUJRVTBzUjBGQlJ5dzJRa0ZCWVN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVTXpSQ3hOUVVGTkxGVkJRVlVzUjBGQlZ5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJRemRFTEUxQlFVMHNZMEZCWXl4SFFVRkhMRlZCUVZVc1IwRkJSeXhIUVVGSExFTkJRVU1zZVVKQlFYbENMRU5CUVVNN1VVRkZiRVVzU1VGQlNTeFBRVUZQTEVOQlFVTXNUVUZCVFN4SFFVRkhMR05CUVdNc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGRGRrTXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zTkVOQlFUUkRMR05CUVdNc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGRrWTdVVUZGUkN4TlFVRk5MRlZCUVZVc1IwRkJSeXhIUVVGSExFTkJRVU1zWlVGQlpTeEhRVUZITEVkQlFVY3NRMEZCUXl4bFFVRmxMRU5CUVVNN1VVRkZOMFFzVFVGQlRTeFRRVUZUTEVkQlFVY3NUMEZCVHl4RFFVRkRMRTFCUVUwc1IwRkJSeXhqUVVGakxFTkJRVU03VVVGRmJFUXNUVUZCVFN4UFFVRlBMRWRCUVVjc1NVRkJTU3hUUVVGVExFTkJRVU1zVTBGQlV5eEhRVUZITEZWQlFWVXNRMEZCUXl4RFFVRkRPMUZCUTNSRUxFbEJRVWtzVFVGQmFVSXNRMEZCUXp0UlFVVjBRaXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1UwRkJVeXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlEyaERMRTFCUVUwc1NVRkJTU3hIUVVGSExFTkJRVU1zUjBGQlJ5eGpRVUZqTEVOQlFVTTdXVUZEYUVNc1RVRkJUU3hYUVVGWExFZEJRVWNzVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hIUVVGSExHTkJRV01zUTBGQlF5eERRVUZETzFsQlJTOUVMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNc2VVSkJRWGxDTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1owSkJRM0JFTEUxQlFVMHNTVUZCU1N4SFFVRlhMRU5CUVVNc1IwRkJSeXhWUVVGVkxFTkJRVU03WjBKQlEzQkRMRTFCUVUwc1IwRkJSeXhYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRWRCUVVjc1ZVRkJWU3hEUVVGRExFTkJRVU03WjBKQlJYQkVMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4VlFVRlZMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3YjBKQlEycERMRTFCUVUwc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF6dHZRa0ZEWml4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yOUNRVU40UXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN2FVSkJRM3BETzJkQ1FVVkVMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4VlFVRlZMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3YjBKQlEycERMRmRCUVZjc1EwRkJReXhKUVVGSkxFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8ybENRVU55UXp0aFFVTktPMWxCUlVRc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzFsQlEyWXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhYUVVGWExFVkJRVVVzUTBGQlF5eEZRVUZGTEZkQlFWY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRaUVVOc1JDeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzVlVGQlZTeERRVUZETEVOQlFVTTdXVUZGZEVNc1RVRkJUU3hMUVVGTExFZEJRVWNzUTBGQlF5eEhRVUZITEZWQlFWVXNRMEZCUXp0WlFVTTNRaXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1ZVRkJWU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzJkQ1FVTnFReXhQUVVGUExFTkJRVU1zUzBGQlN5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dGhRVU5zUXp0VFFVTktPMUZCUTBRc1QwRkJUeXhQUVVGUExFTkJRVU03U1VGRGJrSXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZyUWl4RlFVRkZMR0ZCUVhGQ0xFMUJRVTA3VVVGRGFrVXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNSVUZCUlN4VFFVRlRMRU5CUVVNc1JVRkJSVHRaUVVNeFF5eE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXgxUTBGQmRVTXNRMEZCUXl4RFFVRkRPMU5CUTJ4Rk8xRkJSVVFzU1VGQlNTeERRVUZETERaQ1FVRmhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4RlFVRkZPMWxCUXpsRExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMR3REUVVGclF5dzJRa0ZCWVN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VTBGRE0wYzdVVUZGUkN4TlFVRk5MRTFCUVUwc1IwRkJSeXcyUWtGQllTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFJRVU16UkN4TlFVRk5MRlZCUVZVc1IwRkJSeXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRPMUZCUlhKRUxFbEJRVWtzVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4VlFVRlZMRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRMjVETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHbEVRVUZwUkN4VlFVRlZMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRM2hHTzFGQlJVUXNUVUZCVFN4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJRM0JDTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zUlVGQlJTeFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkZNVU1zVFVGQlRTeFpRVUZaTEVkQlFVY3NTVUZCU1N4VFFVRlRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGREwwTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhaUVVGWkxFVkJRVVVzUTBGQlF5eEZRVUZGTEZsQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVWeVJDeFBRVUZQTEZsQlFWa3NRMEZCUXp0SlFVTjRRaXhEUVVGRE8wbEJSVVE3T3pzN096dFBRVTFITzBsQlEwa3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXgzUWtGQmJVTXNSVUZCUlN4M1FrRkJiVU1zUlVGQlJTeGhRVUZ4UWl4TlFVRk5PMUZCUTNSSUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXgzUWtGQmQwSXNSVUZCUlN4VFFVRlRMRU5CUVVNc1JVRkJSVHRaUVVNelJDeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXgzUkVGQmQwUXNRMEZCUXl4RFFVRkRPMU5CUTI1R08xRkJSVVFzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExIZENRVUYzUWl4RlFVRkZMRk5CUVZNc1EwRkJReXhGUVVGRk8xbEJRek5FTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIZEVRVUYzUkN4RFFVRkRMRU5CUVVNN1UwRkRia1k3VVVGRlJDeEpRVUZKTEVOQlFVTXNOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRVZCUVVVN1dVRkRPVU1zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2EwTkJRV3RETERaQ1FVRmhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFRRVU16Unp0UlFVVkVMRWxCUVVrc1RVRkJhVUlzUTBGQlF6dFJRVVYwUWl4TlFVRk5MRTFCUVUwc1IwRkJSeXcyUWtGQllTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFJRVU16UkN4TlFVRk5MRlZCUVZVc1IwRkJSeXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRPMUZCUTNKRUxFMUJRVTBzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0UlFVVndRaXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExIbENRVUY1UWl4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRk8xbEJRM0JFTEUxQlFVMHNSMEZCUnl4SlFVRkpMRk5CUVZNc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhIUVVGSExGVkJRVlVzUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlJUZEdMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzZDBKQlFYZENMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUjBGQlJ5eERRVUZETEdWQlFXVXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzJkQ1FVTjRSU3hOUVVGTkxFOUJRVThzUjBGQlJ5dzJRa0ZCWVN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0blFrRkZOVVFzVDBGQlR5eERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMmRDUVVOeVFpeFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVONlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEZkQlFWY3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJReXhEUVVGRE8yRkJRMnhGTzFsQlJVUXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRUUVVNelF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE4wUXNUMEZCVHl4TlFVRk5MRU5CUVVNN1NVRkRiRUlzUTBGQlF6dEpRVVZFT3pzN096czdUMEZOUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zVDBGQmEwSXNSVUZCUlN4UlFVRjVRaXhGUVVGRkxHRkJRWEZDTEZGQlFWRTdVVUZEZEVjc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1JVRkJSU3hUUVVGVExFTkJRVU1zUlVGQlJUdFpRVU14UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eDFRMEZCZFVNc1EwRkJReXhEUVVGRE8xTkJRMnhGTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRkZCUVZFc1IwRkJSeXhwUTBGQlpTeERRVUZETEVkQlFVY3NTVUZCU1N4UlFVRlJMRWRCUVVjc2FVTkJRV1VzUTBGQlF5eEpRVUZKTEVWQlFVVTdXVUZEZUVjc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNLME5CUVN0RExFTkJRVU1zUTBGQlF6dFRRVU14UlR0UlFVVkVMRWxCUVVrc1EwRkJReXcyUWtGQllTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUlVGQlJUdFpRVU01UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHJRMEZCYTBNc05rSkJRV0VzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUXpOSE8xRkJSVVFzVFVGQlRTeEZRVUZGTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkRka1FzVFVGQlRTeEZRVUZGTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkRka1FzVFVGQlRTeEZRVUZGTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkRka1FzUlVGQlJTeERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMUZCUTJoQ0xFVkJRVVVzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0UlFVTm9RaXhGUVVGRkxFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTTdVVUZGYUVJc1RVRkJUU3hWUVVGVkxFZEJRVWNzUlVGQlJTeERRVUZETEZkQlFWY3NRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRSUVVOcVJDeE5RVUZOTEZOQlFWTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1ZVRkJWU3hIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhWUVVGVkxFTkJRVU03VVVGRk9VUXNUVUZCVFN4TlFVRk5MRWRCUVVjc1VVRkJVU3hIUVVGSExGTkJRVk1zUjBGQlJ5eFZRVUZWTEVOQlFVTTdVVUZEYWtRc1NVRkJTU3hIUVVGSExFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkZjRU1zUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhGUVVGRkxFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTjBReXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlF6ZENMRVZCUVVVc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTXNSVUZCUlN4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03V1VGRkwwSXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMR1ZCUVdVc1IwRkJSeXhIUVVGSExFTkJRVU1zWlVGQlpTeEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRk8yZENRVU4wUlN4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03WjBKQlExZ3NSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVUZGTEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRuUWtGRE9VSXNSMEZCUnl4SFFVRkhMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZMRlZCUVZVc1EwRkJReXhEUVVGRE8yRkJRelZETzFsQlJVUXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVUZGTEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRUUVVOcVF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkZMMElzVDBGQlR5eEhRVUZITEVOQlFVTTdTVUZEWml4RFFVRkRPMGxCUlVRN096czdPMDlCUzBjN1NVRkRTU3hOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1ZVRkJaMElzUlVGQlJTeGhRVUZ4UWl4UlFVRlJPMUZCUXpGRkxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVkxFVkJRVVVzVjBGQlNTeERRVUZETEVWQlFVVTdXVUZEZUVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNjVU5CUVhGRExFTkJRVU1zUTBGQlF6dFRRVU5vUlR0UlFVVkVMRWxCUVVrc1EwRkJReXcyUWtGQllTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUlVGQlJUdFpRVU01UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHJRMEZCYTBNc05rSkJRV0VzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUXpOSE8xRkJSVVFzVFVGQlRTeE5RVUZOTEVkQlFVY3NOa0pCUVdFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkRNMFFzVFVGQlRTeFZRVUZWTEVkQlFVY3NUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF6dFJRVVZ5UkN4TlFVRk5MR2RDUVVGblFpeEhRVUZITEVsQlFVa3NVMEZCVXl4RFFVRkRMRWRCUVVjc1EwRkJReXg1UWtGQmVVSXNSMEZCUnl4SFFVRkhMRU5CUVVNc2VVSkJRWGxDTEVOQlFVTXNRMEZCUXp0UlFVTjBSeXhOUVVGTkxGVkJRVlVzUjBGQlJ5eFZRVUZWTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRmNFUXNUVUZCVFN4M1FrRkJkMElzUjBGQlJ5eFZRVUZWTEVkQlFVY3NSMEZCUnl4RFFVRkRMRmRCUVZjc1IwRkJSeXhIUVVGSExFTkJRVU1zZVVKQlFYbENMRU5CUVVNN1VVRkZPVVlzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF5eDVRa0ZCZVVJc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVU53UkN4SlFVRkpMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRFdpeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzZDBKQlFYZENMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3WjBKQlF5OURMRTFCUVUwc1VVRkJVU3hIUVVGSExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4SFFVRkhMSGRDUVVGM1FpeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOeVJTeE5RVUZOTEVkQlFVY3NSMEZCUnl4aFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExHVkJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dG5Ra0ZEY2tVc1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4SFFVRkhMSGRDUVVGM1FpeEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJRenRuUWtGRGVrUXNSMEZCUnl4SlFVRkpMRWRCUVVjc1EwRkJRenRoUVVOa08xbEJSVVFzU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXl4RlFVRkZPMmRDUVVOV0xFOUJRVThzUjBGQlJ5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RlFVRkZPMjlDUVVOa0xFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXgzUWtGQmQwSXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHQzUWtGREwwTXNTVUZCU1N4blFrRkJaMElzUTBGQlF5eERRVUZETEVkQlFVY3NkMEpCUVhkQ0xFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRMR1ZCUVdVc1JVRkJSVHMwUWtGRE1VVXNaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eEhRVUZITEhkQ1FVRjNRaXhIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTTdORUpCUTNKRUxFMUJRVTA3ZVVKQlExUTdjVUpCUTBvN2FVSkJRMG83WVVGRFNqdHBRa0ZCVFR0blFrRkRTQ3hQUVVGUExFZEJRVWNzUlVGQlJTeEhRVUZITEVOQlFVTXNSVUZCUlR0dlFrRkRaQ3hMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc2QwSkJRWGRDTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN2QwSkJReTlETEVsQlFVa3NaMEpCUVdkQ0xFTkJRVU1zUTBGQlF5eEhRVUZITEhkQ1FVRjNRaXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVkQlFVY3NRMEZCUXl4bFFVRmxMRVZCUVVVN05FSkJRekZGTEdkQ1FVRm5RaXhEUVVGRExFTkJRVU1zUjBGQlJ5eDNRa0ZCZDBJc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZET3pSQ1FVTnlSQ3hOUVVGTk8zbENRVU5VTzNGQ1FVTktPMmxDUVVOS08yRkJRMG83VTBGRFNqdFJRVVZFTEU5QlFVOHNaMEpCUVdkQ0xFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVVkVPenM3T3pzN08wOUJUMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zWlVGQmQwSXNSVUZCUlN4NVFrRkJjVVFzUlVGQlJTeFZRVUZuUWl4RlFVRkZMR0ZCUVhGQ0xFMUJRVTA3VVVGRE0wb3NTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEdWQlFXVXNSVUZCUlN4cFFrRkJUeXhEUVVGRExFVkJRVVU3V1VGRGFFUXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zTUVOQlFUQkRMRU5CUVVNc1EwRkJRenRUUVVOeVJUdFJRVVZFTEVsQlFVa3NRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eDVRa0ZCZVVJc1JVRkJSU3h0UkVGQmQwSXNRMEZCUXl4RlFVRkZPMWxCUXpORkxFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMR2xHUVVGcFJpeERRVUZETEVOQlFVTTdVMEZETlVjN1VVRkZSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hGUVVGRkxGZEJRVWtzUTBGQlF5eEZRVUZGTzFsQlEzaERMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhGRFFVRnhReXhEUVVGRExFTkJRVU03VTBGRGFFVTdVVUZGUkN4SlFVRkpMRU5CUVVNc05rSkJRV0VzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFVkJRVVU3V1VGRE9VTXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zYTBOQlFXdERMRFpDUVVGaExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0VFFVTXpSenRSUVVWRUxFMUJRVTBzZVVKQlFYbENMRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJRM0pETEUxQlFVMHNiMEpCUVc5Q0xFZEJRVWNzUjBGQlJ5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFGQlJUbEVMRTFCUVUwc1RVRkJUU3hIUVVGSExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFGQlF6TkVMRTFCUVUwc1ZVRkJWU3hIUVVGSExFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1VVRkZja1FzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0WlFVTjRRaXg1UWtGQmVVSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXh2UWtGQmIwSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF5eDVRa0ZCZVVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNc2VVSkJRWGxDTEVOQlFVTXNRMEZCUXp0VFFVTjZTVHRSUVVWRUxFMUJRVTBzVDBGQlR5eEhRVUZITEVsQlFVa3NVMEZCVXl4RFFVRkRMSGxDUVVGNVFpeERRVUZETEUxQlFVMHNSMEZCUnl4VlFVRlZMRU5CUVVNc1EwRkJRenRSUVVVM1JTeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzZVVKQlFYbENMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlEzWkVMRTFCUVUwc1dVRkJXU3hIUVVGSExFZEJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNlVUpCUVhsQ0xFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMR0ZCUVVzc1EwRkJReXhWUVVGVkxFTkJRVU1zZVVKQlFYbENMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhEUVVGRE8xbEJSWFpKTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eFZRVUZWTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1owSkJRMnBETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1ZVRkJWU3hIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRoUVVOcVJEdFRRVU5LTzFGQlJVUXNUMEZCVHl4bFFVRmxMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEV0QlFVc3NZVUZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdTVUZEYWtnc1EwRkJRenRKUVVWRU96czdPenM3VDBGTlJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eDNRa0ZCYlVNc1JVRkJSU3hYUVVGelFpeEZRVUZGTEdGQlFYRkNMRTFCUVUwN1VVRkRNMGdzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExIZENRVUYzUWl4RlFVRkZMRk5CUVZNc1EwRkJReXhGUVVGRk8xbEJRek5FTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIZEVRVUYzUkN4RFFVRkRMRU5CUVVNN1UwRkRia1k3VVVGRFJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zVjBGQlZ5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RlFVRkZPMWxCUXpsRExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMREpEUVVFeVF5eERRVUZETEVOQlFVTTdVMEZEZEVVN1VVRkRSQ3hKUVVGSkxFTkJRVU1zTmtKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVWQlFVVTdXVUZET1VNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNhME5CUVd0RExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRUUVVNelJ6dFJRVVZFTEUxQlFVMHNkMEpCUVhkQ0xFZEJRVWNzVjBGQlZ5eERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRPMUZCUTNKRUxFbEJRVWtzU1VGQlpTeERRVUZETzFGQlJYQkNMRTFCUVUwc1NVRkJTU3hIUVVGSExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFGQlEzcEVMRTFCUVUwc1ZVRkJWU3hIUVVGSExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1VVRkZia1FzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFVkJRVVVzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0WlFVTjZRaXhKUVVGSkxFZEJRVWNzZDBKQlFYZENMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUjBGQlJ5eFZRVUZWTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFZEJRVWNzVlVGQlZTeERRVUZETEVOQlFVTTdXVUZGTlVVc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRVZCUVVVc1IwRkJSeXgzUWtGQmQwSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdG5Ra0ZEZGtRc1NVRkJTU3hEUVVGRExGVkJRVlVzUlVGQlJTeERRVUZETzJkQ1FVTnNRaXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdaMEpCUTJJc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4RlFVRkZMRlZCUVZVc1EwRkJReXhEUVVGRE8yZENRVU5xUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1lVRkRja003V1VGRlJDeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVlVGQlZTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMmRDUVVOcVF5eDNRa0ZCZDBJc1EwRkJReXhEUVVGRExFZEJRVWNzVlVGQlZTeEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dGhRVU14UkR0VFFVTktPMUZCUlVRc1QwRkJUeXgzUWtGQmQwSXNRMEZCUXp0SlFVTndReXhEUVVGRE96dEJRV3BqUkN4bFFVRmxPMEZCUTFNc05rSkJRWGxDTEVkQlFWY3NSVUZCUlN4RFFVRkRPMEZCUXk5RUxHVkJRV1U3UVVGRFV5dzJRa0ZCZVVJc1IwRkJWeXhEUVVGRExFTkJRVU03UVVGRE9VUXNaVUZCWlR0QlFVTlRMR1ZCUVZjc1IwRkJWeXhEUVVGRExFTkJRVU03UVVGRGFFUXNaVUZCWlR0QlFVTlRMRzFDUVVGbExFZEJRVmNzUTBGQlF5eEZRVUZGTEVOQlFVTTdRVUZEZEVRc1pVRkJaVHRCUVVOVExHMUNRVUZsTEVkQlFWY3NSVUZCUlN4RFFVRkRPMEZCUTNKRUxHVkJRV1U3UVVGRFV5eHJRa0ZCWXl4SFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRM0JFTEdWQlFXVTdRVUZEVXl4clFrRkJZeXhIUVVGWExFTkJRVU1zUTBGQlF6dEJRVU51UkN4bFFVRmxPMEZCUTFNc1UwRkJTeXhIUVVGWExFTkJRVU1zUTBGQlF6dEJRV2hDT1VNc2EwSkJiV05ESW4wPSIsInZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6aW1wb3J0LW5hbWVcclxuY29uc3QgYmlnX2ludGVnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnLWludGVnZXJcIikpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIHRvIGNvbnZlcnQgYmV0d2VlbiBCaWdJbnRlZ2VyIGFuZCBvdGhlciB0eXBlcy5cclxuICogQ29udmVydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaXJpL2Jsb2IvZGV2L3NyYy9tYWluL2phdmEvY29tL2lvdGEvaXJpL2hhc2gvS2VybC5qYXZhXHJcbiAqL1xyXG5jbGFzcyBCaWdJbnRlZ2VySGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0cml0cyB0byBhIGJpZ0ludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIGNvbnZlcnQuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCB3aXRoaW4gdGhlIGFycmF5IHRvIHN0YXJ0LlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSB0cml0cyBhcnJheSB0byBjb252ZXJ0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJpdHNUb0JpZ0ludGVnZXIodHJpdHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpIHx8IHRyaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSB0cml0cyBtdXN0IGJlIGEgbm9uIGVtcHR5IEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlciA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvZmZzZXQgKyBsZW5ndGggPiB0cml0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgb2Zmc2V0ICsgbGVuZ3RoIGlzIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZhbHVlID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0Lnplcm87XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubXVsdGlwbHkoQmlnSW50ZWdlckhlbHBlci5SQURJWCkuYWRkKGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCh0cml0c1tvZmZzZXQgKyBpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYmlnSW50ZWdlciB0byB0cml0cy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYmlnSW50ZWdlciB0byBjb252ZXJ0IHRvIHRyaXRzLlxyXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSBhcnJheSB0byByZWNlaXZlIHRoZSB0cml0cy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBwbGFjZSB0aGUgdHJpdHMgaW4gdGhlIGFycmF5LlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGJpZ0ludGVnZXJUb1RyaXRzKHZhbHVlLCB0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodmFsdWUsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdmFsdWUgbXVzdCBiZSBhIGJpZ0ludGVnZXIgdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHRyaXRzIG11c3QgYmUgYW4gSW50OEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIGxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyID4gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9mZnNldCArIGxlbmd0aCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYWJzb2x1dGVWYWx1ZSA9IHZhbHVlLmNvbXBhcmVUbyhiaWdfaW50ZWdlcl8xLmRlZmF1bHQuemVybykgPCAwID8gdmFsdWUubmVnYXRlKCkgOiB2YWx1ZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpdlJlbWFpbmRlciA9IGFic29sdXRlVmFsdWUuZGl2bW9kKEJpZ0ludGVnZXJIZWxwZXIuUkFESVgpO1xyXG4gICAgICAgICAgICBhYnNvbHV0ZVZhbHVlID0gZGl2UmVtYWluZGVyLnF1b3RpZW50O1xyXG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gZGl2UmVtYWluZGVyLnJlbWFpbmRlcjtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+IEJpZ0ludGVnZXJIZWxwZXIuTUFYX1RSSVRfVkFMVUUpIHtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmRlciA9IEJpZ0ludGVnZXJIZWxwZXIuTUlOX1RSSVRfVkFMVUU7XHJcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVZhbHVlID0gYWJzb2x1dGVWYWx1ZS5hZGQoYmlnX2ludGVnZXJfMS5kZWZhdWx0W1wiMVwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJpdHNbb2Zmc2V0ICsgaV0gPSByZW1haW5kZXIudG9KU051bWJlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUuY29tcGFyZVRvKGJpZ19pbnRlZ2VyXzEuZGVmYXVsdC56ZXJvKSA8IDApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgbmVnYXRpdmUgemVyb1xyXG4gICAgICAgICAgICAgICAgdHJpdHNbb2Zmc2V0ICsgaV0gPSB0cml0c1tvZmZzZXQgKyBpXSA9PT0gMCA/IDAgOiAtdHJpdHNbb2Zmc2V0ICsgaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIGJpZ0ludGVnZXIgaW50byBieXRlcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cclxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiBUaGUgZGVzdGluYXRpb24gYXJyYXkgdG8gc3RvcmUgdGhlIGJ5dGVzLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IHdpdGhpbiB0aGUgYXJyYXkgdG8gc3RvcmUgdGhlIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYmlnSW50ZWdlclRvQnl0ZXModmFsdWUsIGRlc3RpbmF0aW9uLCBvZmZzZXQpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodmFsdWUsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdmFsdWUgbXVzdCBiZSBhIGJpZ0ludGVnZXIgdHlwZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGRlc3RpbmF0aW9uLCBBcnJheUJ1ZmZlcikgfHwgZGVzdGluYXRpb24uYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBkZXN0aW5hdGlvbiBtdXN0IGJlIGFuIGFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXN0aW5hdGlvbi5ieXRlTGVuZ3RoIC0gb2Zmc2V0IDwgQmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBEZXN0aW5hdGlvbiBhcnJheSBoYXMgaW52YWxpZCBzaXplLCBpdCBtdXN0IGJlIGF0IGxlYXN0ICR7QmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1lbWJlciBpZiBpdCBpcyBuZWdhdGl2ZSBmb3IgbGF0ZXJcclxuICAgICAgICBjb25zdCBpc05lZyA9IHZhbHVlLmlzTmVnYXRpdmUoKSA/IC0xIDogMDtcclxuICAgICAgICBsZXQgaGV4U3RyaW5nID0gdmFsdWUudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIGlmIChpc05lZyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gQnV0IHJlbW92ZSBpdCBmb3Igbm93XHJcbiAgICAgICAgICAgIGhleFN0cmluZyA9IGhleFN0cmluZy5zbGljZSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IG1ha2Ugc3VyZSB0aGUgaGV4IHN0cmluZyBpcyBhbiBldmVuIGxlbmd0aCBzbyB0aGUgcmVnZXggd29ya3NcclxuICAgICAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIgPT09IDEpIHtcclxuICAgICAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtYXRjaGVzID0gaGV4U3RyaW5nLm1hdGNoKC9bMC05YS1mXXsyfS9nKTtcclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBoZXggdG8gbnVtYmVyc1xyXG4gICAgICAgIGNvbnN0IHNpZ25lZEJ5dGVzID0gbmV3IEludDhBcnJheShtYXRjaGVzXHJcbiAgICAgICAgICAgIC5tYXAoaGV4ID0+IHBhcnNlSW50KGAweCR7aGV4fWAsIDE2KSkpO1xyXG4gICAgICAgIGlmIChpc05lZyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgQmlnSW50ZWdlckhlbHBlci50d29zQ29tcGxlbWVudChzaWduZWRCeXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRlc3RpbmF0aW9uKTtcclxuICAgICAgICAvLyBQYWQgdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXIgd2l0aCB0aGUgbmVnIHZhbHVlXHJcbiAgICAgICAgbGV0IGkgPSBvZmZzZXQ7XHJcbiAgICAgICAgd2hpbGUgKGkgKyBzaWduZWRCeXRlcy5sZW5ndGggPCBCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEgpIHtcclxuICAgICAgICAgICAgZGF0YVZpZXcuc2V0SW50OChpKyssIGlzTmVnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQW5kIGNvcHkgaW4gdGhlIGFjdHVhbCBieXRlc1xyXG4gICAgICAgIGZvciAobGV0IGogPSBzaWduZWRCeXRlcy5sZW5ndGg7IGotLSA+IDA7KSB7XHJcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEludDgoaSsrLCBzaWduZWRCeXRlc1tzaWduZWRCeXRlcy5sZW5ndGggLSAxIC0gal0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBieXRlcyB0byBhIGJpZ0ludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2UgYnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgd2l0aGluIHRoZSBieXRlcyB0byBzdGFydCBjb252ZXJzaW9uLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBieXRlcyB0byB1c2UgZm9yIGNvbnZlcnNpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBieXRlc1RvQmlnSW50ZWdlcihzb3VyY2UsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNvdXJjZSwgQXJyYXlCdWZmZXIpIHx8IHNvdXJjZS5ieXRlTGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHNvdXJjZSBtdXN0IGJlIGEgbm9uIGVtcHR5IG51bWJlciBhcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlciA+IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzb3VyY2UuYnl0ZUxlbmd0aCAtIG9mZnNldCA8IEJpZ0ludGVnZXJIZWxwZXIuQllURV9IQVNIX0xFTkdUSCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihgU291cmNlIGFycmF5IGhhcyBpbnZhbGlkIHNpemUsIGl0IG11c3QgYmUgYXQgbGVhc3QgJHtCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZSk7XHJcbiAgICAgICAgbGV0IHNpZ25lZEJ5dGVzID0gbmV3IEludDhBcnJheShkYXRhVmlldy5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGRhdGFWaWV3LmJ5dGVMZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICBzaWduZWRCeXRlc1tiXSA9IGRhdGFWaWV3LmdldEludDgoYiArIG9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgaW5pdGlhbCBwYWRkaW5nIGxlYXZpbmcgYXQgbGVhc3Qgb25lIGJ5dGVcclxuICAgICAgICBsZXQgcGFkZGluZ09mZnNldCA9IDA7XHJcbiAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gc2lnbmVkQnl0ZXNbMF07XHJcbiAgICAgICAgY29uc3QgaXNOZWcgPSBmaXJzdEJ5dGUgPCAwO1xyXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBwYWRkaW5nIGNoYXJhY3RlciBpcyBuZWdhdGl2ZSB0aGVuIHJldmVyc2UgdGhlIDJzIGNvbXBsZW1lbnRcclxuICAgICAgICAvLyBidXQgZmlyc3Qgc3RyaXAgb2YgdGhlIGxlYWRpbmcgcGFkZGluZ1xyXG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDAgfHwgZmlyc3RCeXRlID09PSAtMSkge1xyXG4gICAgICAgICAgICB3aGlsZSAoc2lnbmVkQnl0ZXNbcGFkZGluZ09mZnNldF0gPT09IGZpcnN0Qnl0ZSAmJiBwYWRkaW5nT2Zmc2V0IDwgc2lnbmVkQnl0ZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgcGFkZGluZ09mZnNldCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFN0cmlwIGFueSBwYWRkaW5nXHJcbiAgICAgICAgICAgIHNpZ25lZEJ5dGVzID0gc2lnbmVkQnl0ZXMuc2xpY2UocGFkZGluZ09mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05lZykge1xyXG4gICAgICAgICAgICBCaWdJbnRlZ2VySGVscGVyLnR3b3NDb21wbGVtZW50KHNpZ25lZEJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhleFN0cmluZyA9IGlzTmVnID8gXCItXCIgOiBcIlwiO1xyXG4gICAgICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KHNpZ25lZEJ5dGVzLmJ1ZmZlcik7XHJcbiAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBkdi5ieXRlTGVuZ3RoOyBoKyspIHtcclxuICAgICAgICAgICAgaGV4U3RyaW5nICs9IGAwMCR7ZHYuZ2V0VWludDgoaCkudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmlnX2ludGVnZXJfMS5kZWZhdWx0KGhleFN0cmluZywgMTYpO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgdHdvc0NvbXBsZW1lbnQoc2lnbmVkQnl0ZXMpIHtcclxuICAgICAgICAvLyBpZiB0aGUgd2hvbGUgbnVtYmVyIGlzIG5lZ2F0aXZlIHRoZW5cclxuICAgICAgICAvLyBjaGFuZ2UgdG8gMidzIGNvbXBsZW1lbnRzIGJ5IG5vdGluZyBhbGwgdGhlIG51bWJlcnNcclxuICAgICAgICAvLyBhbmQgYWRkaW5nIDEgdG8gdGhlIGxhc3QgaS5lLiB+YmlnbnVtKzFcclxuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHNpZ25lZEJ5dGVzLmxlbmd0aDsgYisrKSB7XHJcbiAgICAgICAgICAgIHNpZ25lZEJ5dGVzW2JdID0gfnNpZ25lZEJ5dGVzW2JdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGQgMSB0byBsYXN0IG51bWJlciwgaWYgdGhlIG51bWJlciBpcyAweEZGIGNvbnRpbnVlIHRvIGNhcnJ5XHJcbiAgICAgICAgbGV0IGMgPSBzaWduZWRCeXRlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgc2lnbmVkQnl0ZXNbY10rKztcclxuICAgICAgICB9IHdoaWxlIChzaWduZWRCeXRlc1tjLS1dID09PSAwICYmIGMgPiAwKTtcclxuICAgIH1cclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuQmlnSW50ZWdlckhlbHBlci5SQURJWCA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCgzKTtcclxuLyogQGludGVybmFsICovXHJcbkJpZ0ludGVnZXJIZWxwZXIuTUFYX1RSSVRfVkFMVUUgPSBCaWdJbnRlZ2VySGVscGVyLlJBRElYLm1pbnVzKDEpLmRpdmlkZSgyKTtcclxuLyogQGludGVybmFsICovXHJcbkJpZ0ludGVnZXJIZWxwZXIuTUlOX1RSSVRfVkFMVUUgPSBCaWdJbnRlZ2VySGVscGVyLk1BWF9UUklUX1ZBTFVFLm5lZ2F0ZSgpO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuQmlnSW50ZWdlckhlbHBlci5CSVRfSEFTSF9MRU5HVEggPSAzODQ7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5CaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEggPSBCaWdJbnRlZ2VySGVscGVyLkJJVF9IQVNIX0xFTkdUSCAvIDg7XHJcbmV4cG9ydHMuQmlnSW50ZWdlckhlbHBlciA9IEJpZ0ludGVnZXJIZWxwZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVltbG5TVzUwWldkbGNraGxiSEJsY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlvWld4d1pYSnpMMkpwWjBsdWRHVm5aWEpJWld4d1pYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3T3p0QlFVRkJMRFJGUVVGNVJUdEJRVU42UlN3MFJVRkJlVVU3UVVGRGVrVXNkVU5CUVhWRE8wRkJRM1pETERoRVFVRnBRenRCUVVOcVF5eHpSRUZCYlVRN1FVRkZia1E3T3p0SFFVZEhPMEZCUTBnN1NVRmhTVHM3T3pzN1QwRkxSenRKUVVOSkxFMUJRVTBzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhMUVVGblFpeEZRVUZGTEUxQlFXTXNSVUZCUlN4TlFVRmpPMUZCUXpWRkxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFVkJRVVVzVTBGQlV5eERRVUZETEVsQlFVa3NTMEZCU3l4RFFVRkRMRTFCUVUwc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGRE9VUXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zZVVOQlFYbERMRU5CUVVNc1EwRkJRenRUUVVOd1JUdFJRVVZFTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJReTlETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHdERRVUZyUXl4RFFVRkRMRU5CUVVNN1UwRkROMFE3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NUVUZCVFN4SlFVRkpMRU5CUVVNc1JVRkJSVHRaUVVOb1JDeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhwUTBGQmFVTXNRMEZCUXl4RFFVRkRPMU5CUXpWRU8xRkJSVVFzU1VGQlNTeE5RVUZOTEVkQlFVY3NUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFVkJRVVU3V1VGRGFFTXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zZFVSQlFYVkVMRU5CUVVNc1EwRkJRenRUUVVOc1JqdFJRVVZFTEVsQlFVa3NTMEZCU3l4SFFVRkhMSEZDUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlJYaENMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlEyeERMRXRCUVVzc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4eFFrRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xTkJRMnBHTzFGQlJVUXNUMEZCVHl4TFFVRkxMRU5CUVVNN1NVRkRha0lzUTBGQlF6dEpRVVZFT3pzN096czdUMEZOUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4TFFVRjNRaXhGUVVGRkxFdEJRV2RDTEVWQlFVVXNUVUZCWXl4RlFVRkZMRTFCUVdNN1VVRkRkRWNzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeHhRa0ZCVFN4RFFVRkRMRVZCUVVVN1dVRkRja01zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2NVTkJRWEZETEVOQlFVTXNRMEZCUXp0VFFVTm9SVHRSUVVWRUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFVkJRVVVzVTBGQlV5eERRVUZETEVWQlFVVTdXVUZEZUVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNaME5CUVdkRExFTkJRVU1zUTBGQlF6dFRRVU16UkR0UlFVVkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlF5OURMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEd0RFFVRnJReXhEUVVGRExFTkJRVU03VTBGRE4wUTdVVUZGUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU5vUkN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHBRMEZCYVVNc1EwRkJReXhEUVVGRE8xTkJRelZFTzFGQlJVUXNTVUZCU1N4TlFVRk5MRWRCUVVjc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVTdXVUZEYUVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNkVVJCUVhWRUxFTkJRVU1zUTBGQlF6dFRRVU5zUmp0UlFVVkVMRWxCUVVrc1lVRkJZU3hIUVVGSExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNjVUpCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUlRsRkxFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdXVUZETjBJc1RVRkJUU3haUVVGWkxFZEJRVWNzWVVGQllTeERRVUZETEUxQlFVMHNRMEZCUXl4blFrRkJaMElzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0WlFVTnNSU3hoUVVGaExFZEJRVWNzV1VGQldTeERRVUZETEZGQlFWRXNRMEZCUXp0WlFVTjBReXhKUVVGSkxGTkJRVk1zUjBGQlJ5eFpRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRPMWxCUlhaRExFbEJRVWtzVTBGQlV5eEhRVUZITEdkQ1FVRm5RaXhEUVVGRExHTkJRV01zUlVGQlJUdG5Ra0ZETjBNc1UwRkJVeXhIUVVGSExHZENRVUZuUWl4RFFVRkRMR05CUVdNc1EwRkJRenRuUWtGRE5VTXNZVUZCWVN4SFFVRkhMR0ZCUVdFc1EwRkJReXhIUVVGSExFTkJRVU1zY1VKQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8yRkJRMnhFTzFsQlEwUXNTMEZCU3l4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eFRRVUZUTEVOQlFVTXNWVUZCVlN4RlFVRkZMRU5CUVVNN1UwRkRPVU03VVVGRlJDeEpRVUZKTEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc2NVSkJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVN1dVRkRiRU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0blFrRkROMElzYzBKQlFYTkNPMmRDUVVOMFFpeExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0aFFVTjRSVHRUUVVOS08wbEJRMHdzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMR2xDUVVGcFFpeERRVUZETEV0QlFYZENMRVZCUVVVc1YwRkJkMElzUlVGQlJTeE5RVUZqTzFGQlF6bEdMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc2NVSkJRVTBzUTBGQlF5eEZRVUZGTzFsQlEzSkRMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhGRFFVRnhReXhEUVVGRExFTkJRVU03VTBGRGFFVTdVVUZGUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RlFVRkZMRmRCUVZjc1EwRkJReXhKUVVGSkxGZEJRVmNzUTBGQlF5eFZRVUZWTEV0QlFVc3NRMEZCUXl4RlFVRkZPMWxCUTJoR0xFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMR3REUVVGclF5eERRVUZETEVOQlFVTTdVMEZETjBRN1VVRkZSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTXZReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4clEwRkJhME1zUTBGQlF5eERRVUZETzFOQlF6ZEVPMUZCUlVRc1NVRkJTU3hYUVVGWExFTkJRVU1zVlVGQlZTeEhRVUZITEUxQlFVMHNSMEZCUnl4blFrRkJaMElzUTBGQlF5eG5Ra0ZCWjBJc1JVRkJSVHRaUVVOeVJTeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXd5UkVGQk1rUXNaMEpCUVdkQ0xFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRM3BJTzFGQlJVUXNkVU5CUVhWRE8xRkJRM1pETEUxQlFVMHNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVVV4UXl4SlFVRkpMRk5CUVZNc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUlc1RExFbEJRVWtzUzBGQlN5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZPMWxCUTJRc2QwSkJRWGRDTzFsQlEzaENMRk5CUVZNc1IwRkJSeXhUUVVGVExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTJ4RE8xRkJRMFFzYjBWQlFXOUZPMUZCUTNCRkxFbEJRVWtzVTBGQlV5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRelZDTEZOQlFWTXNSMEZCUnl4SlFVRkpMRk5CUVZNc1JVRkJSU3hEUVVGRE8xTkJReTlDTzFGQlEwUXNUVUZCVFN4UFFVRlBMRWRCUVVjc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTXNRMEZCUXp0UlFVVm9SQ3cyUWtGQk5rSTdVVUZETjBJc1RVRkJUU3hYUVVGWExFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNUMEZCVHp0aFFVTndReXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhIUVVGSExFVkJRVVVzUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkZNME1zU1VGQlNTeExRVUZMTEV0QlFVc3NRMEZCUXl4RFFVRkRMRVZCUVVVN1dVRkRaQ3huUWtGQlowSXNRMEZCUXl4alFVRmpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03VTBGRGFFUTdVVUZGUkN4TlFVRk5MRkZCUVZFc1IwRkJSeXhKUVVGSkxGRkJRVkVzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXp0UlFVVXpReXhwUkVGQmFVUTdVVUZEYWtRc1NVRkJTU3hEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETzFGQlEyWXNUMEZCVHl4RFFVRkRMRWRCUVVjc1YwRkJWeXhEUVVGRExFMUJRVTBzUjBGQlJ5eG5Ra0ZCWjBJc1EwRkJReXhuUWtGQlowSXNSVUZCUlR0WlFVTXZSQ3hSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNSVUZCUlN4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8xTkJRMmhETzFGQlEwUXNLMEpCUVN0Q08xRkJReTlDTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1YwRkJWeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSMEZCUnl4RFFVRkRMRWRCUVVjN1dVRkRka01zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRVZCUVVVc1JVRkJSU3hYUVVGWExFTkJRVU1zVjBGQlZ5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFRRVU5zUlR0SlFVTk1MRU5CUVVNN1NVRkZSRHM3T3pzN1QwRkxSenRKUVVOSkxFMUJRVTBzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhOUVVGdFFpeEZRVUZGTEUxQlFXTXNSVUZCUlN4TlFVRmpPMUZCUXk5RkxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzVjBGQlZ5eERRVUZETEVsQlFVa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGRGRFVXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zTmtOQlFUWkRMRU5CUVVNc1EwRkJRenRUUVVONFJUdFJRVVZFTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJReTlETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExHdERRVUZyUXl4RFFVRkRMRU5CUVVNN1UwRkROMFE3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NUVUZCVFN4SlFVRkpMRU5CUVVNc1JVRkJSVHRaUVVOb1JDeE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhwUTBGQmFVTXNRMEZCUXl4RFFVRkRPMU5CUXpWRU8xRkJSVVFzU1VGQlNTeE5RVUZOTEVOQlFVTXNWVUZCVlN4SFFVRkhMRTFCUVUwc1IwRkJSeXhuUWtGQlowSXNRMEZCUXl4blFrRkJaMElzUlVGQlJUdFpRVU5vUlN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHpSRUZCYzBRc1owSkJRV2RDTEVOQlFVTXNaMEpCUVdkQ0xFVkJRVVVzUTBGQlF5eERRVUZETzFOQlEzQklPMUZCUlVRc1RVRkJUU3hSUVVGUkxFZEJRVWNzU1VGQlNTeFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkZkRU1zU1VGQlNTeFhRVUZYTEVkQlFVY3NTVUZCU1N4VFFVRlRMRU5CUVVNc1VVRkJVU3hEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFGQlEzSkVMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4UlFVRlJMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlF6RkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zUTBGQlF6dFRRVU5xUkR0UlFVVkVMSFZFUVVGMVJEdFJRVU4yUkN4SlFVRkpMR0ZCUVdFc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGRFSXNUVUZCVFN4VFFVRlRMRWRCUVVjc1YwRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEycERMRTFCUVUwc1MwRkJTeXhIUVVGSExGTkJRVk1zUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZGTlVJc05FVkJRVFJGTzFGQlF6VkZMSGxEUVVGNVF6dFJRVU42UXl4SlFVRkpMRk5CUVZNc1MwRkJTeXhEUVVGRExFbEJRVWtzVTBGQlV5eExRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZPMWxCUTNKRExFOUJRVThzVjBGQlZ5eERRVUZETEdGQlFXRXNRMEZCUXl4TFFVRkxMRk5CUVZNc1NVRkJTU3hoUVVGaExFZEJRVWNzVjBGQlZ5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRVZCUVVVN1owSkJRM1pHTEdGQlFXRXNSVUZCUlN4RFFVRkRPMkZCUTI1Q08xbEJRMFFzYjBKQlFXOUNPMWxCUTNCQ0xGZEJRVmNzUjBGQlJ5eFhRVUZYTEVOQlFVTXNTMEZCU3l4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8xTkJRMnhFTzFGQlJVUXNTVUZCU1N4TFFVRkxMRVZCUVVVN1dVRkRVQ3huUWtGQlowSXNRMEZCUXl4alFVRmpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03VTBGRGFFUTdVVUZGUkN4SlFVRkpMRk5CUVZNc1IwRkJSeXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRE8xRkJRMnBETEUxQlFVMHNSVUZCUlN4SFFVRkhMRWxCUVVrc1VVRkJVU3hEUVVGRExGZEJRVmNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTTFReXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExGVkJRVlVzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0WlFVTndReXhUUVVGVExFbEJRVWtzUzBGQlN5eEZRVUZGTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFOQlF6ZEVPMUZCUlVRc1QwRkJUeXh4UWtGQlRTeERRVUZETEZOQlFWTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVOcVF5eERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRTFCUVUwc1EwRkJReXhqUVVGakxFTkJRVU1zVjBGQmMwSTdVVUZEYUVRc2RVTkJRWFZETzFGQlEzWkRMSE5FUVVGelJEdFJRVU4wUkN3d1EwRkJNRU03VVVGRE1VTXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEZkQlFWY3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3V1VGRGVrTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTNCRE8xRkJRMFFzWjBWQlFXZEZPMUZCUTJoRkxFbEJRVWtzUTBGQlF5eEhRVUZITEZkQlFWY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJReTlDTEVkQlFVYzdXVUZEUXl4WFFVRlhMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF6dFRRVU53UWl4UlFVRlJMRmRCUVZjc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRk8wbEJRemxETEVOQlFVTTdPMEZCYUU5RUxHVkJRV1U3UVVGRFV5eHpRa0ZCU3l4SFFVRnpRaXh4UWtGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUXpkRUxHVkJRV1U3UVVGRFV5d3JRa0ZCWXl4SFFVRnpRaXhuUWtGQlowSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVOMFJ5eGxRVUZsTzBGQlExTXNLMEpCUVdNc1IwRkJjMElzWjBKQlFXZENMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETzBGQlJYSkhMR1ZCUVdVN1FVRkRVeXhuUTBGQlpTeEhRVUZYTEVkQlFVY3NRMEZCUXp0QlFVTjBSQ3hsUVVGbE8wRkJRMU1zYVVOQlFXZENMRWRCUVZjc1owSkJRV2RDTEVOQlFVTXNaVUZCWlN4SFFVRkhMRU5CUVVNc1EwRkJRenRCUVZnMVJpdzBRMEZyVDBNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9oYXNoXCIpO1xyXG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb25cIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0c1wiKTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9jcnlwdG9FcnJvclwiKTtcclxuY29uc3Qgc3BvbmdlRmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5XCIpO1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciB0cmFuc2FjdGlvbnMuXHJcbiAqIENvbnZlcnRlZCBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pb3RhLmxpYi5qcy9ibG9iL21hc3Rlci9saWIvY3J5cHRvL3NpZ25pbmcvc2lnbmluZy5qc1xyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb25IZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGhlIGhhc2ggZm9yIGEgdHJhbnNhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIHRvIGdlbmVyYXRlIHRoZSBoYXNoLlxyXG4gICAgICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhyIHRyYW5zYWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzaCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb24gbXVzdCBiZSBvZiB0eXBlIFRyYW5zYWN0aW9uXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXCJjdXJsXCIpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uVHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXModHJhbnNhY3Rpb24udG9Ucnl0ZXMoKSkudG9BcnJheSgpO1xyXG4gICAgICAgIGN1cmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIGN1cmwuYWJzb3JiKHRyYW5zYWN0aW9uVHJpdHMsIDAsIHRyYW5zYWN0aW9uVHJpdHMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBoYXNoVHJpdHMgPSBuZXcgSW50OEFycmF5KGN1cmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKSk7XHJcbiAgICAgICAgY3VybC5zcXVlZXplKGhhc2hUcml0cywgMCwgaGFzaFRyaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoaGFzaFRyaXRzKS50b1RyeXRlcygpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRyYW5zYWN0aW9uSGVscGVyID0gVHJhbnNhY3Rpb25IZWxwZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISmhibk5oWTNScGIyNUlaV3h3WlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YUdWc2NHVnljeTkwY21GdWMyRmpkR2x2YmtobGJIQmxjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNORVZCUVhsRk8wRkJRM3BGTEhsRVFVRnpSRHRCUVVOMFJDeDFSVUZCYjBVN1FVRkRjRVVzTWtSQlFYZEVPMEZCUTNoRUxITkVRVUZ0UkR0QlFVTnVSQ3c0UkVGQk1rUTdRVUZGTTBRN096dEhRVWRITzBGQlEwZzdTVUZEU1RzN096dFBRVWxITzBsQlEwa3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGM1FqdFJRVU4yUXl4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RlFVRkZMSGxDUVVGWExFTkJRVU1zUlVGQlJUdFpRVU5vUkN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5dzJRMEZCTmtNc1EwRkJReXhEUVVGRE8xTkJRM2hGTzFGQlJVUXNUVUZCVFN4SlFVRkpMRWRCUVVjc05rSkJRV0VzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRGNrUXNUVUZCVFN4blFrRkJaMElzUjBGQlJ5eGhRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRmRCUVZjc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMUZCUlRWRkxFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXp0UlFVTnNRaXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxFTkJRVU1zUlVGQlJTeG5Ra0ZCWjBJc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVVV4UkN4TlFVRk5MRk5CUVZNc1IwRkJSeXhKUVVGSkxGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFrVXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF5eEZRVUZGTEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVVM1F5eFBRVUZQTEZkQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1lVRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJRMnhGTEVOQlFVTTdRMEZEU2p0QlFYUkNSQ3c0UTBGelFrTWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGNyeXB0b0Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvY3J5cHRvRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBJU3BvbmdlIHVzaW5nIEN1cmwgYWxnb3JpdGhtLlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pb3RhLmxpYi5qcy9ibG9iL21hc3Rlci9saWIvY3J5cHRvL2N1cmwvY3VybC5qc1xyXG4gKi9cclxuY2xhc3MgQ3VybCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBDdXJsLlxyXG4gICAgICogQHBhcmFtIHJvdW5kcyBUaGUgbnVtYmVyIG9mIHJvdW5kcyB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJvdW5kcyA9IEN1cmwuTlVNQkVSX09GX1JPVU5EUykge1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mUm91bmRzID0gcm91bmRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNvbnN0YW50IGZvciB0aGUgc3BvbmUuXHJcbiAgICAgKiBAbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udGFudCB0byBnZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIGdldENvbnN0YW50KG5hbWUpIHtcclxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSBcIk5VTUJFUl9PRl9ST1VORFNcIjoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX251bWJlck9mUm91bmRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJIQVNIX0xFTkdUSFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiU1RBVEVfTEVOR1RIXCI6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEN1cmxbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBVbmtub3duIGNvbnN0YW50IHJlcXVlc3RlZCAke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0YXRlLlxyXG4gICAgICogQHJldHVybnMgVGhlIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBnZXRTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpc2UgdGhlIGhhc2hlci5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgaW5pdGlhbCBzdGF0ZSBmb3IgdGhlIGhhc2hlci5cclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZShzdGF0ZSkge1xyXG4gICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgSW50OEFycmF5KEN1cmwuU1RBVEVfTEVOR1RIKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBoYXNoZXIuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvcmIgdHJpdHMgaW50byB0aGUgaGFzaC5cclxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgdHJpdHMgdG8gYWJzb3JiLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIHRyaXRzIHRvIGFic29yYiBmcm9tLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbnVtYmVyIG9mIHRyaXRzIHRvIGFic29yYi5cclxuICAgICAqL1xyXG4gICAgYWJzb3JiKHRyaXRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cml0cywgSW50OEFycmF5KSB8fCB0cml0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUcml0cyBtdXN0IGJlIGEgbm9uIGVtcHR5IEludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIk9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJMZW5ndGggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICsgb2Zmc2V0ID4gdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIG9mZnNldCArIGxlbmd0aCBpcyBiZXlvbmQgdGhlIGxlbmd0aCBvZiB0aGUgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2NhbE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICBsZXQgbG9jYWxMZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gbG9jYWxMZW5ndGggPCBDdXJsLkhBU0hfTEVOR1RIID8gbG9jYWxMZW5ndGggOiBDdXJsLkhBU0hfTEVOR1RIO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVtpKytdID0gdHJpdHNbbG9jYWxPZmZzZXQrK107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgbG9jYWxMZW5ndGggLT0gQ3VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICB9IHdoaWxlIChsb2NhbExlbmd0aCA+IDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTcXVlZXplIHRyaXRzIGludG8gdGhlIGhhc2guXHJcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIHNxdWVlemUuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgaW50byB0aGUgdHJpdHMgdG8gc3F1ZWV6ZSBmcm9tLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbnVtYmVyIG9mIHRyaXRzIHRvIHNxdWVlemUuXHJcbiAgICAgKi9cclxuICAgIHNxdWVlemUodHJpdHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpIHx8IHRyaXRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRyaXRzIG11c3QgYmUgYSBub24gZW1wdHkgSW50OEFycmF5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiT2Zmc2V0IG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIkxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPiB0cml0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgb2Zmc2V0ICsgbGVuZ3RoIGlzIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSB0cml0c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvY2FsT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGxldCBsb2NhbExlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgY29uc3QgbGltaXQgPSBsb2NhbExlbmd0aCA8IEN1cmwuSEFTSF9MRU5HVEggPyBsZW5ndGggOiBDdXJsLkhBU0hfTEVOR1RIO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICB0cml0c1tsb2NhbE9mZnNldCsrXSA9IHRoaXMuX3N0YXRlW2krK107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgbG9jYWxMZW5ndGggLT0gQ3VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICB9IHdoaWxlIChsb2NhbExlbmd0aCA+IDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIGhhc2guXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdHJhbnNmb3JtKCkge1xyXG4gICAgICAgIGxldCBzdGF0ZUNvcHk7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCByb3VuZCA9IDA7IHJvdW5kIDwgdGhpcy5fbnVtYmVyT2ZSb3VuZHM7IHJvdW5kKyspIHtcclxuICAgICAgICAgICAgc3RhdGVDb3B5ID0gbmV3IEludDhBcnJheSh0aGlzLl9zdGF0ZS5zbGljZSgpKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDdXJsLlNUQVRFX0xFTkdUSDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZVtpXSA9IEN1cmwuVFJVVEhfVEFCTEVbc3RhdGVDb3B5W2luZGV4XSArIChzdGF0ZUNvcHlbaW5kZXggKz0gKGluZGV4IDwgMzY1ID8gMzY0IDogLTM2NSldIDw8IDIpICsgNV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuQ3VybC5IQVNIX0xFTkdUSCA9IDI0MztcclxuQ3VybC5OVU1CRVJfT0ZfUk9VTkRTID0gODE7XHJcbkN1cmwuU1RBVEVfTEVOR1RIID0gQ3VybC5IQVNIX0xFTkdUSCAqIDM7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5DdXJsLlRSVVRIX1RBQkxFID0gbmV3IEludDhBcnJheShbMSwgMCwgLTEsIDIsIDEsIC0xLCAwLCAyLCAtMSwgMSwgMF0pO1xyXG5leHBvcnRzLkN1cmwgPSBDdXJsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZM1Z5YkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl6Y0c5dVoyVnpMMk4xY213dWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTERSRlFVRjVSVHRCUVVONlJTdzBSVUZCZVVVN1FVRkRla1VzYzBSQlFXMUVPMEZCUjI1RU96czdSMEZIUnp0QlFVTklPMGxCWVVrN096dFBRVWRITzBsQlEwZ3NXVUZCV1N4VFFVRnBRaXhKUVVGSkxFTkJRVU1zWjBKQlFXZENPMUZCUXpsRExFbEJRVWtzUTBGQlF5eGxRVUZsTEVkQlFVY3NUVUZCVFN4RFFVRkRPMGxCUTJ4RExFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzVjBGQlZ5eERRVUZETEVsQlFWazdVVUZETTBJc1VVRkJVU3hKUVVGSkxFVkJRVVU3V1VGRFZpeExRVUZMTEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03WjBKQlEzSkNMRTlCUVU4c1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF6dGhRVU12UWp0WlFVTkVMRXRCUVVzc1lVRkJZU3hEUVVGRE8xbEJRMjVDTEV0QlFVc3NZMEZCWXp0blFrRkRia0k3YjBKQlEwa3NUMEZCVHl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YVVKQlEzSkNPMWxCUTBRc1QwRkJUeXhEUVVGRExFTkJRVU1zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc09FSkJRVGhDTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRlRVU3U1VGRFRDeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVVVGQlVUdFJRVU5ZTEU5QlFVOHNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVOMlFpeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVlVGQlZTeERRVUZETEV0QlFXbENPMUZCUXk5Q0xFbEJRVWtzUzBGQlN5eEZRVUZGTzFsQlExQXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhMUVVGTExFTkJRVU03VTBGRGRrSTdZVUZCVFR0WlFVTklMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRE8xTkJRMnhFTzBsQlEwd3NRMEZCUXp0SlFVVkVPenRQUVVWSE8wbEJRMGtzUzBGQlN6dFJRVU5TTEVsQlFVa3NRMEZCUXl4VlFVRlZMRVZCUVVVc1EwRkJRenRKUVVOMFFpeERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1MwRkJaMElzUlVGQlJTeE5RVUZqTEVWQlFVVXNUVUZCWXp0UlFVTXhSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxGTkJRVk1zUTBGQlF5eEpRVUZKTEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRemxFTEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIRkRRVUZ4UXl4RFFVRkRMRU5CUVVNN1UwRkRhRVU3VVVGRFJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NUVUZCVFN4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVNdlF5eE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXc0UWtGQk9FSXNRMEZCUXl4RFFVRkRPMU5CUTNwRU8xRkJRMFFzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEUxQlFVMHNSMEZCUnl4RFFVRkRMRVZCUVVVN1dVRkRMME1zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc09FSkJRVGhDTEVOQlFVTXNRMEZCUXp0VFFVTjZSRHRSUVVORUxFbEJRVWtzVFVGQlRTeEhRVUZITEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNc1RVRkJUU3hGUVVGRk8xbEJRMmhETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExIVkVRVUYxUkN4RFFVRkRMRU5CUVVNN1UwRkRiRVk3VVVGRlJDeEpRVUZKTEZkQlFWY3NSMEZCUnl4TlFVRk5MRU5CUVVNN1VVRkRla0lzU1VGQlNTeFhRVUZYTEVkQlFVY3NUVUZCVFN4RFFVRkRPMUZCUlhwQ0xFZEJRVWM3V1VGRFF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkRWaXhOUVVGTkxFdEJRVXNzUjBGQlJ5eFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRE8xbEJSVGxGTEU5QlFVOHNRMEZCUXl4SFFVRkhMRXRCUVVzc1JVRkJSVHRuUWtGRFpDeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEZkQlFWY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1lVRkRNME03V1VGRlJDeEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1dVRkZha0lzVjBGQlZ5eEpRVUZKTEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNN1UwRkRia01zVVVGQlVTeFhRVUZYTEVkQlFVY3NRMEZCUXl4RlFVRkZPMGxCUXpsQ0xFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5KTEU5QlFVOHNRMEZCUXl4TFFVRm5RaXhGUVVGRkxFMUJRV01zUlVGQlJTeE5RVUZqTzFGQlF6TkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1UwRkJVeXhEUVVGRExFbEJRVWtzUzBGQlN5eERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRVZCUVVVN1dVRkRPVVFzVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2NVTkJRWEZETEVOQlFVTXNRMEZCUXp0VFFVTm9SVHRSUVVORUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeE5RVUZOTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUXk5RExFMUJRVTBzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRGhDUVVFNFFpeERRVUZETEVOQlFVTTdVMEZEZWtRN1VVRkRSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTXZReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3NFFrRkJPRUlzUTBGQlF5eERRVUZETzFOQlEzcEVPMUZCUTBRc1NVRkJTU3hOUVVGTkxFZEJRVWNzVFVGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4TlFVRk5MRVZCUVVVN1dVRkRhRU1zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2RVUkJRWFZFTEVOQlFVTXNRMEZCUXp0VFFVTnNSanRSUVVWRUxFbEJRVWtzVjBGQlZ5eEhRVUZITEUxQlFVMHNRMEZCUXp0UlFVTjZRaXhKUVVGSkxGZEJRVmNzUjBGQlJ5eE5RVUZOTEVOQlFVTTdVVUZGZWtJc1IwRkJSenRaUVVWRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTldMRTFCUVUwc1MwRkJTeXhIUVVGSExGZEJRVmNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRU5CUVVNN1dVRkZla1VzVDBGQlR5eERRVUZETEVkQlFVY3NTMEZCU3l4RlFVRkZPMmRDUVVOa0xFdEJRVXNzUTBGQlF5eFhRVUZYTEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0aFFVTXpRenRaUVVWRUxFbEJRVWtzUTBGQlF5eFRRVUZUTEVWQlFVVXNRMEZCUXp0WlFVVnFRaXhYUVVGWExFbEJRVWtzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXp0VFFVTnVReXhSUVVGUkxGZEJRVmNzUjBGQlJ5eERRVUZETEVWQlFVVTdTVUZET1VJc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkxMRk5CUVZNN1VVRkRZaXhKUVVGSkxGTkJRVzlDTEVOQlFVTTdVVUZEZWtJc1NVRkJTU3hMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETzFGQlJXUXNTMEZCU3l4SlFVRkpMRXRCUVVzc1IwRkJSeXhEUVVGRExFVkJRVVVzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXl4bFFVRmxMRVZCUVVVc1MwRkJTeXhGUVVGRkxFVkJRVVU3V1VGRGRrUXNVMEZCVXl4SFFVRkhMRWxCUVVrc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJRenRaUVVVdlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEZsQlFWa3NSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRuUWtGRmVFTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEZOQlFWTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhMUVVGTExFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dGhRVU51U0R0VFFVTktPMGxCUTB3c1EwRkJRenM3UVVFM1NuTkNMR2RDUVVGWExFZEJRVmNzUjBGQlJ5eERRVUZETzBGQlF6RkNMSEZDUVVGblFpeEhRVUZYTEVWQlFVVXNRMEZCUXp0QlFVTTVRaXhwUWtGQldTeEhRVUZYTEVsQlFVa3NRMEZCUXl4WFFVRlhMRWRCUVVjc1EwRkJReXhEUVVGRE8wRkJSVzVGTEdWQlFXVTdRVUZEVXl4blFrRkJWeXhIUVVGakxFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdRVUZPZWtjc2IwSkJLMHBESW4wPSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiLi4vZGlnZXN0cy9zaGEzXCIpO1xyXG5jb25zdCBjcnlwdG9FcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCBiaWdJbnRlZ2VySGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9iaWdJbnRlZ2VySGVscGVyXCIpO1xyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgSVNwb25nZSB1c2luZyBLZXJsIGFsZ29yaXRobS5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaXJpL2Jsb2IvZGV2L3NyYy9tYWluL2phdmEvY29tL2lvdGEvaXJpL2hhc2gvS2VybC5qYXZhXHJcbiAqL1xyXG5jbGFzcyBLZXJsIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEtlcmwuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2tlY2NhayA9IG5ldyBzaGEzXzEuU2hhMygzODQsIHNoYTNfMS5TaGEzLktFQ0NBS19QQURESU5HLCAzODQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNvbnN0YW50IGZvciB0aGUgc3BvbmUuXHJcbiAgICAgKiBAbmFtZSBUaGUgbmFtZSBvZiB0aGUgY29udGFudCB0byBnZXQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RhbnQuXHJcbiAgICAgKi9cclxuICAgIGdldENvbnN0YW50KG5hbWUpIHtcclxuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkhBU0hfTEVOR1RIXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJCSVRfSEFTSF9MRU5HVEhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkJZVEVfSEFTSF9MRU5HVEhcIjpcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gS2VybFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoYFVua25vd24gY29uc3RhbnQgcmVxdWVzdGVkICR7bmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGdldFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpc2UgdGhlIGhhc2hlci5cclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgaW5pdGlhbCBzdGF0ZSBmb3IgdGhlIGhhc2hlci5cclxuICAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZShzdGF0ZSkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgaGFzaGVyLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9rZWNjYWsucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWJzb3JiIHRyaXRzIGludG8gdGhlIGhhc2guXHJcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIGFic29yYi5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSB0cml0cyB0byBhYnNvcmIgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIG51bWJlciBvZiB0cml0cyB0byBhYnNvcmIuXHJcbiAgICAgKi9cclxuICAgIGFic29yYih0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiTGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICUgMjQzICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7S2VybC5IQVNIX0xFTkdUSH1gLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvY2FsT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGxldCBsb2NhbExlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyaXRTdGF0ZSA9IHRyaXRzLnNsaWNlKGxvY2FsT2Zmc2V0LCBsb2NhbE9mZnNldCArIEtlcmwuSEFTSF9MRU5HVEgpO1xyXG4gICAgICAgICAgICB0cml0U3RhdGVbS2VybC5IQVNIX0xFTkdUSCAtIDFdID0gMDtcclxuICAgICAgICAgICAgY29uc3QgYmlnSW50ID0gYmlnSW50ZWdlckhlbHBlcl8xLkJpZ0ludGVnZXJIZWxwZXIudHJpdHNUb0JpZ0ludGVnZXIodHJpdFN0YXRlLCAwLCB0cml0U3RhdGUubGVuZ3RoKTtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZVN0YXRlID0gbmV3IEFycmF5QnVmZmVyKEtlcmwuQllURV9IQVNIX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIGJpZ0ludGVnZXJIZWxwZXJfMS5CaWdJbnRlZ2VySGVscGVyLmJpZ0ludGVnZXJUb0J5dGVzKGJpZ0ludCwgYnl0ZVN0YXRlLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5fa2VjY2FrLnVwZGF0ZShieXRlU3RhdGUpO1xyXG4gICAgICAgICAgICBsb2NhbE9mZnNldCArPSBLZXJsLkhBU0hfTEVOR1RIO1xyXG4gICAgICAgICAgICBsb2NhbExlbmd0aCAtPSBLZXJsLkhBU0hfTEVOR1RIO1xyXG4gICAgICAgIH0gd2hpbGUgKGxvY2FsTGVuZ3RoID4gMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNxdWVlemUgdHJpdHMgaW50byB0aGUgaGFzaC5cclxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgdHJpdHMgdG8gc3F1ZWV6ZS5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSB0cml0cyB0byBzcXVlZXplIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgdHJpdHMgdG8gc3F1ZWV6ZS5cclxuICAgICAqL1xyXG4gICAgc3F1ZWV6ZSh0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiTGVuZ3RoIG11c3QgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoICUgMjQzICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7S2VybC5IQVNIX0xFTkdUSH1gLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvY2FsT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIGxldCBsb2NhbExlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTdGF0ZUJ1ZmZlciA9IHRoaXMuX2tlY2Nhay5kaWdlc3QoKTtcclxuICAgICAgICAgICAgY29uc3QgYmlnSW50ID0gYmlnSW50ZWdlckhlbHBlcl8xLkJpZ0ludGVnZXJIZWxwZXIuYnl0ZXNUb0JpZ0ludGVnZXIoYnl0ZVN0YXRlQnVmZmVyLCAwLCBLZXJsLkJZVEVfSEFTSF9MRU5HVEgpO1xyXG4gICAgICAgICAgICBjb25zdCB0cml0U3RhdGUgPSBuZXcgSW50OEFycmF5KEtlcmwuSEFTSF9MRU5HVEgpO1xyXG4gICAgICAgICAgICBiaWdJbnRlZ2VySGVscGVyXzEuQmlnSW50ZWdlckhlbHBlci5iaWdJbnRlZ2VyVG9Ucml0cyhiaWdJbnQsIHRyaXRTdGF0ZSwgMCwgS2VybC5IQVNIX0xFTkdUSCk7XHJcbiAgICAgICAgICAgIHRyaXRTdGF0ZVtLZXJsLkhBU0hfTEVOR1RIIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgS2VybC5IQVNIX0xFTkdUSCkge1xyXG4gICAgICAgICAgICAgICAgdHJpdHNbbG9jYWxPZmZzZXQrK10gPSB0cml0U3RhdGVbaSsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhieXRlU3RhdGVCdWZmZXIpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZHYuYnl0ZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkdi5zZXRVaW50OChpLCBkdi5nZXRVaW50OChpKSBeIDB4RkYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2tlY2Nhay51cGRhdGUoYnl0ZVN0YXRlQnVmZmVyKTtcclxuICAgICAgICAgICAgbG9jYWxMZW5ndGggLT0gS2VybC5IQVNIX0xFTkdUSDtcclxuICAgICAgICB9IHdoaWxlIChsb2NhbExlbmd0aCA+IDApO1xyXG4gICAgfVxyXG59XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5LZXJsLkhBU0hfTEVOR1RIID0gMjQzO1xyXG4vKiBAaW50ZXJuYWwgKi9cclxuS2VybC5CSVRfSEFTSF9MRU5HVEggPSAzODQ7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5LZXJsLkJZVEVfSEFTSF9MRU5HVEggPSBLZXJsLkJJVF9IQVNIX0xFTkdUSCAvIDg7XHJcbmV4cG9ydHMuS2VybCA9IEtlcmw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWEyVnliQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OXpjRzl1WjJWekwydGxjbXd1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0QlFVRkJMRFJGUVVGNVJUdEJRVU42UlN3MFJVRkJlVVU3UVVGRGVrVXNNRU5CUVhWRE8wRkJRM1pETEhORVFVRnRSRHRCUVVOdVJDeHJSVUZCSzBRN1FVRkhMMFE3T3p0SFFVZEhPMEZCUTBnN1NVRlhTVHM3VDBGRlJ6dEpRVU5JTzFGQlEwa3NTVUZCU1N4RFFVRkRMRTlCUVU4c1IwRkJSeXhKUVVGSkxGZEJRVWtzUTBGQlF5eEhRVUZITEVWQlFVVXNWMEZCU1N4RFFVRkRMR05CUVdNc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF6dEpRVU16UkN4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRmRCUVZjc1EwRkJReXhKUVVGWk8xRkJRek5DTEZGQlFWRXNTVUZCU1N4RlFVRkZPMWxCUTFZc1MwRkJTeXhoUVVGaExFTkJRVU03V1VGRGJrSXNTMEZCU3l4cFFrRkJhVUlzUTBGQlF6dFpRVU4yUWl4TFFVRkxMR3RDUVVGclFqdG5Ra0ZEZGtJN2IwSkJRMGtzVDBGQlR5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN2FVSkJRM0pDTzFsQlEwUXNUMEZCVHl4RFFVRkRMRU5CUVVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNPRUpCUVRoQ0xFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEZUVVN1NVRkRUQ3hEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzVTBGQlV5eERRVUZETzBsQlEzSkNMRU5CUVVNN1NVRkZSRHM3TzA5QlIwYzdTVUZEU1N4VlFVRlZMRU5CUVVNc1MwRkJhVUk3U1VGRGJrTXNRMEZCUXp0SlFVVkVPenRQUVVWSE8wbEJRMGtzUzBGQlN6dFJRVU5TTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU03U1VGRGVrSXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1RVRkJUU3hEUVVGRExFdEJRV2RDTEVWQlFVVXNUVUZCWXl4RlFVRkZMRTFCUVdNN1VVRkRNVVFzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeFRRVUZUTEVOQlFVTXNTVUZCU1N4TFFVRkxMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUlVGQlJUdFpRVU01UkN4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eHhRMEZCY1VNc1EwRkJReXhEUVVGRE8xTkJRMmhGTzFGQlEwUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRTFCUVUwc1IwRkJSeXhEUVVGRExFVkJRVVU3V1VGREwwTXNUVUZCVFN4SlFVRkpMSGxDUVVGWExFTkJRVU1zT0VKQlFUaENMRU5CUVVNc1EwRkJRenRUUVVONlJEdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJReTlETEUxQlFVMHNTVUZCU1N4NVFrRkJWeXhEUVVGRExEaENRVUU0UWl4RFFVRkRMRU5CUVVNN1UwRkRla1E3VVVGRFJDeEpRVUZKTEUxQlFVMHNSMEZCUnl4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUlVGQlJUdFpRVU5vUXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eDFSRUZCZFVRc1EwRkJReXhEUVVGRE8xTkJRMnhHTzFGQlEwUXNTVUZCU1N4TlFVRk5MRWRCUVVjc1IwRkJSeXhMUVVGTExFTkJRVU1zUlVGQlJUdFpRVU53UWl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5eG5RMEZCWjBNc1NVRkJTU3hEUVVGRExGZEJRVmNzUlVGQlJTeEZRVUZGTEVWQlFVVXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVONlJqdFJRVVZFTEVsQlFVa3NWMEZCVnl4SFFVRkhMRTFCUVUwc1EwRkJRenRSUVVONlFpeEpRVUZKTEZkQlFWY3NSMEZCUnl4TlFVRk5MRU5CUVVNN1VVRkZla0lzUjBGQlJ6dFpRVU5ETEUxQlFVMHNVMEZCVXl4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlZ5eEZRVUZGTEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03V1VGRk0wVXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGWExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRPMWxCUTNCRExFMUJRVTBzVFVGQlRTeEhRVUZITEcxRFFVRm5RaXhEUVVGRExHbENRVUZwUWl4RFFVRkRMRk5CUVZNc1JVRkJSU3hEUVVGRExFVkJRVVVzVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMWxCUTJ4R0xFMUJRVTBzVTBGQlV5eEhRVUZITEVsQlFVa3NWMEZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRPMWxCUTNwRUxHMURRVUZuUWl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEUxQlFVMHNSVUZCUlN4VFFVRlRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRmVrUXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTTdXVUZGTDBJc1YwRkJWeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTTdXVUZEYUVNc1YwRkJWeXhKUVVGSkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTTdVMEZEYmtNc1VVRkJVU3hYUVVGWExFZEJRVWNzUTBGQlF5eEZRVUZGTzBsQlF6bENMRU5CUVVNN1NVRkZSRHM3T3pzN1QwRkxSenRKUVVOSkxFOUJRVThzUTBGQlF5eExRVUZuUWl4RlFVRkZMRTFCUVdNc1JVRkJSU3hOUVVGak8xRkJRek5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVWQlFVVXNVMEZCVXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhEUVVGRExFMUJRVTBzUzBGQlN5eERRVUZETEVWQlFVVTdXVUZET1VRc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNjVU5CUVhGRExFTkJRVU1zUTBGQlF6dFRRVU5vUlR0UlFVTkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlF5OURMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETERoQ1FVRTRRaXhEUVVGRExFTkJRVU03VTBGRGVrUTdVVUZEUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hIUVVGSExFTkJRVU1zUlVGQlJUdFpRVU12UXl4TlFVRk5MRWxCUVVrc2VVSkJRVmNzUTBGQlF5dzRRa0ZCT0VJc1EwRkJReXhEUVVGRE8xTkJRM3BFTzFGQlEwUXNTVUZCU1N4TlFVRk5MRWRCUVVjc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVTdXVUZEYUVNc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNkVVJCUVhWRUxFTkJRVU1zUTBGQlF6dFRRVU5zUmp0UlFVTkVMRWxCUVVrc1RVRkJUU3hIUVVGSExFZEJRVWNzUzBGQlN5eERRVUZETEVWQlFVVTdXVUZEY0VJc1RVRkJUU3hKUVVGSkxIbENRVUZYTEVOQlFVTXNaME5CUVdkRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNSVUZCUlN4RlFVRkZMRTFCUVUwc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGVrWTdVVUZGUkN4SlFVRkpMRmRCUVZjc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRGVrSXNTVUZCU1N4WFFVRlhMRWRCUVVjc1RVRkJUU3hEUVVGRE8xRkJSWHBDTEVkQlFVYzdXVUZEUXl4TlFVRk5MR1ZCUVdVc1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRPMWxCUlRsRExFMUJRVTBzVFVGQlRTeEhRVUZITEcxRFFVRm5RaXhEUVVGRExHbENRVUZwUWl4RFFVRkRMR1ZCUVdVc1JVRkJSU3hEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU03V1VGRk4wWXNUVUZCVFN4VFFVRlRMRWRCUVdNc1NVRkJTU3hUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMWxCUXpkRUxHMURRVUZuUWl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEUxQlFVMHNSVUZCUlN4VFFVRlRMRVZCUVVVc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXp0WlFVVXpSU3hUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZkQlFWY3NSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRmNFTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRMVlzVDBGQlR5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRmRCUVZjc1JVRkJSVHRuUWtGRGVrSXNTMEZCU3l4RFFVRkRMRmRCUVZjc1JVRkJSU3hEUVVGRExFZEJRVWNzVTBGQlV5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1lVRkRla003V1VGRlJDeE5RVUZOTEVWQlFVVXNSMEZCUnl4SlFVRkpMRkZCUVZFc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF6dFpRVU42UXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXl4VlFVRlZMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3WjBKQlEyaERMRVZCUVVVc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTTdZVUZEZWtNN1dVRkZSQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJRenRaUVVWeVF5eFhRVUZYTEVsQlFVa3NTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJRenRUUVVOdVF5eFJRVUZSTEZkQlFWY3NSMEZCUnl4RFFVRkRMRVZCUVVVN1NVRkRPVUlzUTBGQlF6czdRVUZ1U2tRc1pVRkJaVHRCUVVOVExHZENRVUZYTEVkQlFWY3NSMEZCUnl4RFFVRkRPMEZCUTJ4RUxHVkJRV1U3UVVGRFV5eHZRa0ZCWlN4SFFVRlhMRWRCUVVjc1EwRkJRenRCUVVOMFJDeGxRVUZsTzBGQlExTXNjVUpCUVdkQ0xFZEJRVmNzU1VGQlNTeERRVUZETEdWQlFXVXNSMEZCUnl4RFFVRkRMRU5CUVVNN1FVRk9hRVlzYjBKQmNVcERJbjA9IiwidmFyIGJpZ0ludCA9IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgQkFTRSA9IDFlNyxcclxuICAgICAgICBMT0dfQkFTRSA9IDcsXHJcbiAgICAgICAgTUFYX0lOVCA9IDkwMDcxOTkyNTQ3NDA5OTIsXHJcbiAgICAgICAgTUFYX0lOVF9BUlIgPSBzbWFsbFRvQXJyYXkoTUFYX0lOVCksXHJcbiAgICAgICAgTE9HX01BWF9JTlQgPSBNYXRoLmxvZyhNQVhfSU5UKTtcclxuXHJcbiAgICBmdW5jdGlvbiBJbnRlZ2VyKHYsIHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICBpZiAodHlwZW9mIHJhZGl4ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gK3JhZGl4ID09PSAxMCA/IHBhcnNlVmFsdWUodikgOiBwYXJzZUJhc2UodiwgcmFkaXgpO1xyXG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5zaWduID0gc2lnbjtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlZ2VyLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZnVuY3Rpb24gU21hbGxJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2lnbiA9IHZhbHVlIDwgMDtcclxuICAgICAgICB0aGlzLmlzU21hbGwgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzUHJlY2lzZShuKSB7XHJcbiAgICAgICAgcmV0dXJuIC1NQVhfSU5UIDwgbiAmJiBuIDwgTUFYX0lOVDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzbWFsbFRvQXJyYXkobikgeyAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBkb2Vzbid0IHJlZmVyZW5jZSBCQVNFLCBuZWVkIHRvIGNoYW5nZSB0aGlzIGZ1bmN0aW9uIGlmIEJBU0UgY2hhbmdlc1xyXG4gICAgICAgIGlmIChuIDwgMWU3KVxyXG4gICAgICAgICAgICByZXR1cm4gW25dO1xyXG4gICAgICAgIGlmIChuIDwgMWUxNClcclxuICAgICAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpXTtcclxuICAgICAgICByZXR1cm4gW24gJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlNykgJSAxZTcsIE1hdGguZmxvb3IobiAvIDFlMTQpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcnJheVRvU21hbGwoYXJyKSB7IC8vIElmIEJBU0UgY2hhbmdlcyB0aGlzIGZ1bmN0aW9uIG1heSBuZWVkIHRvIGNoYW5nZVxyXG4gICAgICAgIHRyaW0oYXJyKTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoIDwgNCAmJiBjb21wYXJlQWJzKGFyciwgTUFYX0lOVF9BUlIpIDwgMCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGFyclswXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGFyclswXSArIGFyclsxXSAqIEJBU0U7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gYXJyWzBdICsgKGFyclsxXSArIGFyclsyXSAqIEJBU0UpICogQkFTRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyaW0odikge1xyXG4gICAgICAgIHZhciBpID0gdi5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKHZbLS1pXSA9PT0gMCk7XHJcbiAgICAgICAgdi5sZW5ndGggPSBpICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpIHsgLy8gZnVuY3Rpb24gc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gWWFmZmxlJ3MgbGlicmFyeSBodHRwczovL2dpdGh1Yi5jb20vWWFmZmxlL0JpZ0ludGVnZXJcclxuICAgICAgICB2YXIgeCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIHZhciBpID0gLTE7XHJcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB4W2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUobikge1xyXG4gICAgICAgIGlmIChuID4gMCkgcmV0dXJuIE1hdGguZmxvb3Iobik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGQoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEubGVuZ3RoID49IGIubGVuZ3RoXHJcbiAgICAgICAgdmFyIGxfYSA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBsX2IgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsX2EpLFxyXG4gICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBzdW0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxfYjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBiW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gc3VtID49IGJhc2UgPyAxIDogMDtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsX2EpIHtcclxuICAgICAgICAgICAgc3VtID0gYVtpXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA9PT0gYmFzZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICByW2krK10gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYXJyeSA+IDApIHIucHVzaChjYXJyeSk7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQW55KGEsIGIpIHtcclxuICAgICAgICBpZiAoYS5sZW5ndGggPj0gYi5sZW5ndGgpIHJldHVybiBhZGQoYSwgYik7XHJcbiAgICAgICAgcmV0dXJuIGFkZChiLCBhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTbWFsbChhLCBjYXJyeSkgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGNhcnJ5IGlzIG51bWJlciB3aXRoIDAgPD0gY2FycnkgPCBNQVhfSU5UXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHN1bSwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gLSBiYXNlICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihzdW0gLyBiYXNlKTtcclxuICAgICAgICAgICAgcltpXSA9IHN1bSAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xyXG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYSwgTWF0aC5hYnMoYikpLCB0aGlzLnNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkQW55KGEsIGIpLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBsdXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3Qobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoYSArIGIpKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhICsgYik7XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoTWF0aC5hYnMoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYiwgTWF0aC5hYnMoYSkpLCBhIDwgMCk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hZGQ7XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYikgeyAvLyBhc3N1bWVzIGEgYW5kIGIgYXJlIGFycmF5cyB3aXRoIGEgPj0gYlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkoYV9sKSxcclxuICAgICAgICAgICAgYm9ycm93ID0gMCxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIGRpZmZlcmVuY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93IC0gYltpXTtcclxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlICs9IGJhc2U7XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2UgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IGJfbDsgaSA8IGFfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldIC0gYm9ycm93O1xyXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA8IDApIGRpZmZlcmVuY2UgKz0gYmFzZTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByW2krK10gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBpIDwgYV9sOyBpKyspIHtcclxuICAgICAgICAgICAgcltpXSA9IGFbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3RBbnkoYSwgYiwgc2lnbikge1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICBpZiAoY29tcGFyZUFicyhhLCBiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gc3VidHJhY3QoYSxiKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHN1YnRyYWN0KGIsIGEpO1xyXG4gICAgICAgICAgICBzaWduID0gIXNpZ247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlID0gYXJyYXlUb1NtYWxsKHZhbHVlKTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzaWduKSB2YWx1ZSA9IC12YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodmFsdWUsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0U21hbGwoYSwgYiwgc2lnbikgeyAvLyBhc3N1bWVzIGEgaXMgYXJyYXksIGIgaXMgbnVtYmVyIHdpdGggMCA8PSBiIDwgTUFYX0lOVFxyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gLWIsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBkaWZmZXJlbmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSA9IGFbaV0gKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGRpZmZlcmVuY2UgLyBiYXNlKTtcclxuICAgICAgICAgICAgZGlmZmVyZW5jZSAlPSBiYXNlO1xyXG4gICAgICAgICAgICByW2ldID0gZGlmZmVyZW5jZSA8IDAgPyBkaWZmZXJlbmNlICsgYmFzZSA6IGRpZmZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHIgPSBhcnJheVRvU21hbGwocik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzaWduKSByID0gLXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHIpO1xyXG4gICAgICAgIH0gcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAobi5pc1NtYWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChhLCBNYXRoLmFicyhiKSwgdGhpcy5zaWduKTtcclxuICAgICAgICByZXR1cm4gc3VidHJhY3RBbnkoYSwgYiwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW51cyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhIC0gYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKGIsIE1hdGguYWJzKGEpLCBhID49IDApO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgIXRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ247XHJcbiAgICAgICAgdmFyIHNtYWxsID0gbmV3IFNtYWxsSW50ZWdlcigtdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgc21hbGwuc2lnbiA9ICFzaWduO1xyXG4gICAgICAgIHJldHVybiBzbWFsbDtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcih0aGlzLnZhbHVlLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoTWF0aC5hYnModGhpcy52YWx1ZSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUxvbmcoYSwgYikge1xyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIGwgPSBhX2wgKyBiX2wsXHJcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHByb2R1Y3QsIGNhcnJ5LCBpLCBhX2ksIGJfajtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYV9sOyArK2kpIHtcclxuICAgICAgICAgICAgYV9pID0gYVtpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiX2w7ICsraikge1xyXG4gICAgICAgICAgICAgICAgYl9qID0gYltqXTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSBhX2kgKiBiX2ogKyByW2kgKyBqXTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqICsgMV0gKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsKGEsIGIpIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIHxifCA8IEJBU0VcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgcHJvZHVjdCA9IGFbaV0gKiBiICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgIHJbaV0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XHJcbiAgICAgICAgICAgIHJbaSsrXSA9IGNhcnJ5ICUgYmFzZTtcclxuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNoaWZ0TGVmdCh4LCBuKSB7XHJcbiAgICAgICAgdmFyIHIgPSBbXTtcclxuICAgICAgICB3aGlsZSAobi0tID4gMCkgci5wdXNoKDApO1xyXG4gICAgICAgIHJldHVybiByLmNvbmNhdCh4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUthcmF0c3ViYSh4LCB5KSB7XHJcbiAgICAgICAgdmFyIG4gPSBNYXRoLm1heCh4Lmxlbmd0aCwgeS5sZW5ndGgpO1xyXG5cclxuICAgICAgICBpZiAobiA8PSAzMCkgcmV0dXJuIG11bHRpcGx5TG9uZyh4LCB5KTtcclxuICAgICAgICBuID0gTWF0aC5jZWlsKG4gLyAyKTtcclxuXHJcbiAgICAgICAgdmFyIGIgPSB4LnNsaWNlKG4pLFxyXG4gICAgICAgICAgICBhID0geC5zbGljZSgwLCBuKSxcclxuICAgICAgICAgICAgZCA9IHkuc2xpY2UobiksXHJcbiAgICAgICAgICAgIGMgPSB5LnNsaWNlKDAsIG4pO1xyXG5cclxuICAgICAgICB2YXIgYWMgPSBtdWx0aXBseUthcmF0c3ViYShhLCBjKSxcclxuICAgICAgICAgICAgYmQgPSBtdWx0aXBseUthcmF0c3ViYShiLCBkKSxcclxuICAgICAgICAgICAgYWJjZCA9IG11bHRpcGx5S2FyYXRzdWJhKGFkZEFueShhLCBiKSwgYWRkQW55KGMsIGQpKTtcclxuXHJcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBhZGRBbnkoYWRkQW55KGFjLCBzaGlmdExlZnQoc3VidHJhY3Qoc3VidHJhY3QoYWJjZCwgYWMpLCBiZCksIG4pKSwgc2hpZnRMZWZ0KGJkLCAyICogbikpO1xyXG4gICAgICAgIHRyaW0ocHJvZHVjdCk7XHJcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGZvbGxvd2luZyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gYSBzdXJmYWNlIGZpdCBvZiBhIGdyYXBoIHBsb3R0aW5nIHRoZSBwZXJmb3JtYW5jZSBkaWZmZXJlbmNlXHJcbiAgICAvLyBiZXR3ZWVuIGxvbmcgbXVsdGlwbGljYXRpb24gYW5kIGthcmF0c3ViYSBtdWx0aXBsaWNhdGlvbiB2ZXJzdXMgdGhlIGxlbmd0aHMgb2YgdGhlIHR3byBhcnJheXMuXHJcbiAgICBmdW5jdGlvbiB1c2VLYXJhdHN1YmEobDEsIGwyKSB7XHJcbiAgICAgICAgcmV0dXJuIC0wLjAxMiAqIGwxIC0gMC4wMTIgKiBsMiArIDAuMDAwMDE1ICogbDEgKiBsMiA+IDA7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlLFxyXG4gICAgICAgICAgICBzaWduID0gdGhpcy5zaWduICE9PSBuLnNpZ24sXHJcbiAgICAgICAgICAgIGFicztcclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGIgPT09IDEpIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBhYnMgPSBNYXRoLmFicyhiKTtcclxuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGEsIGFicyksIHNpZ24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVzZUthcmF0c3ViYShhLmxlbmd0aCwgYi5sZW5ndGgpKSAvLyBLYXJhdHN1YmEgaXMgb25seSBmYXN0ZXIgZm9yIGNlcnRhaW4gYXJyYXkgc2l6ZXNcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5S2FyYXRzdWJhKGEsIGIpLCBzaWduKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGEsIGIpLCBzaWduKTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudGltZXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoYSwgYiwgc2lnbikgeyAvLyBhID49IDBcclxuICAgICAgICBpZiAoYSA8IEJBU0UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYiwgYSksIHNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGIsIHNtYWxsVG9BcnJheShhKSksIHNpZ24pO1xyXG4gICAgfVxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5fbXVsdGlwbHlCeVNtYWxsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZShhLnZhbHVlICogdGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEudmFsdWUgKiB0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCBzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmIChhLnZhbHVlID09PSAwKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGEudmFsdWUgPT09IDEpIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoYS52YWx1ZSA9PT0gLTEpIHJldHVybiB0aGlzLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLCB0aGlzLnZhbHVlLCB0aGlzLnNpZ24gIT09IGEuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodikuX211bHRpcGx5QnlTbWFsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRpbWVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICBmdW5jdGlvbiBzcXVhcmUoYSkge1xyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBjcmVhdGVBcnJheShsICsgbCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBhX2o7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBhX2kgPSBhW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYV9qID0gYVtqXTtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3QgPSBhX2kgKiBhX2ogKyByW2kgKyBqXTtcclxuICAgICAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihwcm9kdWN0IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqXSA9IHByb2R1Y3QgLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgICAgICByW2kgKyBqICsgMV0gKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpbShyKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZSh0aGlzLnZhbHVlKSwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlICogdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlKSkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUoc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSksIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kMShhLCBiKSB7IC8vIExlZnQgb3ZlciBmcm9tIHByZXZpb3VzIHZlcnNpb24uIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDIgb24gc21hbGxlciBpbnB1dCBzaXplcy5cclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlQXJyYXkoYi5sZW5ndGgpLFxyXG4gICAgICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBiW2JfbCAtIDFdLFxyXG4gICAgICAgICAgICAvLyBub3JtYWxpemF0aW9uXHJcbiAgICAgICAgICAgIGxhbWJkYSA9IE1hdGguY2VpbChiYXNlIC8gKDIgKiBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpKSxcclxuICAgICAgICAgICAgcmVtYWluZGVyID0gbXVsdGlwbHlTbWFsbChhLCBsYW1iZGEpLFxyXG4gICAgICAgICAgICBkaXZpc29yID0gbXVsdGlwbHlTbWFsbChiLCBsYW1iZGEpLFxyXG4gICAgICAgICAgICBxdW90aWVudERpZ2l0LCBzaGlmdCwgY2FycnksIGJvcnJvdywgaSwgbCwgcTtcclxuICAgICAgICBpZiAocmVtYWluZGVyLmxlbmd0aCA8PSBhX2wpIHJlbWFpbmRlci5wdXNoKDApO1xyXG4gICAgICAgIGRpdmlzb3IucHVzaCgwKTtcclxuICAgICAgICBkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQgPSBkaXZpc29yW2JfbCAtIDFdO1xyXG4gICAgICAgIGZvciAoc2hpZnQgPSBhX2wgLSBiX2w7IHNoaWZ0ID49IDA7IHNoaWZ0LS0pIHtcclxuICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IGJhc2UgLSAxO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluZGVyW3NoaWZ0ICsgYl9sXSAhPT0gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KSB7XHJcbiAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCA9IE1hdGguZmxvb3IoKHJlbWFpbmRlcltzaGlmdCArIGJfbF0gKiBiYXNlICsgcmVtYWluZGVyW3NoaWZ0ICsgYl9sIC0gMV0pIC8gZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBxdW90aWVudERpZ2l0IDw9IGJhc2UgLSAxXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcclxuICAgICAgICAgICAgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgbCA9IGRpdmlzb3IubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBxdW90aWVudERpZ2l0ICogZGl2aXNvcltpXTtcclxuICAgICAgICAgICAgICAgIHEgPSBNYXRoLmZsb29yKGNhcnJ5IC8gYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSAoY2FycnkgLSBxICogYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IHE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9ycm93IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93ICsgYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICBib3Jyb3cgPSAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBib3Jyb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoYm9ycm93ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBxdW90aWVudERpZ2l0IC09IDE7XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FycnkgKz0gcmVtYWluZGVyW3NoaWZ0ICsgaV0gLSBiYXNlICsgZGl2aXNvcltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FycnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2FycnkgKyBiYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyW3NoaWZ0ICsgaV0gPSBjYXJyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJvcnJvdyArPSBjYXJyeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRbc2hpZnRdID0gcXVvdGllbnREaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVub3JtYWxpemF0aW9uXHJcbiAgICAgICAgcmVtYWluZGVyID0gZGl2TW9kU21hbGwocmVtYWluZGVyLCBsYW1iZGEpWzBdO1xyXG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChyZW1haW5kZXIpXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2QyKGEsIGIpIHsgLy8gSW1wbGVtZW50YXRpb24gaWRlYSBzaGFtZWxlc3NseSBzdG9sZW4gZnJvbSBTaWxlbnQgTWF0dCdzIGxpYnJhcnkgaHR0cDovL3NpbGVudG1hdHQuY29tL2JpZ2ludGVnZXIvXHJcbiAgICAgICAgLy8gUGVyZm9ybXMgZmFzdGVyIHRoYW4gZGl2TW9kMSBvbiBsYXJnZXIgaW5wdXQgc2l6ZXMuXHJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXHJcbiAgICAgICAgICAgIHBhcnQgPSBbXSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGd1ZXNzLCB4bGVuLCBoaWdoeCwgaGlnaHksIGNoZWNrO1xyXG4gICAgICAgIHdoaWxlIChhX2wpIHtcclxuICAgICAgICAgICAgcGFydC51bnNoaWZ0KGFbLS1hX2xdKTtcclxuICAgICAgICAgICAgdHJpbShwYXJ0KTtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmVBYnMocGFydCwgYikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhsZW4gPSBwYXJ0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaGlnaHggPSBwYXJ0W3hsZW4gLSAxXSAqIGJhc2UgKyBwYXJ0W3hsZW4gLSAyXTtcclxuICAgICAgICAgICAgaGlnaHkgPSBiW2JfbCAtIDFdICogYmFzZSArIGJbYl9sIC0gMl07XHJcbiAgICAgICAgICAgIGlmICh4bGVuID4gYl9sKSB7XHJcbiAgICAgICAgICAgICAgICBoaWdoeCA9IChoaWdoeCArIDEpICogYmFzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBndWVzcyA9IE1hdGguY2VpbChoaWdoeCAvIGhpZ2h5KTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgY2hlY2sgPSBtdWx0aXBseVNtYWxsKGIsIGd1ZXNzKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKGNoZWNrLCBwYXJ0KSA8PSAwKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGd1ZXNzLS07XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGd1ZXNzKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZ3Vlc3MpO1xyXG4gICAgICAgICAgICBwYXJ0ID0gc3VidHJhY3QocGFydCwgY2hlY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIHJldHVybiBbYXJyYXlUb1NtYWxsKHJlc3VsdCksIGFycmF5VG9TbWFsbChwYXJ0KV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kU21hbGwodmFsdWUsIGxhbWJkYSkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHF1b3RpZW50ID0gY3JlYXRlQXJyYXkobGVuZ3RoKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGksIHEsIHJlbWFpbmRlciwgZGl2aXNvcjtcclxuICAgICAgICByZW1haW5kZXIgPSAwO1xyXG4gICAgICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSByZW1haW5kZXIgKiBiYXNlICsgdmFsdWVbaV07XHJcbiAgICAgICAgICAgIHEgPSB0cnVuY2F0ZShkaXZpc29yIC8gbGFtYmRhKTtcclxuICAgICAgICAgICAgcmVtYWluZGVyID0gZGl2aXNvciAtIHEgKiBsYW1iZGE7XHJcbiAgICAgICAgICAgIHF1b3RpZW50W2ldID0gcSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIHJlbWFpbmRlciB8IDBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZEFueShzZWxmLCB2KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlLCBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgYSA9IHNlbGYudmFsdWUsIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIHZhciBxdW90aWVudDtcclxuICAgICAgICBpZiAoYiA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpdmlkZSBieSB6ZXJvXCIpO1xyXG4gICAgICAgIGlmIChzZWxmLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKGEgLyBiKSksIG5ldyBTbWFsbEludGVnZXIoYSAlIGIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gW3NlbGYsIEludGVnZXJbMF1dO1xyXG4gICAgICAgICAgICBpZiAoYiA9PSAtMSkgcmV0dXJuIFtzZWxmLm5lZ2F0ZSgpLCBJbnRlZ2VyWzBdXTtcclxuICAgICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICBpZiAoYWJzIDwgQkFTRSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2RTbWFsbChhLCBhYnMpO1xyXG4gICAgICAgICAgICAgICAgcXVvdGllbnQgPSBhcnJheVRvU21hbGwodmFsdWVbMF0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IHZhbHVlWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbikgcmVtYWluZGVyID0gLXJlbWFpbmRlcjtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5zaWduICE9PSBuLnNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBzZWxmLnNpZ24gIT09IG4uc2lnbiksIG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IHNtYWxsVG9BcnJheShhYnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGFyaXNvbiA9IGNvbXBhcmVBYnMoYSwgYik7XHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gPT09IC0xKSByZXR1cm4gW0ludGVnZXJbMF0sIHNlbGZdO1xyXG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAwKSByZXR1cm4gW0ludGVnZXJbc2VsZi5zaWduID09PSBuLnNpZ24gPyAxIDogLTFdLCBJbnRlZ2VyWzBdXTtcclxuXHJcbiAgICAgICAgLy8gZGl2TW9kMSBpcyBmYXN0ZXIgb24gc21hbGxlciBpbnB1dCBzaXplc1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCArIGIubGVuZ3RoIDw9IDIwMClcclxuICAgICAgICAgICAgdmFsdWUgPSBkaXZNb2QxKGEsIGIpO1xyXG4gICAgICAgIGVsc2UgdmFsdWUgPSBkaXZNb2QyKGEsIGIpO1xyXG5cclxuICAgICAgICBxdW90aWVudCA9IHZhbHVlWzBdO1xyXG4gICAgICAgIHZhciBxU2lnbiA9IHNlbGYuc2lnbiAhPT0gbi5zaWduLFxyXG4gICAgICAgICAgICBtb2QgPSB2YWx1ZVsxXSxcclxuICAgICAgICAgICAgbVNpZ24gPSBzZWxmLnNpZ247XHJcbiAgICAgICAgaWYgKHR5cGVvZiBxdW90aWVudCA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAocVNpZ24pIHF1b3RpZW50ID0gLXF1b3RpZW50O1xyXG4gICAgICAgICAgICBxdW90aWVudCA9IG5ldyBTbWFsbEludGVnZXIocXVvdGllbnQpO1xyXG4gICAgICAgIH0gZWxzZSBxdW90aWVudCA9IG5ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LCBxU2lnbik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtb2QgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKG1TaWduKSBtb2QgPSAtbW9kO1xyXG4gICAgICAgICAgICBtb2QgPSBuZXcgU21hbGxJbnRlZ2VyKG1vZCk7XHJcbiAgICAgICAgfSBlbHNlIG1vZCA9IG5ldyBCaWdJbnRlZ2VyKG1vZCwgbVNpZ24pO1xyXG4gICAgICAgIHJldHVybiBbcXVvdGllbnQsIG1vZF07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGl2TW9kQW55KHRoaXMsIHYpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHF1b3RpZW50OiByZXN1bHRbMF0sXHJcbiAgICAgICAgICAgIHJlbWFpbmRlcjogcmVzdWx0WzFdXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMF07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vdmVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIGRpdk1vZEFueSh0aGlzLCB2KVsxXTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kID0gQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWUsXHJcbiAgICAgICAgICAgIHZhbHVlLCB4LCB5O1xyXG4gICAgICAgIGlmIChiID09PSAwKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgaWYgKGEgPT09IDEpIHJldHVybiBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIGlmIChhID09PSAtMSkgcmV0dXJuIG4uaXNFdmVuKCkgPyBJbnRlZ2VyWzFdIDogSW50ZWdlclstMV07XHJcbiAgICAgICAgaWYgKG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuLmlzU21hbGwpIHRocm93IG5ldyBFcnJvcihcIlRoZSBleHBvbmVudCBcIiArIG4udG9TdHJpbmcoKSArIFwiIGlzIHRvbyBsYXJnZS5cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQcmVjaXNlKHZhbHVlID0gTWF0aC5wb3coYSwgYikpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodHJ1bmNhdGUodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeCA9IHRoaXM7XHJcbiAgICAgICAgeSA9IEludGVnZXJbMV07XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGIgJiAxID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgICAgICAgIC0tYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIGIgLz0gMjtcclxuICAgICAgICAgICAgeCA9IHguc3F1YXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUucG93O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdyA9IGZ1bmN0aW9uIChleHAsIG1vZCkge1xyXG4gICAgICAgIGV4cCA9IHBhcnNlVmFsdWUoZXhwKTtcclxuICAgICAgICBtb2QgPSBwYXJzZVZhbHVlKG1vZCk7XHJcbiAgICAgICAgaWYgKG1vZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbW9kdWx1cyAwXCIpO1xyXG4gICAgICAgIHZhciByID0gSW50ZWdlclsxXSxcclxuICAgICAgICAgICAgYmFzZSA9IHRoaXMubW9kKG1vZCk7XHJcbiAgICAgICAgd2hpbGUgKGV4cC5pc1Bvc2l0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2UuaXNaZXJvKCkpIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgICAgICBpZiAoZXhwLmlzT2RkKCkpIHIgPSByLm11bHRpcGx5KGJhc2UpLm1vZChtb2QpO1xyXG4gICAgICAgICAgICBleHAgPSBleHAuZGl2aWRlKDIpO1xyXG4gICAgICAgICAgICBiYXNlID0gYmFzZS5zcXVhcmUoKS5tb2QobW9kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3c7XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZUFicyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkgcmV0dXJuIDE7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSBNYXRoLmFicyh0aGlzLnZhbHVlKSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBiID0gTWF0aC5hYnMoYik7XHJcbiAgICAgICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGFib3V0IGNvbXBhcmlzb24gd2l0aCBJbmZpbml0eTpcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGV0ZXJvbHNvbi9CaWdJbnRlZ2VyLmpzL2lzc3Vlcy82MVxyXG4gICAgICAgIGlmICh2ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLFxyXG4gICAgICAgICAgICBiID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG4uc2lnbiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGFyZUFicyhhLCBiKSAqICh0aGlzLnNpZ24gPyAtMSA6IDEpO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYSA8IDAgIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhIDwgMCA/IDEgOiAtMTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpICE9PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmd0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPCAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubHQgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3NlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmx0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSA+PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPD0gMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlWzBdICYgMSkgPT09IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlICYgMSkgPT09IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnNpZ247XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID4gMDtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaWduO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMudmFsdWUpID09PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSAwO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSAyKSByZXR1cm4gdGhpcy5pc0V2ZW4oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2QobikuZXF1YWxzKEludGVnZXJbMF0pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnk7XHJcblxyXG4gICAgZnVuY3Rpb24gaXNCYXNpY1ByaW1lKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHYuYWJzKCk7XHJcbiAgICAgICAgaWYgKG4uaXNVbml0KCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAobi5lcXVhbHMoMikgfHwgbi5lcXVhbHMoMykgfHwgbi5lcXVhbHMoNSkpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChuLmlzRXZlbigpIHx8IG4uaXNEaXZpc2libGVCeSgzKSB8fCBuLmlzRGl2aXNpYmxlQnkoNSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAobi5sZXNzZXIoMjUpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgcHJpbWU6IGxldCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZpZ3VyZSBpdCBvdXRcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xyXG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKSxcclxuICAgICAgICAgICAgblByZXYgPSBuLnByZXYoKTtcclxuICAgICAgICB2YXIgYSA9IFsyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOV0sXHJcbiAgICAgICAgICAgIGIgPSBuUHJldixcclxuICAgICAgICAgICAgZCwgdCwgaSwgeDtcclxuICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkgYiA9IGIuZGl2aWRlKDIpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHggPSBiaWdJbnQoYVtpXSkubW9kUG93KGIsIG4pO1xyXG4gICAgICAgICAgICBpZiAoeC5lcXVhbHMoSW50ZWdlclsxXSkgfHwgeC5lcXVhbHMoblByZXYpKSBjb250aW51ZTtcclxuICAgICAgICAgICAgZm9yICh0ID0gdHJ1ZSwgZCA9IGI7IHQgJiYgZC5sZXNzZXIoblByZXYpIDsgZCA9IGQubXVsdGlwbHkoMikpIHtcclxuICAgICAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpLm1vZChuKTtcclxuICAgICAgICAgICAgICAgIGlmICh4LmVxdWFscyhuUHJldikpIHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJpbWUgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uIChpdGVyYXRpb25zKSB7XHJcbiAgICAgICAgdmFyIGlzUHJpbWUgPSBpc0Jhc2ljUHJpbWUodGhpcyk7XHJcbiAgICAgICAgaWYgKGlzUHJpbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzUHJpbWU7XHJcbiAgICAgICAgdmFyIG4gPSB0aGlzLmFicygpO1xyXG4gICAgICAgIHZhciB0ID0gaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkID8gNSA6IGl0ZXJhdGlvbnM7XHJcbiAgICAgICAgLy8gdXNlIHRoZSBGZXJtYXQgcHJpbWFsaXR5IHRlc3RcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGJpZ0ludC5yYW5kQmV0d2VlbigyLCBuLm1pbnVzKDIpKTtcclxuICAgICAgICAgICAgaWYgKCFhLm1vZFBvdyhuLnByZXYoKSwgbikuaXNVbml0KCkpIHJldHVybiBmYWxzZTsgLy8gZGVmaW5pdGVseSBjb21wb3NpdGVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIGxhcmdlIGNoYW5jZSBvZiBiZWluZyBwcmltZVxyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludiA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIHQgPSBiaWdJbnQuemVybywgbmV3VCA9IGJpZ0ludC5vbmUsIHIgPSBwYXJzZVZhbHVlKG4pLCBuZXdSID0gdGhpcy5hYnMoKSwgcSwgbGFzdFQsIGxhc3RSO1xyXG4gICAgICAgIHdoaWxlICghbmV3Ui5lcXVhbHMoYmlnSW50Lnplcm8pKSB7XHJcbiAgICAgICAgICAgIHEgPSByLmRpdmlkZShuZXdSKTtcclxuICAgICAgICAgICAgbGFzdFQgPSB0O1xyXG4gICAgICAgICAgICBsYXN0UiA9IHI7XHJcbiAgICAgICAgICAgIHQgPSBuZXdUO1xyXG4gICAgICAgICAgICByID0gbmV3UjtcclxuICAgICAgICAgICAgbmV3VCA9IGxhc3RULnN1YnRyYWN0KHEubXVsdGlwbHkobmV3VCkpO1xyXG4gICAgICAgICAgICBuZXdSID0gbGFzdFIuc3VidHJhY3QocS5tdWx0aXBseShuZXdSKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghci5lcXVhbHMoMSkpIHRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkgKyBcIiBhbmQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBhcmUgbm90IGNvLXByaW1lXCIpO1xyXG4gICAgICAgIGlmICh0LmNvbXBhcmUoMCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHQgPSB0LmFkZChuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0Lm5lZ2F0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnYgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnY7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsIDEsIHRoaXMuc2lnbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA8IE1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwgMSksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwgMSwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgLSAxID4gLU1BWF9JTlQpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlIC0gMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHBvd2Vyc09mVHdvID0gWzFdO1xyXG4gICAgd2hpbGUgKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSA8PSBCQVNFKSBwb3dlcnNPZlR3by5wdXNoKDIgKiBwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGggLSAxXSk7XHJcbiAgICB2YXIgcG93ZXJzMkxlbmd0aCA9IHBvd2Vyc09mVHdvLmxlbmd0aCwgaGlnaGVzdFBvd2VyMiA9IHBvd2Vyc09mVHdvW3Bvd2VyczJMZW5ndGggLSAxXTtcclxuXHJcbiAgICBmdW5jdGlvbiBzaGlmdF9pc1NtYWxsKG4pIHtcclxuICAgICAgICByZXR1cm4gKCh0eXBlb2YgbiA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIikgJiYgK01hdGguYWJzKG4pIDw9IEJBU0UpIHx8XHJcbiAgICAgICAgICAgIChuIGluc3RhbmNlb2YgQmlnSW50ZWdlciAmJiBuLnZhbHVlLmxlbmd0aCA8PSAxKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSArbjtcclxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0UmlnaHQoLW4pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpO1xyXG4gICAgICAgICAgICBuIC09IHBvd2VyczJMZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Lm11bHRpcGx5KHBvd2Vyc09mVHdvW25dKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB2YXIgcmVtUXVvO1xyXG4gICAgICAgIGlmICghc2hpZnRfaXNTbWFsbChuKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pICsgXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gPSArbjtcclxuICAgICAgICBpZiAobiA8IDApIHJldHVybiB0aGlzLnNoaWZ0TGVmdCgtbik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKG4gPj0gcG93ZXJzMkxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LmlzWmVybygpKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICAgICAgICAgIG4gLT0gcG93ZXJzMkxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbVF1byA9IGRpdk1vZEFueShyZXN1bHQsIHBvd2Vyc09mVHdvW25dKTtcclxuICAgICAgICByZXR1cm4gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKSA/IHJlbVF1b1swXS5wcmV2KCkgOiByZW1RdW9bMF07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbiAgICBmdW5jdGlvbiBiaXR3aXNlKHgsIHksIGZuKSB7XHJcbiAgICAgICAgeSA9IHBhcnNlVmFsdWUoeSk7XHJcbiAgICAgICAgdmFyIHhTaWduID0geC5pc05lZ2F0aXZlKCksIHlTaWduID0geS5pc05lZ2F0aXZlKCk7XHJcbiAgICAgICAgdmFyIHhSZW0gPSB4U2lnbiA/IHgubm90KCkgOiB4LFxyXG4gICAgICAgICAgICB5UmVtID0geVNpZ24gPyB5Lm5vdCgpIDogeTtcclxuICAgICAgICB2YXIgeERpZ2l0ID0gMCwgeURpZ2l0ID0gMDtcclxuICAgICAgICB2YXIgeERpdk1vZCA9IG51bGwsIHlEaXZNb2QgPSBudWxsO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICB3aGlsZSAoIXhSZW0uaXNaZXJvKCkgfHwgIXlSZW0uaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgeERpdk1vZCA9IGRpdk1vZEFueSh4UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeERpZ2l0ID0geERpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh4U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeERpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB4RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeURpdk1vZCA9IGRpdk1vZEFueSh5UmVtLCBoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgeURpZ2l0ID0geURpdk1vZFsxXS50b0pTTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh5U2lnbikge1xyXG4gICAgICAgICAgICAgICAgeURpZ2l0ID0gaGlnaGVzdFBvd2VyMiAtIDEgLSB5RGlnaXQ7IC8vIHR3bydzIGNvbXBsZW1lbnQgZm9yIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeFJlbSA9IHhEaXZNb2RbMF07XHJcbiAgICAgICAgICAgIHlSZW0gPSB5RGl2TW9kWzBdO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChmbih4RGlnaXQsIHlEaWdpdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3VtID0gZm4oeFNpZ24gPyAxIDogMCwgeVNpZ24gPyAxIDogMCkgIT09IDAgPyBiaWdJbnQoLTEpIDogYmlnSW50KDApO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgc3VtID0gc3VtLm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpLmFkZChiaWdJbnQocmVzdWx0W2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZSgpLnByZXYoKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICYgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQ7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIHwgYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm9yO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgcmV0dXJuIGJpdHdpc2UodGhpcywgbiwgZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgXiBiOyB9KTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnhvciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnhvcjtcclxuXHJcbiAgICB2YXIgTE9CTUFTS19JID0gMSA8PCAzMCwgTE9CTUFTS19CSSA9IChCQVNFICYgLUJBU0UpICogKEJBU0UgJiAtQkFTRSkgfCBMT0JNQVNLX0k7XHJcbiAgICBmdW5jdGlvbiByb3VnaExPQihuKSB7IC8vIGdldCBsb3dlc3RPbmVCaXQgKHJvdWdoKVxyXG4gICAgICAgIC8vIFNtYWxsSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMzApXHJcbiAgICAgICAgLy8gQmlnSW50ZWdlcjogcmV0dXJuIE1pbihsb3dlc3RPbmVCaXQobiksIDEgPDwgMTQpIFtCQVNFPTFlN11cclxuICAgICAgICB2YXIgdiA9IG4udmFsdWUsIHggPSB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiA/IHYgfCBMT0JNQVNLX0kgOiB2WzBdICsgdlsxXSAqIEJBU0UgfCBMT0JNQVNLX0JJO1xyXG4gICAgICAgIHJldHVybiB4ICYgLXg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWF4KGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICByZXR1cm4gYS5ncmVhdGVyKGIpID8gYSA6IGI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtaW4oYSwgYikge1xyXG4gICAgICAgIGEgPSBwYXJzZVZhbHVlKGEpO1xyXG4gICAgICAgIGIgPSBwYXJzZVZhbHVlKGIpO1xyXG4gICAgICAgIHJldHVybiBhLmxlc3NlcihiKSA/IGEgOiBiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2NkKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICBpZiAoYS5lcXVhbHMoYikpIHJldHVybiBhO1xyXG4gICAgICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYjtcclxuICAgICAgICBpZiAoYi5pc1plcm8oKSkgcmV0dXJuIGE7XHJcbiAgICAgICAgdmFyIGMgPSBJbnRlZ2VyWzFdLCBkLCB0O1xyXG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpICYmIGIuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgZCA9IE1hdGgubWluKHJvdWdoTE9CKGEpLCByb3VnaExPQihiKSk7XHJcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShkKTtcclxuICAgICAgICAgICAgYiA9IGIuZGl2aWRlKGQpO1xyXG4gICAgICAgICAgICBjID0gYy5tdWx0aXBseShkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgYSA9IGEuZGl2aWRlKHJvdWdoTE9CKGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuZGl2aWRlKHJvdWdoTE9CKGIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYS5ncmVhdGVyKGIpKSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gYjsgYiA9IGE7IGEgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBiLnN1YnRyYWN0KGEpO1xyXG4gICAgICAgIH0gd2hpbGUgKCFiLmlzWmVybygpKTtcclxuICAgICAgICByZXR1cm4gYy5pc1VuaXQoKSA/IGEgOiBhLm11bHRpcGx5KGMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGNtKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKS5hYnMoKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKS5hYnMoKTtcclxuICAgICAgICByZXR1cm4gYS5kaXZpZGUoZ2NkKGEsIGIpKS5tdWx0aXBseShiKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmRCZXR3ZWVuKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICB2YXIgbG93ID0gbWluKGEsIGIpLCBoaWdoID0gbWF4KGEsIGIpO1xyXG4gICAgICAgIHZhciByYW5nZSA9IGhpZ2guc3VidHJhY3QobG93KS5hZGQoMSk7XHJcbiAgICAgICAgaWYgKHJhbmdlLmlzU21hbGwpIHJldHVybiBsb3cuYWRkKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJhbmdlLnZhbHVlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCByZXN0cmljdGVkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgdG9wID0gcmVzdHJpY3RlZCA/IHJhbmdlLnZhbHVlW2ldIDogQkFTRTtcclxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gdHJ1bmNhdGUoTWF0aC5yYW5kb20oKSAqIHRvcCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KGRpZ2l0KTtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0IDwgdG9wKSByZXN0cmljdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCA9IGFycmF5VG9TbWFsbChyZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiBsb3cuYWRkKHR5cGVvZiByZXN1bHQgPT09IFwibnVtYmVyXCIgPyBuZXcgU21hbGxJbnRlZ2VyKHJlc3VsdCkgOiBuZXcgQmlnSW50ZWdlcihyZXN1bHQsIGZhbHNlKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgcGFyc2VCYXNlID0gZnVuY3Rpb24gKHRleHQsIGJhc2UpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XHJcblx0XHR2YXIgaTtcclxuXHRcdHZhciBhYnNCYXNlID0gTWF0aC5hYnMoYmFzZSk7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGMgPSB0ZXh0W2ldLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdGlmKGMgPT09IFwiLVwiKSBjb250aW51ZTtcclxuXHRcdFx0aWYoL1thLXowLTldLy50ZXN0KGMpKSB7XHJcblx0XHRcdCAgICBpZigvWzAtOV0vLnRlc3QoYykgJiYgK2MgPj0gYWJzQmFzZSkge1xyXG5cdFx0XHRcdFx0aWYoYyA9PT0gXCIxXCIgJiYgYWJzQmFzZSA9PT0gMSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiICsgYmFzZSArIFwiLlwiKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoYy5jaGFyQ29kZUF0KDApIC0gODcgPj0gYWJzQmFzZSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiICsgYmFzZSArIFwiLlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuICAgICAgICBpZiAoMiA8PSBiYXNlICYmIGJhc2UgPD0gMzYpIHtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSBMT0dfTUFYX0lOVCAvIE1hdGgubG9nKGJhc2UpKSB7XHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIGJhc2UpO1xyXG5cdFx0XHRcdGlmKGlzTmFOKHJlc3VsdCkpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSBcIiArIGJhc2UgKyBcIi5cIik7XHJcblx0XHRcdFx0fVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIocGFyc2VJbnQodGV4dCwgYmFzZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhc2UgPSBwYXJzZVZhbHVlKGJhc2UpO1xyXG4gICAgICAgIHZhciBkaWdpdHMgPSBbXTtcclxuICAgICAgICB2YXIgaXNOZWdhdGl2ZSA9IHRleHRbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgIGZvciAoaSA9IGlzTmVnYXRpdmUgPyAxIDogMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2ldLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IGMuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKDQ4IDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDU3KSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMpKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoOTcgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTIyKSBkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMuY2hhckNvZGVBdCgwKSAtIDg3KSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiPFwiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBpO1xyXG4gICAgICAgICAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHRleHRbaV0gIT09IFwiPlwiKTtcclxuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKHBhcnNlVmFsdWUodGV4dC5zbGljZShzdGFydCArIDEsIGkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlclwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsIGJhc2UsIGlzTmVnYXRpdmUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IEludGVnZXJbMF0sIHBvdyA9IEludGVnZXJbMV0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hZGQoZGlnaXRzW2ldLnRpbWVzKHBvdykpO1xyXG4gICAgICAgICAgICBwb3cgPSBwb3cudGltZXMoYmFzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc05lZ2F0aXZlID8gdmFsLm5lZ2F0ZSgpIDogdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeShkaWdpdCkge1xyXG4gICAgICAgIGlmIChkaWdpdCA8PSAzNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQoZGlnaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCI8XCIgKyBkaWdpdCArIFwiPlwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvQmFzZShuLCBiYXNlKSB7XHJcbiAgICAgICAgYmFzZSA9IGJpZ0ludChiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIHt2YWx1ZTogWzBdLCBpc05lZ2F0aXZlOiBmYWxzZX07XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5vbnplcm8gbnVtYmVycyB0byBiYXNlIDAuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZS5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4ge3ZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlfTtcclxuICAgICAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0LmFwcGx5KFtdLCBBcnJheS5hcHBseShudWxsLCBBcnJheSgtbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLCBbMSwgMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgICAgIGlzTmVnYXRpdmU6IGZhbHNlXHJcbiAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBBcnJheS5hcHBseShudWxsLCBBcnJheSgrbiAtIDEpKVxyXG4gICAgICAgICAgICAgIC5tYXAoQXJyYXkucHJvdG90eXBlLnZhbHVlT2YsIFswLCAxXSk7XHJcbiAgICAgICAgICAgIGFyci51bnNoaWZ0KFsxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgdmFsdWU6IFtdLmNvbmNhdC5hcHBseShbXSwgYXJyKSxcclxuICAgICAgICAgICAgICBpc05lZ2F0aXZlOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG5lZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSAmJiBiYXNlLmlzUG9zaXRpdmUoKSkge1xyXG4gICAgICAgICAgICBuZWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBuID0gbi5hYnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2UuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzWmVybygpKSByZXR1cm4ge3ZhbHVlOiBbMF0sIGlzTmVnYXRpdmU6IGZhbHNlfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgdmFsdWU6IEFycmF5LmFwcGx5KG51bGwsIEFycmF5KCtuKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAubWFwKE51bWJlci5wcm90b3R5cGUudmFsdWVPZiwgMSksXHJcbiAgICAgICAgICAgICAgaXNOZWdhdGl2ZTogbmVnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXQgPSBbXTtcclxuICAgICAgICB2YXIgbGVmdCA9IG4sIGRpdm1vZDtcclxuICAgICAgICB3aGlsZSAobGVmdC5pc05lZ2F0aXZlKCkgfHwgbGVmdC5jb21wYXJlQWJzKGJhc2UpID49IDApIHtcclxuICAgICAgICAgICAgZGl2bW9kID0gbGVmdC5kaXZtb2QoYmFzZSk7XHJcbiAgICAgICAgICAgIGxlZnQgPSBkaXZtb2QucXVvdGllbnQ7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IGRpdm1vZC5yZW1haW5kZXI7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdC5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2l0ID0gYmFzZS5taW51cyhkaWdpdCkuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5uZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0LnB1c2goZGlnaXQudG9KU051bWJlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LnB1c2gobGVmdC50b0pTTnVtYmVyKCkpO1xyXG4gICAgICAgIHJldHVybiB7dmFsdWU6IG91dC5yZXZlcnNlKCksIGlzTmVnYXRpdmU6IG5lZ307XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9CYXNlU3RyaW5nKG4sIGJhc2UpIHtcclxuICAgICAgICB2YXIgYXJyID0gdG9CYXNlKG4sIGJhc2UpO1xyXG4gICAgICAgIHJldHVybiAoYXJyLmlzTmVnYXRpdmUgPyBcIi1cIiA6IFwiXCIpICsgYXJyLnZhbHVlLm1hcChzdHJpbmdpZnkpLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChyYWRpeCkge1xyXG4gICAgICByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT09IDEwKSByZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMsIHJhZGl4KTtcclxuICAgICAgICB2YXIgdiA9IHRoaXMudmFsdWUsIGwgPSB2Lmxlbmd0aCwgc3RyID0gU3RyaW5nKHZbLS1sXSksIHplcm9zID0gXCIwMDAwMDAwXCIsIGRpZ2l0O1xyXG4gICAgICAgIHdoaWxlICgtLWwgPj0gMCkge1xyXG4gICAgICAgICAgICBkaWdpdCA9IFN0cmluZyh2W2xdKTtcclxuICAgICAgICAgICAgc3RyICs9IHplcm9zLnNsaWNlKGRpZ2l0Lmxlbmd0aCkgKyBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpZ24gPSB0aGlzLnNpZ24gPyBcIi1cIiA6IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIHNpZ24gKyBzdHI7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHVuZGVmaW5lZCkgcmFkaXggPSAxMDtcclxuICAgICAgICBpZiAocmFkaXggIT0gMTApIHJldHVybiB0b0Jhc2VTdHJpbmcodGhpcywgcmFkaXgpO1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmdWYWx1ZSh2KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoK3YpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9ICt2O1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IHRydW5jYXRlKHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHgpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgdiA9IHYuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHYuc3BsaXQoL2UvaSk7XHJcbiAgICAgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAyKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgc3BsaXQuam9pbihcImVcIikpO1xyXG4gICAgICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwID0gc3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwWzBdID09PSBcIitcIikgZXhwID0gZXhwLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgZXhwID0gK2V4cDtcclxuICAgICAgICAgICAgICAgIGlmIChleHAgIT09IHRydW5jYXRlKGV4cCkgfHwgIWlzUHJlY2lzZShleHApKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgZXhwICsgXCIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzcGxpdFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsUGxhY2UgPSB0ZXh0LmluZGV4T2YoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwIC09IHRleHQubGVuZ3RoIC0gZGVjaW1hbFBsYWNlIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBkZWNpbWFsUGxhY2UpICsgdGV4dC5zbGljZShkZWNpbWFsUGxhY2UgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChleHAgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBuZWdhdGl2ZSBleHBvbmVudCBwYXJ0IGZvciBpbnRlZ2Vyc1wiKTtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gKG5ldyBBcnJheShleHAgKyAxKSkuam9pbihcIjBcIik7XHJcbiAgICAgICAgICAgICAgICB2ID0gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IC9eKFswLTldWzAtOV0qKSQvLnRlc3Qodik7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xyXG4gICAgICAgICAgICB2YXIgciA9IFtdLCBtYXggPSB2Lmxlbmd0aCwgbCA9IExPR19CQVNFLCBtaW4gPSBtYXggLSBsO1xyXG4gICAgICAgICAgICB3aGlsZSAobWF4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCt2LnNsaWNlKG1pbiwgbWF4KSk7XHJcbiAgICAgICAgICAgICAgICBtaW4gLT0gbDtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPCAwKSBtaW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgbWF4IC09IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJpbShyKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodikge1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UodikpIHtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHRydW5jYXRlKHYpKSB0aHJvdyBuZXcgRXJyb3IodiArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlclZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG4gICAgLy8gUHJlLWRlZmluZSBudW1iZXJzIGluIHJhbmdlIFstOTk5LDk5OV1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICAgICAgSW50ZWdlcltpXSA9IG5ldyBTbWFsbEludGVnZXIoaSk7XHJcbiAgICAgICAgaWYgKGkgPiAwKSBJbnRlZ2VyWy1pXSA9IG5ldyBTbWFsbEludGVnZXIoLWkpO1xyXG4gICAgfVxyXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgIEludGVnZXIub25lID0gSW50ZWdlclsxXTtcclxuICAgIEludGVnZXIuemVybyA9IEludGVnZXJbMF07XHJcbiAgICBJbnRlZ2VyLm1pbnVzT25lID0gSW50ZWdlclstMV07XHJcbiAgICBJbnRlZ2VyLm1heCA9IG1heDtcclxuICAgIEludGVnZXIubWluID0gbWluO1xyXG4gICAgSW50ZWdlci5nY2QgPSBnY2Q7XHJcbiAgICBJbnRlZ2VyLmxjbSA9IGxjbTtcclxuICAgIEludGVnZXIuaXNJbnN0YW5jZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgU21hbGxJbnRlZ2VyOyB9O1xyXG4gICAgSW50ZWdlci5yYW5kQmV0d2VlbiA9IHJhbmRCZXR3ZWVuO1xyXG5cclxuICAgIEludGVnZXIuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLm1hcChwYXJzZVZhbHVlKSwgcGFyc2VWYWx1ZShiYXNlIHx8IDEwKSwgaXNOZWdhdGl2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBJbnRlZ2VyO1xyXG59KSgpO1xyXG5cclxuLy8gTm9kZS5qcyBjaGVja1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoXCJleHBvcnRzXCIpKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpZ0ludDtcclxufVxyXG5cclxuLy9hbWQgY2hlY2tcclxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcclxuICBkZWZpbmUoIFwiYmlnLWludGVnZXJcIiwgW10sIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGJpZ0ludDtcclxuICB9KTtcclxufVxyXG4iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIi4vdHJ5dGVzXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgYWRkcmVzc2VzLlxyXG4gKi9cclxuY2xhc3MgQWRkcmVzcyB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3NUcnl0ZXMsIGNoZWNrc3VtVHJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5fYWRkcmVzc1RyeXRlcyA9IGFkZHJlc3NUcnl0ZXM7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tzdW1Ucnl0ZXMgPSBjaGVja3N1bVRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFkZHJlc3MgZnJvbSB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgdHJ5dGVzIHRvIGNyZWF0ZSB0aGUgYWRkcmVzcyBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgQWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21Ucnl0ZXMoYWRkcmVzcykge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgYWRkcmVzcyBzaG91bGQgYmUgYSB2YWxpZCBUcnl0ZXMgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0cnl0ZXNTdHJpbmcgPSBhZGRyZXNzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRyeXRlc1N0cmluZy5sZW5ndGggIT09IEFkZHJlc3MuTEVOR1RIICYmIHRyeXRlc1N0cmluZy5sZW5ndGggIT09IEFkZHJlc3MuTEVOR1RIX1dJVEhfQ0hFQ0tTVU0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIGFkZHJlc3Mgc2hvdWxkIGVpdGhlciBiZSAke0FkZHJlc3MuTEVOR1RIfSBvciAke0FkZHJlc3MuTEVOR1RIX1dJVEhfQ0hFQ0tTVU19IGNoYXJhY3RlcnMgaW4gbGVuZ3RoYCwgeyBsZW5ndGg6IHRyeXRlc1N0cmluZy5sZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NUcnl0ZXMgPSB0cnl0ZXNTdHJpbmcuc3Vic3RyKDAsIEFkZHJlc3MuTEVOR1RIKTtcclxuICAgICAgICBsZXQgY2hlY2tzdW1Ucnl0ZXM7XHJcbiAgICAgICAgaWYgKHRyeXRlc1N0cmluZy5sZW5ndGggPT09IEFkZHJlc3MuTEVOR1RIX1dJVEhfQ0hFQ0tTVU0pIHtcclxuICAgICAgICAgICAgY2hlY2tzdW1Ucnl0ZXMgPSB0cnl0ZXNTdHJpbmcuc3Vic3RyKEFkZHJlc3MuTEVOR1RIKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRyZXNzKGFkZHJlc3NUcnl0ZXMsIGNoZWNrc3VtVHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgYWRkcmVzcyB0byB0cnl0ZXMgd2l0aCBubyBjaGVja3N1bS5cclxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSBhZGRyZXNzIHdpdGggbm8gY2hlY2tzdW0uXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0aGlzLl9hZGRyZXNzVHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgYWRkcmVzcyB0byB0cnl0ZXMgd2l0aCBhIGNoZWNrc3VtLCBjcmVhdGluZyBhIGJsYW5rIG9uZSBpZiBuZWVkZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgYWRkcmVzcyB3aXRoIGNoZWNrc3UsLlxyXG4gICAgICovXHJcbiAgICB0b1RyeXRlc1dpdGhDaGVja3N1bSgpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHRoaXMuX2NoZWNrc3VtVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodGhpcy5fYWRkcmVzc1RyeXRlcyArIHRoaXMuX2NoZWNrc3VtVHJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoaXMgYWRkcmVzcyBoYXMgbm8gY2hlY2tzdW0gY2FsY3VsYXRlZCBmb3IgaXRgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHRoaXMuX2NoZWNrc3VtVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkcmVzc1RyeXRlcyArIHRoaXMuX2NoZWNrc3VtVHJ5dGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3NUcnl0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgbGVuZ3RoIGZvciBhIHZhbGlkIGFkZHJlc3Mgd2l0aG91dCBjaGVja3N1bSAoODEpLlxyXG4gKi9cclxuQWRkcmVzcy5MRU5HVEggPSA4MTtcclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggZm9yIGFuIGFkZHJlc3MgY2hlY2tzdW0gKDkpLlxyXG4gKi9cclxuQWRkcmVzcy5MRU5HVEhfQ0hFQ0tTVU0gPSA5O1xyXG4vKipcclxuICogVGhlIGxlbmd0aCBmb3IgdmFsaWQgYWRkcmVzcyB3aXRoIGNoZWNrc3VtICg5MCkuXHJcbiAqL1xyXG5BZGRyZXNzLkxFTkdUSF9XSVRIX0NIRUNLU1VNID0gQWRkcmVzcy5MRU5HVEggKyBBZGRyZXNzLkxFTkdUSF9DSEVDS1NVTTtcclxuLyoqXHJcbiAqIEFuIGVtcHR5IGhhc2ggYWxsIDlzLlxyXG4gKi9cclxuQWRkcmVzcy5FTVBUWSA9IEFkZHJlc3MuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcIjlcIi5yZXBlYXQoQWRkcmVzcy5MRU5HVEgpKSk7XHJcbmV4cG9ydHMuQWRkcmVzcyA9IEFkZHJlc3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlXUmtjbVZ6Y3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlrWVhSaEwyRmtaSEpsYzNNdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTERSRlFVRjVSVHRCUVVONlJTeHJSRUZCSzBNN1FVRkRMME1zY1VOQlFXdERPMEZCUld4RE96dEhRVVZITzBGQlEwZzdTVUYzUWtrc1pVRkJaVHRKUVVObUxGbEJRVzlDTEdGQlFYRkNMRVZCUVVVc1kwRkJjMEk3VVVGRE4wUXNTVUZCU1N4RFFVRkRMR05CUVdNc1IwRkJSeXhoUVVGaExFTkJRVU03VVVGRGNFTXNTVUZCU1N4RFFVRkRMR1ZCUVdVc1IwRkJTU3hqUVVGakxFTkJRVU03U1VGRE0wTXNRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFOUJRV1U3VVVGRGNFTXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEU5QlFVOHNSVUZCUlN4bFFVRk5MRU5CUVVNc1JVRkJSVHRaUVVOMlF5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXcyUTBGQk5rTXNRMEZCUXl4RFFVRkRPMU5CUTNSRk8xRkJSVVFzVFVGQlRTeFpRVUZaTEVkQlFVY3NUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xRkJSWGhETEVsQlFVa3NXVUZCV1N4RFFVRkRMRTFCUVUwc1MwRkJTeXhQUVVGUExFTkJRVU1zVFVGQlRTeEpRVUZKTEZsQlFWa3NRMEZCUXl4TlFVRk5MRXRCUVVzc1QwRkJUeXhEUVVGRExHOUNRVUZ2UWl4RlFVRkZPMWxCUTJoSExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMR2REUVVGblF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4UFFVRlBMRTlCUVU4c1EwRkJReXh2UWtGQmIwSXNkVUpCUVhWQ0xFVkJRVVVzUlVGQlJTeE5RVUZOTEVWQlFVVXNXVUZCV1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGJFczdVVUZGUkN4TlFVRk5MR0ZCUVdFc1IwRkJSeXhaUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSVUZCUlN4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRE4wUXNTVUZCU1N4alFVRmpMRU5CUVVNN1VVRkRia0lzU1VGQlNTeFpRVUZaTEVOQlFVTXNUVUZCVFN4TFFVRkxMRTlCUVU4c1EwRkJReXh2UWtGQmIwSXNSVUZCUlR0WlFVTjBSQ3hqUVVGakxFZEJRVWNzV1VGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VTBGRGVFUTdVVUZEUkN4UFFVRlBMRWxCUVVrc1QwRkJUeXhEUVVGRExHRkJRV0VzUlVGQlJTeGpRVUZqTEVOQlFVTXNRMEZCUXp0SlFVTjBSQ3hEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU03U1VGRGJFUXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEc5Q1FVRnZRanRSUVVOMlFpeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4RlFVRkZPMWxCUXpkRExFOUJRVThzWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1kwRkJZeXhIUVVGSExFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0VFFVTjRSVHRoUVVGTk8xbEJRMGdzVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc1owUkJRV2RFTEVOQlFVTXNRMEZCUXp0VFFVTjZSVHRKUVVOTUxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eGxRVUZsTEVOQlFVTXNSVUZCUlR0WlFVTTNReXhQUVVGUExFbEJRVWtzUTBGQlF5eGpRVUZqTEVkQlFVY3NTVUZCU1N4RFFVRkRMR1ZCUVdVc1EwRkJRenRUUVVOeVJEdGhRVUZOTzFsQlEwZ3NUMEZCVHl4SlFVRkpMRU5CUVVNc1kwRkJZeXhEUVVGRE8xTkJRemxDTzBsQlEwd3NRMEZCUXpzN1FVRnVSa1E3TzBkQlJVYzdRVUZEYjBJc1kwRkJUU3hIUVVGWExFVkJRVVVzUTBGQlF6dEJRVU16UXpzN1IwRkZSenRCUVVOdlFpeDFRa0ZCWlN4SFFVRlhMRU5CUVVNc1EwRkJRenRCUVVOdVJEczdSMEZGUnp0QlFVTnZRaXcwUWtGQmIwSXNSMEZCVnl4UFFVRlBMRU5CUVVNc1RVRkJUU3hIUVVGSExFOUJRVThzUTBGQlF5eGxRVUZsTEVOQlFVTTdRVUZGTDBZN08wZEJSVWM3UVVGRGIwSXNZVUZCU3l4SFFVRlpMRTlCUVU4c1EwRkJReXhWUVVGVkxFTkJRVU1zWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRnFRamxITERCQ1FYRkdReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBlbnVtIGZvciB0aGUgYWRkcmVzcyBzZWN1cml0eSB2YWx1ZXMuXHJcbiAqL1xyXG52YXIgQWRkcmVzc1NlY3VyaXR5O1xyXG4oZnVuY3Rpb24gKEFkZHJlc3NTZWN1cml0eSkge1xyXG4gICAgQWRkcmVzc1NlY3VyaXR5W0FkZHJlc3NTZWN1cml0eVtcImxvd1wiXSA9IDFdID0gXCJsb3dcIjtcclxuICAgIEFkZHJlc3NTZWN1cml0eVtBZGRyZXNzU2VjdXJpdHlbXCJtZWRpdW1cIl0gPSAyXSA9IFwibWVkaXVtXCI7XHJcbiAgICBBZGRyZXNzU2VjdXJpdHlbQWRkcmVzc1NlY3VyaXR5W1wiaGlnaFwiXSA9IDNdID0gXCJoaWdoXCI7XHJcbn0pKEFkZHJlc3NTZWN1cml0eSA9IGV4cG9ydHMuQWRkcmVzc1NlY3VyaXR5IHx8IChleHBvcnRzLkFkZHJlc3NTZWN1cml0eSA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlXUmtjbVZ6YzFObFkzVnlhWFI1TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlJoZEdFdllXUmtjbVZ6YzFObFkzVnlhWFI1TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRVHM3UjBGRlJ6dEJRVU5JTEVsQlFWa3NaVUZKV0R0QlFVcEVMRmRCUVZrc1pVRkJaVHRKUVVOMlFpeHRSRUZCVVN4RFFVRkJPMGxCUTFJc2VVUkJRVlVzUTBGQlFUdEpRVU5XTEhGRVFVRlJMRU5CUVVFN1FVRkRXaXhEUVVGRExFVkJTbGNzWlVGQlpTeEhRVUZtTEhWQ1FVRmxMRXRCUVdZc2RVSkJRV1VzVVVGSk1VSWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xyXG5jb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCIuL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuY29uc3QgdGFnXzEgPSByZXF1aXJlKFwiLi90YWdcIik7XHJcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcclxuY29uc3QgdHJ5dGVOdW1iZXJfMSA9IHJlcXVpcmUoXCIuL3RyeXRlTnVtYmVyXCIpO1xyXG4vKipcclxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgYnVuZGxlcy5cclxuICovXHJcbmNsYXNzIEJ1bmRsZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBCdW5kbGUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBuZXcgdHJhbnNhY3Rpb25zIHRvIHRoZSBidW5kbGUuXHJcbiAgICAgKiBAcGFyYW0gc2lnbmF0dXJlTWVzc2FnZUxlbmd0aCBUaGUgbnVtYmVyIG9mIHRyYW5zYWN0aW9ucyB0byBhZGQuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyBmb3IgdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBmaXJzdCBvZiB0aGUgdHJhbnNhY3Rpb25zLlxyXG4gICAgICogQHBhcmFtIHRhZyBUaGUgdGFnIHRvIGluY2x1ZGUgaW4gdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcCBmb3IgdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYWRkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZU1lc3NhZ2VMZW5ndGgsIGFkZHJlc3MsIHZhbHVlLCB0YWcsIHRpbWVzdGFtcCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlTWVzc2FnZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tUGFyYW1zKHVuZGVmaW5lZCwgYWRkcmVzcywgaSA9PT0gMCA/IHZhbHVlIDogMCwgdGFnLCB0aW1lc3RhbXAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0YWcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHNpZ25hdHVyZSBmcmFnbWVudHMgdG8gdGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzIFRoZSBzaWduYXR1cmUgZnJhZ21lbnRzIHRvIGFkZCB0byB0aGUgYnVuZGxlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgYWRkU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzKSB7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSAoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50c1tpXSB8fCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuRU1QVFkpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS50cnVua1RyYW5zYWN0aW9uID0gaGFzaF8xLkhhc2guRU1QVFk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLmJyYW5jaFRyYW5zYWN0aW9uID0gaGFzaF8xLkhhc2guRU1QVFk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLmF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85O1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS5hdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOTtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNbaV0ubm9uY2UgPSB0YWdfMS5UYWcuRU1QVFk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQnVuZGxlID0gQnVuZGxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZblZ1Wkd4bExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJSaGRHRXZZblZ1Wkd4bExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3MFJVRkJlVVU3UVVGRGVrVXNhMFJCUVN0RE8wRkJSUzlETEdsRFFVRTRRanRCUVVNNVFpeDVSVUZCYzBVN1FVRkRkRVVzSzBKQlFUUkNPMEZCUXpWQ0xDdERRVUUwUXp0QlFVTTFReXdyUTBGQk5FTTdRVUZGTlVNN08wZEJSVWM3UVVGRFNEdEpRVlZKT3p0UFFVVkhPMGxCUTBnN1VVRkRTU3hKUVVGSkxFTkJRVU1zV1VGQldTeEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wbEJSVVE3T3pzN096czdUMEZQUnp0SlFVTkpMR1ZCUVdVc1EwRkJReXh6UWtGQk9FSXNSVUZCUlN4UFFVRm5RaXhGUVVGRkxFdEJRV0VzUlVGQlJTeEhRVUZSTEVWQlFVVXNVMEZCYVVJN1VVRkRMMGNzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExITkNRVUZ6UWl4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRk8xbEJRemRETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1NVRkJTU3hEUVVGRExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNSMEZCUnl4RlFVTTFReXhUUVVGVExFVkJRVVVzVTBGQlV5eEZRVUZGTEZOQlFWTXNSVUZCUlN4VFFVRlRMRVZCUXpGRExGTkJRVk1zUlVGQlJTeFRRVUZUTEVWQlFVVXNSMEZCUnl4RlFVRkZMRk5CUVZNc1JVRkRjRU1zVTBGQlV5eEZRVUZGTEZOQlFWTXNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xTkJRMjVHTzBsQlEwd3NRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTERSQ1FVRTBRaXhEUVVGRExIbENRVUZ4UkR0UlFVTnlSaXhKUVVGSkxESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMSGxDUVVGNVFpeERRVUZETEVWQlFVVTdXVUZEYWtRc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNLMFZCUVN0RkxFTkJRVU1zUTBGQlF6dFRRVU40Unp0UlFVVkVMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0WlFVTXZReXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMSGRDUVVGM1FpeEhRVUZITEVOQlFVTXNlVUpCUVhsQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NiVVJCUVhkQ0xFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdXVUZEYWtnc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUjBGQlJ5eFhRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRPMWxCUTI1RUxFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEVkQlFVY3NWMEZCU1N4RFFVRkRMRXRCUVVzc1EwRkJRenRaUVVOd1JDeEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExHMUNRVUZ0UWl4SFFVRkhMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETzFsQlF5OUVMRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNOa0pCUVRaQ0xFZEJRVWNzZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNN1dVRkRla1VzU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXcyUWtGQk5rSXNSMEZCUnl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF6dFpRVU42UlN4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NSMEZCUnl4VFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRE8xTkJRekZETzBsQlEwd3NRMEZCUXp0RFFVTktPMEZCY2tSRUxIZENRWEZFUXlKOSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBoYXNoZXMuXHJcbiAqL1xyXG5jbGFzcyBIYXNoIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IodHJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaGFzaCBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSB0cnl0ZXMgdG8gY3JlYXRlIHRoZSBoYXNoIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBIYXNoLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVRyeXRlcyhoYXNoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGhhc2gsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBoYXNoIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGhhc2gubGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gSGFzaC5MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIGhhc2ggc2hvdWxkIGJlICR7SGFzaC5MRU5HVEh9IGNoYXJhY3RlcnMgaW4gbGVuZ3RoYCwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgSGFzaChoYXNoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgaGFzaCB0byB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgaGFzaC5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXMudG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGxlbmd0aCBmb3IgYSB2YWxpZCBoYXNoICg4MSkuXHJcbiAqL1xyXG5IYXNoLkxFTkdUSCA9IDgxO1xyXG4vKipcclxuICogQW4gZW1wdHkgaGFzaCBhbGwgOXMuXHJcbiAqL1xyXG5IYXNoLkVNUFRZID0gSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKFwiOVwiLnJlcGVhdChIYXNoLkxFTkdUSCkpKTtcclxuZXhwb3J0cy5IYXNoID0gSGFzaDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYUdGemFDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5a1lYUmhMMmhoYzJndWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEJRVUZCTERSRlFVRjVSVHRCUVVONlJTeHJSRUZCSzBNN1FVRkRMME1zY1VOQlFXdERPMEZCUld4RE96dEhRVVZITzBGQlEwZzdTVUZoU1N4bFFVRmxPMGxCUTJZc1dVRkJiMElzVFVGQll6dFJRVU01UWl4SlFVRkpMRU5CUVVNc1QwRkJUeXhIUVVGSExFMUJRVTBzUTBGQlF6dEpRVU14UWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQldUdFJRVU5xUXl4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RlFVRkZMR1ZCUVUwc1EwRkJReXhGUVVGRk8xbEJRM0JETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExEQkRRVUV3UXl4RFFVRkRMRU5CUVVNN1UwRkRia1U3VVVGRlJDeE5RVUZOTEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU03VVVGRE4wSXNTVUZCU1N4TlFVRk5MRXRCUVVzc1NVRkJTU3hEUVVGRExFMUJRVTBzUlVGQlJUdFpRVU40UWl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHpRa0ZCYzBJc1NVRkJTU3hEUVVGRExFMUJRVTBzZFVKQlFYVkNMRVZCUVVVc1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlF6ZEdPMUZCUlVRc1QwRkJUeXhKUVVGSkxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTXhRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTjRRaXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRKUVVOdVF5eERRVUZET3p0QlFXcEVSRHM3UjBGRlJ6dEJRVU52UWl4WFFVRk5MRWRCUVZjc1JVRkJSU3hEUVVGRE8wRkJRek5ET3p0SFFVVkhPMEZCUTI5Q0xGVkJRVXNzUjBGQlV5eEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlVuSkhMRzlDUVcxRVF5SjkiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzXCIpO1xyXG5jb25zdCBhZGRyZXNzU2VjdXJpdHlfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NTZWN1cml0eVwiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIGlucHV0cy5cclxuICovXHJcbmNsYXNzIElucHV0IHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiBpbnB1dCBmcm9tIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgYWRkcmVzcyBzZWN1cml0eS5cclxuICAgICAqIEBwYXJhbSBrZXlJbmRleCBUaGUga2V5IGluZGV4LlxyXG4gICAgICogQHBhcmFtIGJhbGFuY2UgVGhlIGJhbGFuY2Ugb2YgdGhlIGFkZHJlc3MuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgaW5zdGFuY2Ugb2YgSW5wdXQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUGFyYW1zKGFkZHJlc3MsIHNlY3VyaXR5LCBrZXlJbmRleCwgYmFsYW5jZSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhIHZhbGlkIEFkZHJlc3Mgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5LmxvdyB8fCBzZWN1cml0eSA+IGFkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzZWN1cml0eSBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAke2FkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5sb3d9IGFuZCAke2FkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5oaWdofWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoa2V5SW5kZXgpIHx8IGtleUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGtleUluZGV4IHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoYmFsYW5jZSkgfHwgYmFsYW5jZSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBiYWxhbmNlIHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnB1dCA9IG5ldyBJbnB1dCgpO1xyXG4gICAgICAgIGlucHV0LmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICAgIGlucHV0LnNlY3VyaXR5ID0gc2VjdXJpdHk7XHJcbiAgICAgICAgaW5wdXQua2V5SW5kZXggPSBrZXlJbmRleDtcclxuICAgICAgICBpbnB1dC5iYWxhbmNlID0gYmFsYW5jZTtcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5JbnB1dCA9IElucHV0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzV3ZFhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdGMFlTOXBibkIxZEM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTkVWQlFYbEZPMEZCUTNwRkxEUkZRVUY1UlR0QlFVTjZSU3hyUkVGQkswTTdRVUZETDBNc2RVTkJRVzlETzBGQlEzQkRMSFZFUVVGdlJEdEJRVVZ3UkRzN1IwRkZSenRCUVVOSU8wbEJhMEpKTEdWQlFXVTdTVUZEWmp0SlFVTkJMRU5CUVVNN1NVRkZSRHM3T3pzN096dFBRVTlITzBsQlEwa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhQUVVGblFpeEZRVU5vUWl4UlFVRjVRaXhGUVVONlFpeFJRVUZuUWl4RlFVTm9RaXhQUVVGbE8xRkJRM0JETEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVWQlFVVXNhVUpCUVU4c1EwRkJReXhGUVVGRk8xbEJRM2hETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExEaERRVUU0UXl4RFFVRkRMRU5CUVVNN1UwRkRka1U3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NVVUZCVVN4SFFVRkhMR2xEUVVGbExFTkJRVU1zUjBGQlJ5eEpRVUZKTEZGQlFWRXNSMEZCUnl4cFEwRkJaU3hEUVVGRExFbEJRVWtzUlVGQlJUdFpRVU40Unl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3lRMEZCTWtNc2FVTkJRV1VzUTBGQlF5eEhRVUZITEZGQlFWRXNhVU5CUVdVc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlEzSklPMUZCUlVRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxGRkJRVkVzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZEYmtRc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNjME5CUVhORExFTkJRVU1zUTBGQlF6dFRRVU12UkR0UlFVVkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hQUVVGUExFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlEycEVMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEhGRFFVRnhReXhEUVVGRExFTkJRVU03VTBGRE9VUTdVVUZGUkN4TlFVRk5MRXRCUVVzc1IwRkJSeXhKUVVGSkxFdEJRVXNzUlVGQlJTeERRVUZETzFGQlF6RkNMRXRCUVVzc1EwRkJReXhQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETzFGQlEzaENMRXRCUVVzc1EwRkJReXhSUVVGUkxFZEJRVWNzVVVGQlVTeERRVUZETzFGQlF6RkNMRXRCUVVzc1EwRkJReXhSUVVGUkxFZEJRVWNzVVVGQlVTeERRVUZETzFGQlF6RkNMRXRCUVVzc1EwRkJReXhQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETzFGQlEzaENMRTlCUVU4c1MwRkJTeXhEUVVGRE8wbEJRMnBDTEVOQlFVTTdRMEZEU2p0QlFYcEVSQ3h6UWtGNVJFTWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50cy5cclxuICovXHJcbmNsYXNzIFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHNpZ25hdHVyZSBmcmFnbWVudCBmcm9tIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgVGhlIHRyeXRlcyB0byBjcmVhdGUgdGhlIHNpZ25hdHVyZSBmcmFnbWVudCBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVRyeXRlcyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5sZW5ndGgoKTtcclxuICAgICAgICBpZiAobGVuZ3RoICE9PSBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgc2hvdWxkIGJlICR7U2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSH0gY2hhcmFjdGVycyBpbiBsZW5ndGhgLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgc2lnbmF0dXJlIGZyYWdtZW50IHRvIHRyeXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSBzaWduYXR1cmUgZnJhZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBsZW5ndGggb2YgYSB2YWxpZCBzaWduYXR1cmUgbWVzc2FnZSBmcmFnbWVudCAoMjE4NylcclxuICovXHJcblNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEggPSAyMTg3O1xyXG4vKipcclxuICogQW4gZW1wdHkgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQgYWxsIDlzLlxyXG4gKi9cclxuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkVNUFRZID0gU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoXCI5XCIucmVwZWF0KFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpKSk7XHJcbmV4cG9ydHMuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ID0gU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMmxuYm1GMGRYSmxUV1Z6YzJGblpVWnlZV2R0Wlc1MExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJSaGRHRXZjMmxuYm1GMGRYSmxUV1Z6YzJGblpVWnlZV2R0Wlc1MExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3MFJVRkJlVVU3UVVGRGVrVXNhMFJCUVN0RE8wRkJReTlETEhGRFFVRnJRenRCUVVWc1F6czdSMEZGUnp0QlFVTklPMGxCWVVrc1pVRkJaVHRKUVVObUxGbEJRVzlDTEUxQlFXTTdVVUZET1VJc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eE5RVUZOTEVOQlFVTTdTVUZETVVJc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEhkQ1FVRm5RenRSUVVOeVJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zZDBKQlFYZENMRVZCUVVVc1pVRkJUU3hEUVVGRExFVkJRVVU3V1VGRGVFUXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zT0VSQlFUaEVMRU5CUVVNc1EwRkJRenRUUVVOMlJqdFJRVVZFTEUxQlFVMHNUVUZCVFN4SFFVRkhMSGRDUVVGM1FpeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRPMUZCUTJwRUxFbEJRVWtzVFVGQlRTeExRVUZMTEhkQ1FVRjNRaXhEUVVGRExFMUJRVTBzUlVGQlJUdFpRVU0xUXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3dRMEZCTUVNc2QwSkJRWGRDTEVOQlFVTXNUVUZCVFN4MVFrRkJkVUlzUlVGQlJTeEZRVUZGTEUxQlFVMHNSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRja2s3VVVGRFJDeFBRVUZQTEVsQlFVa3NkMEpCUVhkQ0xFTkJRVU1zZDBKQlFYZENMRU5CUVVNc1EwRkJRenRKUVVOc1JTeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVVVGQlVUdFJRVU5ZTEU5QlFVOHNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJRenRKUVVONFFpeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVVVGQlVUdFJRVU5ZTEU5QlFVOHNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dEpRVU51UXl4RFFVRkRPenRCUVdoRVJEczdSMEZGUnp0QlFVTnZRaXdyUWtGQlRTeEhRVUZYTEVsQlFVa3NRMEZCUXp0QlFVTTNRenM3UjBGRlJ6dEJRVU52UWl3NFFrRkJTeXhIUVVFMlFpeDNRa0ZCZDBJc1EwRkJReXhWUVVGVkxFTkJRVU1zWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExIZENRVUYzUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEJRVkpxU3l3MFJFRnJSRU1pZlE9PSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB0YWdzLlxyXG4gKi9cclxuY2xhc3MgVGFnIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IodHJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdGFnIGZyb20gdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHRhZyBUaGUgdHJ5dGVzIHRvIGNyZWF0ZSB0aGUgdGFnIGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUYWcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKHRhZykge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0YWcsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB0YWcgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRyeXRlc1N0cmluZyA9IHRhZy50b1N0cmluZygpO1xyXG4gICAgICAgIGlmICh0cnl0ZXNTdHJpbmcubGVuZ3RoID4gVGFnLkxFTkdUSCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgdGFnIHNob3VsZCBiZSBhdCBtb3N0ICR7VGFnLkxFTkdUSH0gY2hhcmFjdGVycyBpbiBsZW5ndGhgLCB7IGxlbmd0aDogdHJ5dGVzU3RyaW5nLmxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRyeXRlc1N0cmluZy5sZW5ndGggPCBUYWcuTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRyeXRlc1N0cmluZyArPSBcIjlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUYWcodHJ5dGVzU3RyaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgdGFnIHRvIHRyeXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSB0YWcuXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0aGlzLl90cnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGxlbmd0aCBvZiBhIHZhbGlkIHRhZyAoMjcpLlxyXG4gKi9cclxuVGFnLkxFTkdUSCA9IDI3O1xyXG4vKipcclxuICogQW4gZW1wdHkgdGFnIGFsbCA5cy5cclxuICovXHJcblRhZy5FTVBUWSA9IFRhZy5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKFwiOVwiLnJlcGVhdChUYWcuTEVOR1RIKSkpO1xyXG5leHBvcnRzLlRhZyA9IFRhZztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEdGbkxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJSaGRHRXZkR0ZuTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3cwUlVGQmVVVTdRVUZEZWtVc2EwUkJRU3RETzBGQlF5OURMSEZEUVVGclF6dEJRVVZzUXpzN1IwRkZSenRCUVVOSU8wbEJZVWtzWlVGQlpUdEpRVU5tTEZsQlFXOUNMRTFCUVdNN1VVRkRPVUlzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRNVUlzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWRCUVZjN1VVRkRhRU1zU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUlVGQlJTeGxRVUZOTEVOQlFVTXNSVUZCUlR0WlFVTnVReXhOUVVGTkxFbEJRVWtzY1VKQlFWTXNRMEZCUXl4NVEwRkJlVU1zUTBGQlF5eERRVUZETzFOQlEyeEZPMUZCUlVRc1NVRkJTU3haUVVGWkxFZEJRVWNzUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMUZCUld4RExFbEJRVWtzV1VGQldTeERRVUZETEUxQlFVMHNSMEZCUnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hGUVVGRk8xbEJRMnhETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExEWkNRVUUyUWl4SFFVRkhMRU5CUVVNc1RVRkJUU3gxUWtGQmRVSXNSVUZCUlN4RlFVRkZMRTFCUVUwc1JVRkJSU3haUVVGWkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTjRTRHRSUVVWRUxFOUJRVThzV1VGQldTeERRVUZETEUxQlFVMHNSMEZCUnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hGUVVGRk8xbEJRM0pETEZsQlFWa3NTVUZCU1N4SFFVRkhMRU5CUVVNN1UwRkRka0k3VVVGRlJDeFBRVUZQTEVsQlFVa3NSMEZCUnl4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRE8wbEJRMnBETEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeFJRVUZSTzFGQlExZ3NUMEZCVHl4bFFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTXpReXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVThzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTjRRaXhEUVVGRE96dEJRWFJFUkRzN1IwRkZSenRCUVVOdlFpeFZRVUZOTEVkQlFWY3NSVUZCUlN4RFFVRkRPMEZCUXpORE96dEhRVVZITzBGQlEyOUNMRk5CUVVzc1IwRkJVU3hIUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEdWQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJVbXhITEd0Q1FYZEVReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzXCIpO1xyXG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi9oYXNoXCIpO1xyXG5jb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCIuL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuY29uc3QgdGFnXzEgPSByZXF1aXJlKFwiLi90YWdcIik7XHJcbmNvbnN0IHRyeXRlTnVtYmVyXzEgPSByZXF1aXJlKFwiLi90cnl0ZU51bWJlclwiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB0cmFuc2FjdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvbiB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJhbnNhY3Rpb24gZnJvbSBwYXJhbWV0ZXJzLlxyXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBUaGUgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gb2Jzb2xldGVUYWcgT2Jzb2xldGUgdHJhbnNhY3Rpb24gdGFnLlxyXG4gICAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wLlxyXG4gICAgICogQHBhcmFtIGN1cnJlbnRJbmRleCBUaGUgY3VycmVudCBpbmRleC5cclxuICAgICAqIEBwYXJhbSBsYXN0SW5kZXggVGhlIGxhc3QgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUuXHJcbiAgICAgKiBAcGFyYW0gdHJ1bmtUcmFuc2FjdGlvbiBUaGUgdHJ1bmsgdHJhbnNhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gYnJhbmNoVHJhbnNhY3Rpb24gVGhlIGJyYW5jaCB0cmFuc2FjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0YWcgVGhlIHRhZy5cclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50VGltZXN0YW1wIFRoZSBhdHRhY2htZW50IHRpbWVzdGFtcC5cclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCBUaGUgYXR0YWNobWVudCB0aW1lc3RhbXAgbG93ZXIgYm91bmQuXHJcbiAgICAgKiBAcGFyYW0gYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgIFRoZSBhdHRhY2htZW50IHRpbWVzdGFtcCB1cHBlciBib3VuZC5cclxuICAgICAqIEBwYXJhbSBub25jZSBUaGUgbm9uY2UuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgaW5zdGFuY2Ugb2YgdHJhbnNhY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUGFyYW1zKHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCwgYWRkcmVzcywgdmFsdWUsIG9ic29sZXRlVGFnLCB0aW1lc3RhbXAsIGN1cnJlbnRJbmRleCwgbGFzdEluZGV4LCBidW5kbGUsIHRydW5rVHJhbnNhY3Rpb24sIGJyYW5jaFRyYW5zYWN0aW9uLCB0YWcsIGF0dGFjaG1lbnRUaW1lc3RhbXAsIGF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kLCBhdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCwgbm9uY2UpIHtcclxuICAgICAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xyXG4gICAgICAgIHR4LnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudDtcclxuICAgICAgICB0eC5hZGRyZXNzID0gYWRkcmVzcztcclxuICAgICAgICB0eC52YWx1ZSA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcih2YWx1ZSwgMTEpO1xyXG4gICAgICAgIHR4Lm9ic29sZXRlVGFnID0gb2Jzb2xldGVUYWc7XHJcbiAgICAgICAgdHgudGltZXN0YW1wID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgdHguY3VycmVudEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGN1cnJlbnRJbmRleCk7XHJcbiAgICAgICAgdHgubGFzdEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGxhc3RJbmRleCk7XHJcbiAgICAgICAgdHguYnVuZGxlID0gYnVuZGxlO1xyXG4gICAgICAgIHR4LnRydW5rVHJhbnNhY3Rpb24gPSB0cnVua1RyYW5zYWN0aW9uO1xyXG4gICAgICAgIHR4LmJyYW5jaFRyYW5zYWN0aW9uID0gYnJhbmNoVHJhbnNhY3Rpb247XHJcbiAgICAgICAgdHgudGFnID0gdGFnO1xyXG4gICAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYXR0YWNobWVudFRpbWVzdGFtcCk7XHJcbiAgICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQpO1xyXG4gICAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kKTtcclxuICAgICAgICB0eC5ub25jZSA9IG5vbmNlO1xyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHRyYW5zYWN0aW9uIGZyb20gdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIGZvciB0aGUgdGhpcy5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKHRyeXRlcykge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cnl0ZXMsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB0cnl0ZXMgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdHJ5dGVzLmxlbmd0aCgpO1xyXG4gICAgICAgIGlmIChsZW5ndGggIT09IFRyYW5zYWN0aW9uLkxFTkdUSCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgdHJ5dGVzIG11c3QgYmUgJHtUcmFuc2FjdGlvbi5MRU5HVEh9IGluIGxlbmd0aGAsIHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGVja0luZGV4U3RhcnQgPSAyMjc5O1xyXG4gICAgICAgIGNvbnN0IGNoZWNrSW5kZXhMZW5ndGggPSAxNjtcclxuICAgICAgICBjb25zdCBjaGVjayA9IHRyeXRlcy5zdWIoY2hlY2tJbmRleFN0YXJ0LCBjaGVja0luZGV4TGVuZ3RoKS50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChjaGVjayAhPT0gVHJhbnNhY3Rpb24uQ0hFQ0tfVkFMVUUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIHRyeXRlcyBiZXR3ZWVuICR7Y2hlY2tJbmRleFN0YXJ0fSBhbmQgJHtjaGVja0luZGV4U3RhcnQgKyBjaGVja0luZGV4TGVuZ3RofSBzaG91bGQgYmUgYWxsIDlzYCwgeyBjaGVjayB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb24oKTtcclxuICAgICAgICBsZXQgc3RhcnRQb3MgPSAwO1xyXG4gICAgICAgIHR4LnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpKTtcclxuICAgICAgICBzdGFydFBvcyArPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIO1xyXG4gICAgICAgIHR4LmFkZHJlc3MgPSBhZGRyZXNzXzEuQWRkcmVzcy5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIGFkZHJlc3NfMS5BZGRyZXNzLkxFTkdUSCkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IGFkZHJlc3NfMS5BZGRyZXNzLkxFTkdUSDtcclxuICAgICAgICB0eC52YWx1ZSA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCAxMSksIDExKTtcclxuICAgICAgICBzdGFydFBvcyArPSAxMTtcclxuICAgICAgICBzdGFydFBvcyArPSBUcmFuc2FjdGlvbi5DSEVDS19WQUxVRV9MRU5HVEg7XHJcbiAgICAgICAgdHgub2Jzb2xldGVUYWcgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0YWdfMS5UYWcuTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gdGFnXzEuVGFnLkxFTkdUSDtcclxuICAgICAgICB0eC50aW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XHJcbiAgICAgICAgdHguY3VycmVudEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzkpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85O1xyXG4gICAgICAgIHR4Lmxhc3RJbmRleCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85KSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOTtcclxuICAgICAgICB0eC5idW5kbGUgPSBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIGhhc2hfMS5IYXNoLkxFTkdUSCkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IGhhc2hfMS5IYXNoLkxFTkdUSDtcclxuICAgICAgICB0eC50cnVua1RyYW5zYWN0aW9uID0gaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCBoYXNoXzEuSGFzaC5MRU5HVEgpKTtcclxuICAgICAgICBzdGFydFBvcyArPSBoYXNoXzEuSGFzaC5MRU5HVEg7XHJcbiAgICAgICAgdHguYnJhbmNoVHJhbnNhY3Rpb24gPSBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIGhhc2hfMS5IYXNoLkxFTkdUSCkpO1xyXG4gICAgICAgIHN0YXJ0UG9zICs9IGhhc2hfMS5IYXNoLkxFTkdUSDtcclxuICAgICAgICB0eC50YWcgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0YWdfMS5UYWcuTEVOR1RIKSk7XHJcbiAgICAgICAgc3RhcnRQb3MgKz0gdGFnXzEuVGFnLkxFTkdUSDtcclxuICAgICAgICB0eC5hdHRhY2htZW50VGltZXN0YW1wID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzkpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85O1xyXG4gICAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXBMb3dlckJvdW5kID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzkpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85O1xyXG4gICAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzkpKTtcclxuICAgICAgICBzdGFydFBvcyArPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85O1xyXG4gICAgICAgIHR4Lm5vbmNlID0gdGFnXzEuVGFnLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdGFnXzEuVGFnLkxFTkdUSCkpO1xyXG4gICAgICAgIHJldHVybiB0eDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgdHJhbnNhY3Rpb24gdG8gdHJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIGFzIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdG9Ucnl0ZXMoKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc2AsIHsgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50OiB0aGlzLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMuYWRkcmVzcywgYWRkcmVzc18xLkFkZHJlc3MpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBhZGRyZXNzIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNgLCB7IGFkZHJlc3M6IHRoaXMuYWRkcmVzcyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMub2Jzb2xldGVUYWcsIHRhZ18xLlRhZykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIG9ic29sZXRlVGFnIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNgLCB7IG9ic29sZXRlVGFnOiB0aGlzLm9ic29sZXRlVGFnIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy5idW5kbGUsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgYnVuZGxlIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNgLCB7IGJ1bmRsZTogdGhpcy5idW5kbGUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLnRydW5rVHJhbnNhY3Rpb24sIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgdHJ1bmtUcmFuc2FjdGlvbiBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzYCwgeyB0cnVua1RyYW5zYWN0aW9uOiB0aGlzLnRydW5rVHJhbnNhY3Rpb24gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLmJyYW5jaFRyYW5zYWN0aW9uLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihgVGhlIGJyYW5jaFRyYW5zYWN0aW9uIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNgLCB7IGJyYW5jaFRyYW5zYWN0aW9uOiB0aGlzLmJyYW5jaFRyYW5zYWN0aW9uIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy5ub25jZSwgdGFnXzEuVGFnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgbm9uY2UgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc2AsIHsgbm9uY2U6IHRoaXMubm9uY2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyeXRlcyA9IHRoaXMuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArIHRoaXMuYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy52YWx1ZSB8fCBUcmFuc2FjdGlvbi5FTVBUWV8xMSkudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgVHJhbnNhY3Rpb24uQ0hFQ0tfVkFMVUVcclxuICAgICAgICAgICAgKyB0aGlzLm9ic29sZXRlVGFnLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLnRpbWVzdGFtcCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLmN1cnJlbnRJbmRleCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLmxhc3RJbmRleCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArIHRoaXMuYnVuZGxlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArIHRoaXMudHJ1bmtUcmFuc2FjdGlvbi50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyB0aGlzLmJyYW5jaFRyYW5zYWN0aW9uLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArICh0aGlzLnRhZyB8fCB0aGlzLm9ic29sZXRlVGFnKS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy5hdHRhY2htZW50VGltZXN0YW1wIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICsgKHRoaXMuYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgKyAodGhpcy5hdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICArIHRoaXMubm9uY2UudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRyeXRlcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCAhPT0gVHJhbnNhY3Rpb24uTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSB0cnl0ZXMgbXVzdCBiZSAke1RyYW5zYWN0aW9uLkxFTkdUSH0gaW4gbGVuZ3RoICR7bGVuZ3RofWAsIHsgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGB7XG5cXHRzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQ6IFwiJHsodGhpcy5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgfHwgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcblxcdGFkZHJlc3M6IFwiJHsodGhpcy5hZGRyZXNzIHx8IGFkZHJlc3NfMS5BZGRyZXNzLkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcblxcdHZhbHVlOiAkeyh0aGlzLnZhbHVlIHx8IFRyYW5zYWN0aW9uLkVNUFRZXzExKS50b051bWJlcigpfVxuXFx0b2Jzb2xldGVUYWc6IFwiJHsodGhpcy5vYnNvbGV0ZVRhZyB8fCB0YWdfMS5UYWcuRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxuXFx0dGltZXN0YW1wOiAkeyh0aGlzLnRpbWVzdGFtcCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvTnVtYmVyKCl9XG5cXHRjdXJyZW50SW5kZXg6ICR7KHRoaXMuY3VycmVudEluZGV4IHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9OdW1iZXIoKX1cblxcdGxhc3RJbmRleDogJHsodGhpcy5sYXN0SW5kZXggfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b051bWJlcigpfVxuXFx0YnVuZGxlOiBcIiR7KHRoaXMuYnVuZGxlIHx8IGhhc2hfMS5IYXNoLkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcblxcdHRydW5rVHJhbnNhY3Rpb246IFwiJHsodGhpcy50cnVua1RyYW5zYWN0aW9uIHx8IGhhc2hfMS5IYXNoLkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcblxcdGJyYW5jaFRyYW5zYWN0aW9uOiBcIiR7KHRoaXMuYnJhbmNoVHJhbnNhY3Rpb24gfHwgaGFzaF8xLkhhc2guRU1QVFkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKX1cIlxuXFx0dGFnOiBcIiR7KHRoaXMudGFnIHx8IHRoaXMub2Jzb2xldGVUYWcgfHwgdGFnXzEuVGFnLkVNUFRZKS50b1RyeXRlcygpLnRvU3RyaW5nKCl9XCJcblxcdGF0dGFjaG1lbnRUaW1lc3RhbXA6ICR7KHRoaXMuYXR0YWNobWVudFRpbWVzdGFtcCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvTnVtYmVyKCl9XG5cXHRhdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZDogJHsodGhpcy5hdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvTnVtYmVyKCl9XG5cXHRhdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZDogJHsodGhpcy5hdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvTnVtYmVyKCl9XG5cXHRub25jZTogXCIkeyh0aGlzLm5vbmNlIHx8IHRhZ18xLlRhZy5FTVBUWSkudG9Ucnl0ZXMoKS50b1N0cmluZygpfVwiXG59YDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGxlbmd0aCBvZiBhIHZhbGlkIHRyYW5zYWN0aW9uICgyNjczKS5cclxuICovXHJcblRyYW5zYWN0aW9uLkxFTkdUSCA9IDI2NzM7XHJcbi8qKlxyXG4gKiBUaGUgbGVuZ3RoIG9mIGEgdmFsaWQgY2hlY2sgdmFsdWUgKDE2KS5cclxuICovXHJcblRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFX0xFTkdUSCA9IDE2O1xyXG4vKipcclxuICogVGhlIGNoZWNrIHZhbHVlIGZvciBidW5kbGVzIGFsbCA5cy5cclxuICovXHJcblRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFID0gXCI5XCIucmVwZWF0KFRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFX0xFTkdUSCk7XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5UcmFuc2FjdGlvbi5FTVBUWV8xMSA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcigwLCAxMSk7XHJcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKaGJuTmhZM1JwYjI0dWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdGMFlTOTBjbUZ1YzJGamRHbHZiaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNORVZCUVhsRk8wRkJRM3BGTEd0RVFVRXJRenRCUVVNdlF5eDFRMEZCYjBNN1FVRkRjRU1zYVVOQlFUaENPMEZCUXpsQ0xIbEZRVUZ6UlR0QlFVTjBSU3dyUWtGQk5FSTdRVUZETlVJc0swTkJRVFJETzBGQlF6VkRMSEZEUVVGclF6dEJRVVZzUXpzN1IwRkZSenRCUVVOSU8wbEJaMFpKTEdWQlFXVTdTVUZEWmp0SlFVTkJMRU5CUVVNN1NVRkZSRHM3T3pzN096czdPenM3T3pzN096czdPMDlCYTBKSE8wbEJRMGtzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4M1FrRkJhMFFzUlVGRGJFUXNUMEZCWjBJc1JVRkRhRUlzUzBGQllTeEZRVU5pTEZkQlFXZENMRVZCUTJoQ0xGTkJRV2xDTEVWQlEycENMRmxCUVc5Q0xFVkJRM0JDTEZOQlFXbENMRVZCUTJwQ0xFMUJRVmtzUlVGRFdpeG5Ra0ZCYzBJc1JVRkRkRUlzYVVKQlFYVkNMRVZCUTNaQ0xFZEJRVkVzUlVGRFVpeHRRa0ZCTWtJc1JVRkRNMElzTmtKQlFYRkRMRVZCUTNKRExEWkNRVUZ4UXl4RlFVTnlReXhMUVVGVk8xRkJReTlDTEUxQlFVMHNSVUZCUlN4SFFVRkhMRWxCUVVrc1YwRkJWeXhGUVVGRkxFTkJRVU03VVVGRE4wSXNSVUZCUlN4RFFVRkRMSGRDUVVGM1FpeEhRVUZITEhkQ1FVRjNRaXhEUVVGRE8xRkJRM1pFTEVWQlFVVXNRMEZCUXl4UFFVRlBMRWRCUVVjc1QwRkJUeXhEUVVGRE8xRkJRM0pDTEVWQlFVVXNRMEZCUXl4TFFVRkxMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRemRETEVWQlFVVXNRMEZCUXl4WFFVRlhMRWRCUVVjc1YwRkJWeXhEUVVGRE8xRkJRemRDTEVWQlFVVXNRMEZCUXl4VFFVRlRMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1VVRkRha1FzUlVGQlJTeERRVUZETEZsQlFWa3NSMEZCUnl4NVFrRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXp0UlFVTjJSQ3hGUVVGRkxFTkJRVU1zVTBGQlV5eEhRVUZITEhsQ1FVRlhMRU5CUVVNc1ZVRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETzFGQlEycEVMRVZCUVVVc1EwRkJReXhOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZETzFGQlEyNUNMRVZCUVVVc1EwRkJReXhuUWtGQlowSXNSMEZCUnl4blFrRkJaMElzUTBGQlF6dFJRVU4yUXl4RlFVRkZMRU5CUVVNc2FVSkJRV2xDTEVkQlFVY3NhVUpCUVdsQ0xFTkJRVU03VVVGRGVrTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExFTkJRVU03VVVGRFlpeEZRVUZGTEVOQlFVTXNiVUpCUVcxQ0xFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNRMEZCUXp0UlFVTnlSU3hGUVVGRkxFTkJRVU1zTmtKQlFUWkNMRWRCUVVjc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNOa0pCUVRaQ0xFTkJRVU1zUTBGQlF6dFJRVU42Uml4RlFVRkZMRU5CUVVNc05rSkJRVFpDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zTmtKQlFUWkNMRU5CUVVNc1EwRkJRenRSUVVONlJpeEZRVUZGTEVOQlFVTXNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJRenRSUVVOcVFpeFBRVUZQTEVWQlFVVXNRMEZCUXp0SlFVTmtMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZqTzFGQlEyNURMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRVZCUVVVc1pVRkJUU3hEUVVGRExFVkJRVVU3V1VGRGRFTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zTkVOQlFUUkRMRU5CUVVNc1EwRkJRenRUUVVOeVJUdFJRVVZFTEUxQlFVMHNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dFJRVU12UWl4SlFVRkpMRTFCUVUwc1MwRkJTeXhYUVVGWExFTkJRVU1zVFVGQlRTeEZRVUZGTzFsQlF5OUNMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEhOQ1FVRnpRaXhYUVVGWExFTkJRVU1zVFVGQlRTeFpRVUZaTEVWQlFVVXNSVUZCUlN4TlFVRk5MRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRM3BHTzFGQlJVUXNUVUZCVFN4bFFVRmxMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRemRDTEUxQlFVMHNaMEpCUVdkQ0xFZEJRVWNzUlVGQlJTeERRVUZETzFGQlF6VkNMRTFCUVUwc1MwRkJTeXhIUVVGSExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNaVUZCWlN4RlFVRkZMR2RDUVVGblFpeERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1VVRkZka1VzU1VGQlNTeExRVUZMTEV0QlFVc3NWMEZCVnl4RFFVRkRMRmRCUVZjc1JVRkJSVHRaUVVOdVF5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXh6UWtGQmMwSXNaVUZCWlN4UlFVRlJMR1ZCUVdVc1IwRkJSeXhuUWtGQlowSXNiVUpCUVcxQ0xFVkJRVVVzUlVGQlJTeExRVUZMTEVWQlFVVXNRMEZCUXl4RFFVRkRPMU5CUTNSSk8xRkJSVVFzVFVGQlRTeEZRVUZGTEVkQlFVY3NTVUZCU1N4WFFVRlhMRVZCUVVVc1EwRkJRenRSUVVVM1FpeEpRVUZKTEZGQlFWRXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRha0lzUlVGQlJTeERRVUZETEhkQ1FVRjNRaXhIUVVGSExHMUVRVUYzUWl4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4dFJFRkJkMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNwSUxGRkJRVkVzU1VGQlNTeHRSRUZCZDBJc1EwRkJReXhOUVVGTkxFTkJRVU03VVVGRE5VTXNSVUZCUlN4RFFVRkRMRTlCUVU4c1IwRkJSeXhwUWtGQlR5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeHBRa0ZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFVXNVVUZCVVN4SlFVRkpMR2xDUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETzFGQlF6TkNMRVZCUVVVc1EwRkJReXhMUVVGTExFZEJRVWNzZVVKQlFWY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eFJRVUZSTEVWQlFVVXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRGFFVXNVVUZCVVN4SlFVRkpMRVZCUVVVc1EwRkJRenRSUVVObUxGRkJRVkVzU1VGQlNTeFhRVUZYTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU03VVVGRE0wTXNSVUZCUlN4RFFVRkRMRmRCUVZjc1IwRkJSeXhUUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxGTkJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJ4RkxGRkJRVkVzU1VGQlNTeFRRVUZITEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUTNaQ0xFVkJRVVVzUTBGQlF5eFRRVUZUTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUVVVc2VVSkJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJ4R0xGRkJRVkVzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRkZCUVZFc1EwRkJRenRSUVVOcVF5eEZRVUZGTEVOQlFVTXNXVUZCV1N4SFFVRkhMSGxDUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxIbENRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOeVJpeFJRVUZSTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU03VVVGRGFrTXNSVUZCUlN4RFFVRkRMRk5CUVZNc1IwRkJSeXg1UWtGQlZ5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeDVRa0ZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJFWXNVVUZCVVN4SlFVRkpMSGxDUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETzFGQlEycERMRVZCUVVVc1EwRkJReXhOUVVGTkxFZEJRVWNzVjBGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeFhRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNdlJDeFJRVUZSTEVsQlFVa3NWMEZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVONFFpeEZRVUZGTEVOQlFVTXNaMEpCUVdkQ0xFZEJRVWNzVjBGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeFhRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONlJTeFJRVUZSTEVsQlFVa3NWMEZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVONFFpeEZRVUZGTEVOQlFVTXNhVUpCUVdsQ0xFZEJRVWNzVjBGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeFhRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNeFJTeFJRVUZSTEVsQlFVa3NWMEZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVONFFpeEZRVUZGTEVOQlFVTXNSMEZCUnl4SFFVRkhMRk5CUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1UwRkJSeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETVVRc1VVRkJVU3hKUVVGSkxGTkJRVWNzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZEZGtJc1JVRkJSU3hEUVVGRExHMUNRVUZ0UWl4SFFVRkhMSGxDUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxIbENRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNMVJpeFJRVUZSTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU03VVVGRGFrTXNSVUZCUlN4RFFVRkRMRFpDUVVFMlFpeEhRVUZITEhsQ1FVRlhMRU5CUVVNc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMSGxDUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBSeXhSUVVGUkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNN1VVRkRha01zUlVGQlJTeERRVUZETERaQ1FVRTJRaXhIUVVGSExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEhsQ1FVRlhMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUnl4UlFVRlJMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTTdVVUZEYWtNc1JVRkJSU3hEUVVGRExFdEJRVXNzUjBGQlJ5eFRRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEZOQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVFZFTEU5QlFVOHNSVUZCUlN4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkpMRkZCUVZFN1VVRkRXQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExIZENRVUYzUWl4RlFVRkZMRzFFUVVGM1FpeERRVUZETEVWQlFVVTdXVUZETDBVc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNkVVZCUVhWRkxFVkJRVVVzUlVGQlJTeDNRa0ZCZDBJc1JVRkJSU3hKUVVGSkxFTkJRVU1zZDBKQlFYZENMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRemRLTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRVZCUVVVc2FVSkJRVThzUTBGQlF5eEZRVUZGTzFsQlF6ZERMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEhORVFVRnpSQ3hGUVVGRkxFVkJRVVVzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRekZITzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRVZCUVVVc1UwRkJSeXhEUVVGRExFVkJRVVU3V1VGRE4wTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zTUVSQlFUQkVMRVZCUVVVc1JVRkJSU3hYUVVGWExFVkJRVVVzU1VGQlNTeERRVUZETEZkQlFWY3NSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRkRWc3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4WFFVRkpMRU5CUVVNc1JVRkJSVHRaUVVONlF5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXh4UkVGQmNVUXNSVUZCUlN4RlFVRkZMRTFCUVUwc1JVRkJSU3hKUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTjJSenRSUVVWRUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc1YwRkJTU3hEUVVGRExFVkJRVVU3V1VGRGJrUXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zSzBSQlFTdEVMRVZCUVVVc1JVRkJSU3huUWtGQlowSXNSVUZCUlN4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVWQlFVVXNRMEZCUXl4RFFVRkRPMU5CUTNKSk8xRkJSVVFzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJc1JVRkJSU3hYUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU53UkN4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eG5SVUZCWjBVc1JVRkJSU3hGUVVGRkxHbENRVUZwUWl4RlFVRkZMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRlRWs3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NSVUZCUlN4VFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVOMlF5eE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXh2UkVGQmIwUXNSVUZCUlN4RlFVRkZMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTndSenRSUVVWRUxFMUJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4M1FrRkJkMElzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1kwRkROVVFzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRGJFTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhKUVVGSkxGZEJRVmNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRE1VUXNWMEZCVnl4RFFVRkRMRmRCUVZjN1kwRkRka0lzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRGRFTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhKUVVGSkxIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTzJOQlF6ZEVMRU5CUVVNc1NVRkJTU3hEUVVGRExGbEJRVmtzU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0alFVTm9SU3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVsQlFVa3NlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN1kwRkROMFFzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3WTBGRGFrTXNTVUZCU1N4RFFVRkRMR2RDUVVGblFpeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSVHRqUVVNelF5eEpRVUZKTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMk5CUXpWRExFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NTVUZCU1N4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMk5CUTNCRUxFTkJRVU1zU1VGQlNTeERRVUZETEcxQ1FVRnRRaXhKUVVGSkxIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTzJOQlEzWkZMRU5CUVVNc1NVRkJTU3hEUVVGRExEWkNRVUUyUWl4SlFVRkpMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRk8yTkJRMnBHTEVOQlFVTXNTVUZCU1N4RFFVRkRMRFpDUVVFMlFpeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMk5CUTJwR0xFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03VVVGRmRrTXNUVUZCVFN4TlFVRk5MRWRCUVVjc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU0zUWl4SlFVRkpMRTFCUVUwc1MwRkJTeXhYUVVGWExFTkJRVU1zVFVGQlRTeEZRVUZGTzFsQlF5OUNMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEhOQ1FVRnpRaXhYUVVGWExFTkJRVU1zVFVGQlRTeGpRVUZqTEUxQlFVMHNSVUZCUlN4RlFVRkZMRVZCUVVVc1RVRkJUU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFRRVU51Unp0UlFVVkVMRTlCUVU4c1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnlReXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFOUJRVTg3SzBKQlEyZENMRU5CUVVNc1NVRkJTU3hEUVVGRExIZENRVUYzUWl4SlFVRkpMRzFFUVVGM1FpeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdGpRVU40Unl4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFbEJRVWtzYVVKQlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVTdWMEZEZUVRc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEZkQlFWY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVU3YTBKQlEzaERMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzU1VGQlNTeFRRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTzJWQlEzaEVMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJUdHJRa0ZETDBNc1EwRkJReXhKUVVGSkxFTkJRVU1zV1VGQldTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTzJWQlEzaEVMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zU1VGQlNTeDVRa0ZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJUdGhRVU53UkN4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFbEJRVWtzVjBGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdDFRa0ZEZGtNc1EwRkJReXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRWxCUVVrc1YwRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSVHQzUWtGRE1VUXNRMEZCUXl4SlFVRkpMRU5CUVVNc2FVSkJRV2xDTEVsQlFVa3NWMEZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlR0VlFVTXhSU3hEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVsQlFVa3NTVUZCU1N4RFFVRkRMRmRCUVZjc1NVRkJTU3hUUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRk8zbENRVU5zUkN4RFFVRkRMRWxCUVVrc1EwRkJReXh0UWtGQmJVSXNTVUZCU1N4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlR0dFEwRkRiRVFzUTBGQlF5eEpRVUZKTEVOQlFVTXNOa0pCUVRaQ0xFbEJRVWtzZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVU3YlVOQlEzUkZMRU5CUVVNc1NVRkJTU3hEUVVGRExEWkNRVUUyUWl4SlFVRkpMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZPMWxCUXpkR0xFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NTVUZCU1N4VFFVRkhMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPMFZCUTNwRUxFTkJRVU03U1VGRFF5eERRVUZET3p0QlFYQlNSRHM3UjBGRlJ6dEJRVU52UWl4clFrRkJUU3hIUVVGWExFbEJRVWtzUTBGQlF6dEJRVVUzUXpzN1IwRkZSenRCUVVOdlFpdzRRa0ZCYTBJc1IwRkJWeXhGUVVGRkxFTkJRVU03UVVGRmRrUTdPMGRCUlVjN1FVRkRiMElzZFVKQlFWY3NSMEZCVnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eHJRa0ZCYTBJc1EwRkJReXhEUVVGRE8wRkJSWGhHTEdWQlFXVTdRVUZEVXl4dlFrRkJVU3hIUVVGblFpeDVRa0ZCVnl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdRVUZxUW14R0xHdERRWE5TUXlKOSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3NcIik7XHJcbmNvbnN0IHRhZ18xID0gcmVxdWlyZShcIi4vdGFnXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyYW5zZmVycy5cclxuICovXHJcbmNsYXNzIFRyYW5zZmVyIHtcclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cmFuc2ZlciBmcm9tIHBhcmFtZXRlcnMuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gbWVzc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSB0cmFuc2Zlci5cclxuICAgICAqIEBwYXJhbSB0YWcgVGhlIHRhZy5cclxuICAgICAqIEByZXR1cm5zIE5ldyBpbnN0YW5jZSBvZiBUcmFuc2Zlci5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21QYXJhbXMoYWRkcmVzcywgdmFsdWUsIG1lc3NhZ2UsIHRhZykge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhIHZhbGlkIEFkZHJlc3Mgb2JqZWN0XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KG1lc3NhZ2UpICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKG1lc3NhZ2UsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBtZXNzYWdlIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodGFnKSAmJiAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0YWcsIHRhZ18xLlRhZykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSB0YWcgc2hvdWxkIGJlIGEgdmFsaWQgVGFnIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXIgPSBuZXcgVHJhbnNmZXIoKTtcclxuICAgICAgICB0cmFuc2Zlci5hZGRyZXNzID0gYWRkcmVzcztcclxuICAgICAgICB0cmFuc2Zlci52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRyYW5zZmVyLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRyYW5zZmVyLnRhZyA9IHRhZztcclxuICAgICAgICByZXR1cm4gdHJhbnNmZXI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UcmFuc2ZlciA9IFRyYW5zZmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpoYm5ObVpYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpHRjBZUzkwY21GdWMyWmxjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNORVZCUVhsRk8wRkJRM3BGTERSRlFVRjVSVHRCUVVONlJTeHJSRUZCSzBNN1FVRkRMME1zZFVOQlFXOURPMEZCUTNCRExDdENRVUUwUWp0QlFVTTFRaXh4UTBGQmEwTTdRVUZGYkVNN08wZEJSVWM3UVVGRFNEdEpRV3RDU1N4bFFVRmxPMGxCUTJZN1NVRkRRU3hEUVVGRE8wbEJSVVE3T3pzN096czdUMEZQUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zVDBGQlowSXNSVUZEYUVJc1MwRkJZU3hGUVVOaUxFOUJRV1VzUlVGRFppeEhRVUZSTzFGQlF6ZENMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRVZCUVVVc2FVSkJRVThzUTBGQlF5eEZRVUZGTzFsQlEzaERMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETERoRFFVRTRReXhEUVVGRExFTkJRVU03VTBGRGRrVTdVVUZGUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1MwRkJTeXhIUVVGSExFTkJRVU1zUlVGQlJUdFpRVU0zUXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHRRMEZCYlVNc1EwRkJReXhEUVVGRE8xTkJRelZFTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMR1ZCUVUwc1EwRkJReXhGUVVGRk8xbEJRM3BGTEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExEWkRRVUUyUXl4RFFVRkRMRU5CUVVNN1UwRkRkRVU3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEVWQlFVVXNVMEZCUnl4RFFVRkRMRVZCUVVVN1dVRkRPVVFzVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc2MwTkJRWE5ETEVOQlFVTXNRMEZCUXp0VFFVTXZSRHRSUVVWRUxFMUJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NVVUZCVVN4RlFVRkZMRU5CUVVNN1VVRkRhRU1zVVVGQlVTeERRVUZETEU5QlFVOHNSMEZCUnl4UFFVRlBMRU5CUVVNN1VVRkRNMElzVVVGQlVTeERRVUZETEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNN1VVRkRka0lzVVVGQlVTeERRVUZETEU5QlFVOHNSMEZCUnl4UFFVRlBMRU5CUVVNN1VVRkRNMElzVVVGQlVTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNN1VVRkRia0lzVDBGQlR5eFJRVUZSTEVOQlFVTTdTVUZEY0VJc1EwRkJRenREUVVOS08wRkJla1JFTERSQ1FYbEVReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgZGF0YUVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvZGF0YUVycm9yXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyaXRzLlxyXG4gKi9cclxuY2xhc3MgVHJpdHMge1xyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0cml0cykge1xyXG4gICAgICAgIHRoaXMuX3RyaXRzID0gdHJpdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cml0cyBmcm9tIEludDhBcnJheSBhcnJheS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnl0ZXMgdXNlZCB0byBjcmVhdGUgdHJpdHMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcml0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21BcnJheSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh2YWx1ZSwgSW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gdmFsaWQgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHModmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJpdHMgZnJvbSBudW1iZXIgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVHJ5dGVzIHVzZWQgdG8gY3JlYXRlIHRyaXRzLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVHJpdHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tTnVtYmVyQXJyYXkodmFsdWUpIHtcclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh2YWx1ZSwgTnVtYmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gdmFsaWQgdHJpdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHMobmV3IEludDhBcnJheSh2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJpdHMgZnJvbSB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVHJ5dGVzIHVzZWQgdG8gY3JlYXRlIHRyaXRzLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVHJpdHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHZhbHVlLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJ5dGVzU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCB0cml0cyA9IG5ldyBJbnQ4QXJyYXkodHJ5dGVzU3RyaW5nLmxlbmd0aCAqIDMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJ5dGVzU3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHRyeXRlc18xLlRyeXRlcy5BTFBIQUJFVC5pbmRleE9mKHRyeXRlc1N0cmluZy5jaGFyQXQoaSkpO1xyXG4gICAgICAgICAgICB0cml0c1tpICogM10gPSBUcml0cy5UUllURVNfVFJJVFNbaWR4XVswXTtcclxuICAgICAgICAgICAgdHJpdHNbaSAqIDMgKyAxXSA9IFRyaXRzLlRSWVRFU19UUklUU1tpZHhdWzFdO1xyXG4gICAgICAgICAgICB0cml0c1tpICogMyArIDJdID0gVHJpdHMuVFJZVEVTX1RSSVRTW2lkeF1bMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHModHJpdHMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJpdHMgZnJvbSBudW1iZXJcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBOdW1iZXIgdXNlZCB0byBjcmVhdGUgdHJpdHMuXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcml0cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21OdW1iZXIodmFsdWUpIHtcclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgaXMgbm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyaXRzID0gW107XHJcbiAgICAgICAgbGV0IGFic29sdXRlVmFsdWUgPSB2YWx1ZSA8IDAgPyAtdmFsdWUgOiB2YWx1ZTtcclxuICAgICAgICB3aGlsZSAoYWJzb2x1dGVWYWx1ZSA+IDApIHtcclxuICAgICAgICAgICAgbGV0IHJlbWFpbmRlciA9IGFic29sdXRlVmFsdWUgJSAzO1xyXG4gICAgICAgICAgICBhYnNvbHV0ZVZhbHVlID0gTWF0aC5mbG9vcihhYnNvbHV0ZVZhbHVlIC8gMyk7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSAtMTtcclxuICAgICAgICAgICAgICAgIGFic29sdXRlVmFsdWUrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cml0c1t0cml0cy5sZW5ndGhdID0gcmVtYWluZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRyaXRzW2ldID0gLXRyaXRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVHJpdHMobmV3IEludDhBcnJheSh0cml0cykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgdHdvIHRyaXRzIHRvZ2V0aGVyLlxyXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCB0cml0LlxyXG4gICAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIHRyaXQuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJpdCB3aGljaCBpcyB0aGUgYWRkaXRpb24gb2YgdGhlIGEgKyBiLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYWRkKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoZmlyc3QsIFRyaXRzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIGZpcnN0IHNob3VsZCBiZSBhIHZhbGlkIFRyaXRzIG9iamVjdFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlY29uZCwgVHJpdHMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc2Vjb25kcyBzaG91bGQgYmUgYSB2YWxpZCBUcml0cyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBJbnQ4QXJyYXkoTWF0aC5tYXgoZmlyc3QuX3RyaXRzLmxlbmd0aCwgc2Vjb25kLl90cml0cy5sZW5ndGgpKTtcclxuICAgICAgICBsZXQgY2FycnkgPSAwO1xyXG4gICAgICAgIGxldCBpQTtcclxuICAgICAgICBsZXQgaUI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaUEgPSBpIDwgZmlyc3QuX3RyaXRzLmxlbmd0aCA/IGZpcnN0Ll90cml0c1tpXSA6IDA7XHJcbiAgICAgICAgICAgIGlCID0gaSA8IHNlY29uZC5fdHJpdHMubGVuZ3RoID8gc2Vjb25kLl90cml0c1tpXSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZBID0gVHJpdHMuZnVsbEFkZChpQSwgaUIsIGNhcnJ5KTtcclxuICAgICAgICAgICAgb3V0W2ldID0gZkFbMF07XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gZkFbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUcml0cy5mcm9tQXJyYXkob3V0KTtcclxuICAgIH1cclxuICAgIC8qIEBpbnRlcm5hbCAqL1xyXG4gICAgc3RhdGljIGZ1bGxBZGQoYSwgYiwgYykge1xyXG4gICAgICAgIGNvbnN0IHNBID0gVHJpdHMuc3VtKGEsIGIpO1xyXG4gICAgICAgIGNvbnN0IGNBID0gVHJpdHMuY29ucyhhLCBiKTtcclxuICAgICAgICBjb25zdCBjQiA9IFRyaXRzLmNvbnMoc0EsIGMpO1xyXG4gICAgICAgIGNvbnN0IGNPdXQgPSBUcml0cy5hbnkoY0EsIGNCKTtcclxuICAgICAgICBjb25zdCBzT1V0ID0gVHJpdHMuc3VtKHNBLCBjKTtcclxuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShbc09VdCwgY091dF0pO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgc3VtKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBzID0gYSArIGI7XHJcbiAgICAgICAgc3dpdGNoIChzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICBjYXNlIC0yOiByZXR1cm4gMTtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgY29ucyhhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBzdGF0aWMgYW55KGEsIGIpIHtcclxuICAgICAgICBjb25zdCBzID0gYSArIGI7XHJcbiAgICAgICAgaWYgKHMgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSB0cml0cyBhcnJheS5cclxuICAgICAqIEByZXR1cm5zIEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cml0cy5cclxuICAgICAqL1xyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJpdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIHRyaXRzIGFycmF5IGFzIGEgbnVtYmVyIGFycmF5LlxyXG4gICAgICogQHJldHVybnMgQXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyaXRzLlxyXG4gICAgICovXHJcbiAgICB0b051bWJlckFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3RyaXRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0cml0cyBhcyB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUcnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHRvVHJ5dGVzKCkge1xyXG4gICAgICAgIGxldCB0cnl0ZXMgPSBcIlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHJpdHMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBwb3NzaWJsZSB0cnl0ZSB2YWx1ZXMgdG8gZmluZCBjb3JyZWN0IHRyaXQgcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0cnl0ZXNfMS5Ucnl0ZXMuQUxQSEFCRVQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChUcml0cy5UUllURVNfVFJJVFNbal1bMF0gPT09IHRoaXMuX3RyaXRzW2ldICYmXHJcbiAgICAgICAgICAgICAgICAgICAgVHJpdHMuVFJZVEVTX1RSSVRTW2pdWzFdID09PSB0aGlzLl90cml0c1tpICsgMV0gJiZcclxuICAgICAgICAgICAgICAgICAgICBUcml0cy5UUllURVNfVFJJVFNbal1bMl0gPT09IHRoaXMuX3RyaXRzW2kgKyAyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeXRlcyArPSB0cnl0ZXNfMS5Ucnl0ZXMuQUxQSEFCRVQuY2hhckF0KGopO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHRyaXRzIGFzIGEgbnVtYmVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIHRyaXRzIGNvbnZlcnRlZCB0byBhIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgdG9OdW1iZXIoKSB7XHJcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fdHJpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZSAqIDMgKyB0aGlzLl90cml0c1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGF0IGlzIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzLlxyXG4gICAgICogQHJldHVybnMgTGVuZ3RoIG9mIHRoZSB0cml0cy5cclxuICAgICAqL1xyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cml0cy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHN1YiBvZiB0aGUgdHJpdHMuXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uIHRvIGdldCB0aGUgc3ViLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBzdWIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJpdHMgc3ViLlxyXG4gICAgICovXHJcbiAgICBzdWIoc3RhcnQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydCkgfHwgc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc3RhcnQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCAoc3RhcnQgKyBsZW5ndGgpID4gdGhpcy5fdHJpdHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoYFRoZSBzdGFydCArIGxlbmd0aCBtdXN0IDw9ICR7dGhpcy5fdHJpdHMubGVuZ3RofWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVHJpdHMuZnJvbUFycmF5KHRoaXMuX3RyaXRzLnNsaWNlKHN0YXJ0LCBzdGFydCArIGxlbmd0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qIEBpbnRlcm5hbCAqL1xyXG5Ucml0cy5UUllURVNfVFJJVFMgPSBbXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAwLCAwXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAwLCAwXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIC0xLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAtMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgLTEsIDFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAwLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAwLCAxXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgMSwgMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIC0xLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgLTEsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAtMSwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMCwgMCwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzEsIDAsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFstMSwgMSwgLTFdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWzAsIDEsIC0xXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFsxLCAxLCAtMV0pLFxyXG4gICAgbmV3IEludDhBcnJheShbLTEsIC0xLCAwXSksXHJcbiAgICBuZXcgSW50OEFycmF5KFswLCAtMSwgMF0pLFxyXG4gICAgbmV3IEludDhBcnJheShbMSwgLTEsIDBdKSxcclxuICAgIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAwXSlcclxuXTtcclxuZXhwb3J0cy5Ucml0cyA9IFRyaXRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpwZEhNdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12WkdGMFlTOTBjbWwwY3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTUVWQlFYVkZPMEZCUTNaRkxEUkZRVUY1UlR0QlFVTjZSU3cwUlVGQmVVVTdRVUZEZWtVc2EwUkJRU3RETzBGQlF5OURMSEZEUVVGclF6dEJRVVZzUXpzN1IwRkZSenRCUVVOSU8wbEJiVU5KTEdWQlFXVTdTVUZEWml4WlFVRnZRaXhMUVVGblFqdFJRVU5vUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF6dEpRVU40UWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU1zUzBGQlowSTdVVUZEY0VNc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hUUVVGVExFTkJRVU1zUlVGQlJUdFpRVU40UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eDNRMEZCZDBNc1EwRkJReXhEUVVGRE8xTkJRMnBGTzFGQlEwUXNUMEZCVHl4SlFVRkpMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dEpRVU0xUWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUzBGQlpUdFJRVU42UXl4SlFVRkpMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhGUVVGRk8xbEJRM0pETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExIZERRVUYzUXl4RFFVRkRMRU5CUVVNN1UwRkRha1U3VVVGRFJDeFBRVUZQTEVsQlFVa3NTMEZCU3l4RFFVRkRMRWxCUVVrc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVVWRU96czdPMDlCU1VjN1NVRkRTU3hOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFXRTdVVUZEYkVNc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hsUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU55UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3lRMEZCTWtNc1EwRkJReXhEUVVGRE8xTkJRM0JGTzFGQlEwUXNUVUZCVFN4WlFVRlpMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFGQlEzUkRMRTFCUVUwc1MwRkJTeXhIUVVGakxFbEJRVWtzVTBGQlV5eERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFVXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEZsQlFWa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3V1VGRE1VTXNUVUZCVFN4SFFVRkhMRWRCUVVjc1pVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkVMRXRCUVVzc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVkQlFVY3NTMEZCU3l4RFFVRkRMRmxCUVZrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXhReXhMUVVGTExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zV1VGQldTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxETEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEYWtRN1VVRkRSQ3hQUVVGUExFbEJRVWtzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUXpWQ0xFTkJRVU03U1VGRlJEczdPenRQUVVsSE8wbEJRMGtzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TFFVRmhPMUZCUTJ4RExFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGQlJUdFpRVU5vUXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5dzJRa0ZCTmtJc1EwRkJReXhEUVVGRE8xTkJRM1JFTzFGQlEwUXNUVUZCVFN4TFFVRkxMRWRCUVdFc1JVRkJSU3hEUVVGRE8xRkJRek5DTEVsQlFVa3NZVUZCWVN4SFFVRkhMRXRCUVVzc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRkwwTXNUMEZCVHl4aFFVRmhMRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRM1JDTEVsQlFVa3NVMEZCVXl4SFFVRkhMR0ZCUVdFc1IwRkJSeXhEUVVGRExFTkJRVU03V1VGRGJFTXNZVUZCWVN4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zWVVGQllTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUlRsRExFbEJRVWtzVTBGQlV5eEhRVUZITEVOQlFVTXNSVUZCUlR0blFrRkRaaXhUUVVGVExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJZc1lVRkJZU3hGUVVGRkxFTkJRVU03WVVGRGJrSTdXVUZGUkN4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEZOQlFWTXNRMEZCUXp0VFFVTnVRenRSUVVORUxFbEJRVWtzUzBGQlN5eEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTllMRXRCUVVzc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzJkQ1FVTnVReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRGVFSTdVMEZEU2p0UlFVVkVMRTlCUVU4c1NVRkJTU3hMUVVGTExFTkJRVU1zU1VGQlNTeFRRVUZUTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNelF5eERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVmtzUlVGQlJTeE5RVUZoTzFGQlEzcERMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGRGNFTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zTUVOQlFUQkRMRU5CUVVNc1EwRkJRenRUUVVOdVJUdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RFFVRkRMRVZCUVVVN1dVRkRja01zVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc05FTkJRVFJETEVOQlFVTXNRMEZCUXp0VFFVTnlSVHRSUVVWRUxFMUJRVTBzUjBGQlJ5eEhRVUZITEVsQlFVa3NVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRVZCUVVVc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5RkxFbEJRVWtzUzBGQlN5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTmtMRWxCUVVrc1JVRkJSU3hEUVVGRE8xRkJRMUFzU1VGQlNTeEZRVUZGTEVOQlFVTTdVVUZGVUN4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVVZxUXl4RlFVRkZMRWRCUVVjc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrUXNSVUZCUlN4SFFVRkhMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0pFTEUxQlFVMHNSVUZCUlN4SFFVRkhMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlJTeEZRVUZGTEVWQlFVVXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRaUVVONFF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyWXNTMEZCU3l4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFRRVU5xUWp0UlFVVkVMRTlCUVU4c1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVTm9ReXhEUVVGRE8wbEJSVVFzWlVGQlpUdEpRVU5RTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJVeXhGUVVGRkxFTkJRVk1zUlVGQlJTeERRVUZUTzFGQlEyeEVMRTFCUVUwc1JVRkJSU3hIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRek5DTEUxQlFVMHNSVUZCUlN4SFFVRkhMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpWQ0xFMUJRVTBzUlVGQlJTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6ZENMRTFCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJReTlDTEUxQlFVMHNTVUZCU1N4SFFVRkhMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlRsQ0xFOUJRVThzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU4yUXl4RFFVRkRPMGxCUlVRc1pVRkJaVHRKUVVOUUxFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCVXl4RlFVRkZMRU5CUVZNN1VVRkRia01zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVWb1FpeFJRVUZSTEVOQlFVTXNSVUZCUlR0WlFVTlFMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnNRaXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRiRUlzVDBGQlR5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1UwRkRja0k3U1VGRFRDeERRVUZETzBsQlJVUXNaVUZCWlR0SlFVTlFMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlV5eEZRVUZGTEVOQlFWTTdVVUZEY0VNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEZRVUZGTzFsQlExUXNUMEZCVHl4RFFVRkRMRU5CUVVNN1UwRkRXanRSUVVORUxFOUJRVThzUTBGQlF5eERRVUZETzBsQlEySXNRMEZCUXp0SlFVVkVMR1ZCUVdVN1NVRkRVQ3hOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFWTXNSVUZCUlN4RFFVRlRPMUZCUTI1RExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkZhRUlzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUTFBc1QwRkJUeXhEUVVGRExFTkJRVU03VTBGRFdqdGhRVUZOTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVOa0xFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVMEZEWWp0UlFVVkVMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRMklzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxFOUJRVTg3VVVGRFZpeFBRVUZQTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRka0lzUTBGQlF6dEpRVVZFT3pzN1QwRkhSenRKUVVOSkxHRkJRV0U3VVVGRGFFSXNUMEZCVHl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnVReXhEUVVGRE8wbEJSVVE3T3p0UFFVZEhPMGxCUTBrc1VVRkJVVHRSUVVOWUxFbEJRVWtzVFVGQlRTeEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVVm9RaXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSVHRaUVVNMVF5dzJSVUZCTmtVN1dVRkROMFVzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExHVkJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1JVRkJSU3hGUVVGRk8yZENRVU0zUXl4SlFVRkpMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUXpORExFdEJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8yOUNRVU12UXl4TFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RlFVRkZPMjlDUVVOcVJDeE5RVUZOTEVsQlFVa3NaVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNCRExFMUJRVTA3YVVKQlExUTdZVUZEU2p0VFFVTktPMUZCUlVRc1QwRkJUeXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTNKRExFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzU1VGQlNTeFhRVUZYTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUlhCQ0xFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3V1VGRE9VTXNWMEZCVnl4SFFVRkhMRmRCUVZjc1IwRkJSeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVOc1JEdFJRVVZFTEU5QlFVOHNWMEZCVnl4RFFVRkRPMGxCUTNaQ0xFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hOUVVGTk8xRkJRMVFzVDBGQlR5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVNNVFpeERRVUZETzBsQlJVUTdPenM3TzA5QlMwYzdTVUZEU1N4SFFVRkhMRU5CUVVNc1MwRkJZU3hGUVVGRkxFMUJRV003VVVGRGNFTXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRXRCUVVzc1IwRkJSeXhEUVVGRExFVkJRVVU3V1VGRE4wTXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zYVVOQlFXbERMRU5CUVVNc1EwRkJRenRUUVVNeFJEdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSVHRaUVVNeFJTeE5RVUZOTEVsQlFVa3NjVUpCUVZNc1EwRkJReXc0UWtGQk9FSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETzFOQlF6TkZPMUZCUTBRc1QwRkJUeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFdEJRVXNzUlVGQlJTeExRVUZMTEVkQlFVY3NUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOeVJTeERRVUZET3p0QlFYWlJSQ3hsUVVGbE8wRkJRMU1zYTBKQlFWa3NSMEZCWjBJN1NVRkRhRVFzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzaENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVONFFpeEpRVUZKTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjZRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVFSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNoQ0xFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETVVJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVrSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRla0lzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM2hDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjRRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU42UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRlRUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzaENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU16UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRekZDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNVUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXhRaXhKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU42UWl4SlFVRkpMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVONlFpeEpRVUZKTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpGQ0xFbEJRVWtzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzcENMRWxCUVVrc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM3BDTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNVUlzU1VGQlNTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtJc1NVRkJTU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRGVrSXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1EwRkROVUlzUTBGQlF6dEJRVGxDVGl4elFrRXdVVU1pZlE9PSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBkYXRhRXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvci9kYXRhRXJyb3JcIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiLi90cml0c1wiKTtcclxuY29uc3QgdHJ5dGVzXzEgPSByZXF1aXJlKFwiLi90cnl0ZXNcIik7XHJcbi8qKlxyXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB0cnl0ZSBudW1iZXIuXHJcbiAqL1xyXG5jbGFzcyBUcnl0ZU51bWJlciB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRyeXRlIG51bWJlciBmcm9tIG51bWJlci5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbnVtYmVyIHZhbHVlIHRvIGNyZWF0ZSB0aGUgb2JqZWN0IGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSB0cnl0ZSBsZW5ndGggdG8gcGFkIHRoZSBudW1iZXIgd2l0aC5cclxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyeXRlTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSwgbGVuZ3RoID0gVHJ5dGVOdW1iZXIuTEVOR1RIXzkpIHtcclxuICAgICAgICBsZXQgdHJ5dGVzO1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgbGVuZ3RoIHNob3VsZCBiZSBhIG51bWJlciA+IDBcIiwgeyBsZW5ndGggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdHJ5dGVzID0gXCI5XCIucmVwZWF0KGxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGlzIG5vdCBhbiBpbnRlZ2VyXCIsIHsgdmFsdWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21OdW1iZXIodmFsdWUpLnRvTnVtYmVyQXJyYXkoKTtcclxuICAgICAgICAgICAgd2hpbGUgKHRyaXRzLmxlbmd0aCA8IGxlbmd0aCAqIDMpIHtcclxuICAgICAgICAgICAgICAgIHRyaXRzLnB1c2goMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5dGVzID0gdHJpdHNfMS5Ucml0cy5mcm9tTnVtYmVyQXJyYXkodHJpdHMpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcnl0ZU51bWJlcih0cnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgdHJ5dGUgbnVtYmVyIGZyb20gdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdmFsdWUgdG8gY3JlYXRlIHRoZSBvYmplY3QgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIHRyeXRlIGxlbmd0aCB0byBwYWQgdGhlIG51bWJlciB3aXRoLlxyXG4gICAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgVHJ5dGVOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tVHJ5dGVzKHZhbHVlLCBsZW5ndGggPSBUcnl0ZU51bWJlci5MRU5HVEhfOSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh2YWx1ZSwgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0cnl0ZVN0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBsZW5ndGggc2hvdWxkIGJlIGEgbnVtYmVyID4gMFwiLCB7IGxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRyeXRlU3RyaW5nLmxlbmd0aCA+IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFwiVGhlIHZhbHVlIGNvbnRhaW5zIHRvbyBtYW55IGNoYXJhY3RlcnNcIiwgeyBsZW5ndGg6IHRyeXRlU3RyaW5nLmxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRyeXRlU3RyaW5nLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0cnl0ZVN0cmluZyArPSBcIjlcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUcnl0ZU51bWJlcih0cnl0ZVN0cmluZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdGhlIHRyeXRlIG51bWJlciB0byB0cnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgdHJ5dGUgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICB0b1RyeXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodGhpcy5fdHJ5dGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCB0aGUgdHJ5dGUgbnVtYmVyIHRvIG51bWJlci5cclxuICAgICAqIEByZXR1cm5zIG51bWJlciB2YWx1ZSBvZiB0aGUgdHJ5dGUgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICB0b051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX3RyeXRlcykpLnRvTnVtYmVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdmFsdWVPZigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b051bWJlcigpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBMZW5ndGggb2YgYSBudW1iZXIgdGhhdCB1c2VzIDkgdHJ5dGVzLlxyXG4gKi9cclxuVHJ5dGVOdW1iZXIuTEVOR1RIXzkgPSA5O1xyXG4vKipcclxuICogQW4gZW1wdHkgOSBsZW5ndGggdHJ5dGUgbnVtYmVyLlxyXG4gKi9cclxuVHJ5dGVOdW1iZXIuRU1QVFlfOSA9IFRyeXRlTnVtYmVyLmZyb21OdW1iZXIoMCwgVHJ5dGVOdW1iZXIuTEVOR1RIXzkpO1xyXG5leHBvcnRzLlRyeXRlTnVtYmVyID0gVHJ5dGVOdW1iZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISjVkR1ZPZFcxaVpYSXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpHRjBZUzkwY25sMFpVNTFiV0psY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wRkJRVUVzTkVWQlFYbEZPMEZCUTNwRkxEUkZRVUY1UlR0QlFVTjZSU3hyUkVGQkswTTdRVUZETDBNc2JVTkJRV2RETzBGQlEyaERMSEZEUVVGclF6dEJRVVZzUXpzN1IwRkZSenRCUVVOSU8wbEJZVWtzWlVGQlpUdEpRVU5tTEZsQlFXOUNMRTFCUVdNN1VVRkRPVUlzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRNVUlzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGaExFVkJRVVVzVTBGQmFVSXNWMEZCVnl4RFFVRkRMRkZCUVZFN1VVRkRla1VzU1VGQlNTeE5RVUZOTEVOQlFVTTdVVUZGV0N4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1RVRkJUU3hKUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU5vUkN4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5eHRRMEZCYlVNc1JVRkJSU3hGUVVGRkxFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEZUVVN1VVRkZSQ3hKUVVGSkxESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhGUVVGRk8xbEJRemRDTEUxQlFVMHNSMEZCUnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFOQlF5OUNPMkZCUVUwN1dVRkRTQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVU3WjBKQlEyaERMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETERaQ1FVRTJRaXhGUVVGRkxFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0aFFVTnFSVHRaUVVWRUxFMUJRVTBzUzBGQlN5eEhRVUZITEdGQlFVc3NRMEZCUXl4VlFVRlZMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zWVVGQllTeEZRVUZGTEVOQlFVTTdXVUZGZEVRc1QwRkJUeXhMUVVGTExFTkJRVU1zVFVGQlRTeEhRVUZITEUxQlFVMHNSMEZCUnl4RFFVRkRMRVZCUVVVN1owSkJRemxDTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WVVGRGFrSTdXVUZGUkN4TlFVRk5MRWRCUVVjc1lVRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFRRVU12UkR0UlFVVkVMRTlCUVU4c1NVRkJTU3hYUVVGWExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEYmtNc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TFFVRmhMRVZCUVVVc1UwRkJhVUlzVjBGQlZ5eERRVUZETEZGQlFWRTdVVUZEZWtVc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hsUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU55UXl4TlFVRk5MRWxCUVVrc2NVSkJRVk1zUTBGQlF5d3lRMEZCTWtNc1EwRkJReXhEUVVGRE8xTkJRM0JGTzFGQlEwUXNTVUZCU1N4WFFVRlhMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzFGQlJXNURMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hOUVVGTkxFbEJRVWtzUTBGQlF5eEZRVUZGTzFsQlEyaEVMRTFCUVUwc1NVRkJTU3h4UWtGQlV5eERRVUZETEcxRFFVRnRReXhGUVVGRkxFVkJRVVVzVFVGQlRTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTjRSVHRSUVVWRUxFbEJRVWtzVjBGQlZ5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRVZCUVVVN1dVRkROMElzVFVGQlRTeEpRVUZKTEhGQ1FVRlRMRU5CUVVNc2QwTkJRWGRETEVWQlFVVXNSVUZCUlN4TlFVRk5MRVZCUVVVc1YwRkJWeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEYWtjN1VVRkZSQ3hQUVVGUExGZEJRVmNzUTBGQlF5eE5RVUZOTEVkQlFVY3NUVUZCVFN4RlFVRkZPMWxCUTJoRExGZEJRVmNzU1VGQlNTeEhRVUZITEVOQlFVTTdVMEZEZEVJN1VVRkZSQ3hQUVVGUExFbEJRVWtzVjBGQlZ5eERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMGxCUTNoRExFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzVDBGQlR5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU16UXl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTlCUVU4c1lVRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMGxCUTNoRkxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hSUVVGUk8xRkJRMWdzVDBGQlR5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRPMGxCUTNoQ0xFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hQUVVGUE8xRkJRMVlzVDBGQlR5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1NVRkRNMElzUTBGQlF6czdRVUV4UjBRN08wZEJSVWM3UVVGRGIwSXNiMEpCUVZFc1IwRkJWeXhEUVVGRExFTkJRVU03UVVGRE5VTTdPMGRCUlVjN1FVRkRiMElzYlVKQlFVOHNSMEZCWjBJc1YwRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVWQlFVVXNWMEZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8wRkJVbXhITEd0RFFUUkhReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBudW1iZXJIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlclwiKTtcclxuY29uc3Qgc3RyaW5nSGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXJcIik7XHJcbmNvbnN0IGRhdGFFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2RhdGFFcnJvclwiKTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyeXRlcy5cclxuICovXHJcbmNsYXNzIFRyeXRlcyB7XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRyeXRlcykge1xyXG4gICAgICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHRyeXRlcyBmcm9tIGEgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHRvIGNyZWF0ZSB0aGUgdHJ5dGVzIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIEFuIG9wdGlvbmFsIHZhbGlkYXRpb24gbGVuZ3RoIGZvciB0aGUgdHJ5dGVzLCAwIG1lYW5zIGlnbm9yZSBsZW5ndGguXHJcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBsZW5ndGggPSAwKSB7XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcIlRoZSBsZW5ndGggbXVzdCBiZSA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIVRyeXRlcy5pc1ZhbGlkKHZhbHVlLCBsZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgdmFsdWUgYW5kIGxlbmd0aCBkbyBub3QgY29udGFpbiB2YWxpZCB0cnl0ZXNcIiwgeyB2YWx1ZSwgbGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRyeXRlcyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERvZXMgdGhlIHZhbHVlIGNvbnRhaW4gdmFsaWQgdHJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHRvIHZhbGlkYXRlIGFzIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggQW4gb3B0aW9uYWwgdmFsaWRhdGlvbiBsZW5ndGggZm9yIHRoZSB0cnl0ZXMsIDAgbWVhbnMgaWdub3JlIGxlbmd0aC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGlucHV0IHdhcyB2YWxpZCB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1ZhbGlkKHZhbHVlLCBsZW5ndGggPSAwKSB7XHJcbiAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeWzlBLVpdeyR7bGVuZ3RoID8gbGVuZ3RoIDogXCIwLFwifX0kYCkudGVzdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IHRoZSB0cnl0ZXMgdG8gYSBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHRyeXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHRyeXRlcy5cclxuICAgICAqL1xyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cnl0ZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBzdWIgb2YgdGhlIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24gdG8gZ2V0IHRoZSBzdWIuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHN1Yi5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgc3ViLlxyXG4gICAgICovXHJcbiAgICBzdWIoc3RhcnQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydCkgfHwgc3RhcnQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXCJUaGUgc3RhcnQgbXVzdCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCAoc3RhcnQgKyBsZW5ndGgpID4gdGhpcy5fdHJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKGBUaGUgc3RhcnQgKyBsZW5ndGggbXVzdCA8PSAke3RoaXMuX3RyeXRlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUcnl0ZXMuZnJvbVN0cmluZyh0aGlzLl90cnl0ZXMuc3Vic3RyKHN0YXJ0LCBsZW5ndGgpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWxsIHRoZSBjaGFyYWN0ZXJzIHRoYXQgY2FuIGJlIHVzZWQgaW4gdHJ5dGVzLlxyXG4gKi9cclxuVHJ5dGVzLkFMUEhBQkVUID0gXCI5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcclxuZXhwb3J0cy5Ucnl0ZXMgPSBUcnl0ZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISjVkR1Z6TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlJoZEdFdmRISjVkR1Z6TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3cwUlVGQmVVVTdRVUZEZWtVc05FVkJRWGxGTzBGQlEzcEZMR3RFUVVFclF6dEJRVVV2UXpzN1IwRkZSenRCUVVOSU8wbEJVMGtzWlVGQlpUdEpRVU5tTEZsQlFXOUNMRTFCUVdNN1VVRkRPVUlzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRNVUlzUTBGQlF6dEpRVVZFT3pzN096dFBRVXRITzBsQlEwa3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGaExFVkJRVVVzVTBGQmFVSXNRMEZCUXp0UlFVTjBSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVU3V1VGREwwSXNUVUZCVFN4SlFVRkpMSEZDUVVGVExFTkJRVU1zYzBOQlFYTkRMRU5CUVVNc1EwRkJRenRUUVVNdlJEdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJReTlETEUxQlFVMHNTVUZCU1N4eFFrRkJVeXhEUVVGRExIbENRVUY1UWl4RFFVRkRMRU5CUVVNN1UwRkRiRVE3VVVGRFJDeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFVkJRVVVzVFVGQlRTeERRVUZETEVWQlFVVTdXVUZEYUVNc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNhMFJCUVd0RUxFVkJRVVVzUlVGQlJTeExRVUZMTEVWQlFVVXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVNNVJqdFJRVU5FTEU5QlFVOHNTVUZCU1N4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGRE4wSXNRMEZCUXp0SlFVVkVPenM3T3p0UFFVdEhPMGxCUTBrc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eExRVUZoTEVWQlFVVXNVMEZCYVVJc1EwRkJRenRSUVVOdVJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVWQlFVVTdXVUZETDBJc1QwRkJUeXhMUVVGTExFTkJRVU03VTBGRGFFSTdZVUZCVFR0WlFVTklMRTlCUVU4c1NVRkJTU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VTBGRGVFVTdTVUZEVEN4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NVVUZCVVR0UlFVTllMRTlCUVU4c1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF6dEpRVU40UWl4RFFVRkRPMGxCUlVRN096dFBRVWRITzBsQlEwa3NUVUZCVFR0UlFVTlVMRTlCUVU4c1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZETDBJc1EwRkJRenRKUVVWRU96czdPenRQUVV0SE8wbEJRMGtzUjBGQlJ5eERRVUZETEV0QlFXRXNSVUZCUlN4TlFVRmpPMUZCUTNCRExFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeExRVUZMTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUXpkRExFMUJRVTBzU1VGQlNTeHhRa0ZCVXl4RFFVRkRMR2xEUVVGcFF5eERRVUZETEVOQlFVTTdVMEZETVVRN1VVRkRSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVkQlFVY3NUVUZCVFN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVWQlFVVTdXVUZETTBVc1RVRkJUU3hKUVVGSkxIRkNRVUZUTEVOQlFVTXNPRUpCUVRoQ0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVNMVJUdFJRVU5FTEU5QlFVOHNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU5xUlN4RFFVRkRPenRCUVRWRlJEczdSMEZGUnp0QlFVTlhMR1ZCUVZFc1IwRkJWeXcyUWtGQk5rSXNRMEZCUXp0QlFVcHVSU3gzUWtFNFJVTWlmUT09IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBjb3JlRXJyb3JfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBBIGRhdGEgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBEYXRhRXJyb3IgZXh0ZW5kcyBjb3JlRXJyb3JfMS5Db3JlRXJyb3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRGF0YUVycm9yLlxyXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFkZGl0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gaW5uZXJFcnJvciBBZGQgaW5mb3JtYXRpb24gZnJvbSBpbm5lciBlcnJvciBpZiB0aGVyZSB3YXMgb25lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgYWRkaXRpb25hbCwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5kb21haW4gPSBcIkRhdGFcIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkRhdGFFcnJvciA9IERhdGFFcnJvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWkdGMFlVVnljbTl5TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMlZ5Y205eUwyUmhkR0ZGY25KdmNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPMEZCUVVFc2IwVkJRV2xGTzBGQlJXcEZPenRIUVVWSE8wRkJRMGdzWlVGQmRVSXNVMEZCVVN4eFFrRkJVenRKUVVOd1F6czdPenM3VDBGTFJ6dEpRVU5JTEZsQlFWa3NUMEZCWlN4RlFVRkZMRlZCUVd0RExFVkJRVVVzVlVGQmEwSTdVVUZETDBVc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZWTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkRka01zU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNN1NVRkRla0lzUTBGQlF6dERRVU5LTzBGQldFUXNPRUpCVjBNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGNvcmVFcnJvcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvclwiKTtcclxuLyoqXHJcbiAqIEEgYnVzaW5lc3MgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXHJcbiAqL1xyXG5jbGFzcyBCdXNpbmVzc0Vycm9yIGV4dGVuZHMgY29yZUVycm9yXzEuQ29yZUVycm9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEJ1c2luZXNzRXJyb3IuXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSBmb3IgdGhlIGVycm9yLlxyXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWwgQWRkaXRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBlcnJvci5cclxuICAgICAqIEBwYXJhbSBpbm5lckVycm9yIEFkZCBpbmZvcm1hdGlvbiBmcm9tIGlubmVyIGVycm9yIGlmIHRoZXJlIHdhcyBvbmUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGFkZGl0aW9uYWwsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlLCBhZGRpdGlvbmFsLCBpbm5lckVycm9yKTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IFwiQnVzaW5lc3NcIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJ1c2luZXNzRXJyb3IgPSBCdXNpbmVzc0Vycm9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZblZ6YVc1bGMzTkZjbkp2Y2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlsY25KdmNpOWlkWE5wYm1WemMwVnljbTl5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkJRU3h2UlVGQmFVVTdRVUZGYWtVN08wZEJSVWM3UVVGRFNDeHRRa0ZCTWtJc1UwRkJVU3h4UWtGQlV6dEpRVU40UXpzN096czdUMEZMUnp0SlFVTklMRmxCUVZrc1QwRkJaU3hGUVVGRkxGVkJRV3RETEVWQlFVVXNWVUZCYTBJN1VVRkRMMFVzUzBGQlN5eERRVUZETEU5QlFVOHNSVUZCUlN4VlFVRlZMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRGRrTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhWUVVGVkxFTkJRVU03U1VGRE4wSXNRMEZCUXp0RFFVTktPMEZCV0VRc2MwTkJWME1pZlE9PSIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgc3BvbmdlRmFjdG9yeV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnlcIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0c1wiKTtcclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgYWRkcmVzcyBzaWduaW5nLlxyXG4gKiBPcmlnaW5hbCBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pb3RhLmxpYi5qcy9ibG9iL21hc3Rlci9saWIvY3J5cHRvL3NpZ25pbmcvc2lnbmluZy5qc1xyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEFkZHJlc3NIZWxwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBjaGVja3N1bSBmb3IgdGhlIHRyaXRzLlxyXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSB0cml0cyB0byBjcmVhdGUgdGhlIGNoZWNrc3VtIGZvci5cclxuICAgICAqIEBwYXJhbSBjaGVja3N1bUxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBjaGVja3N1bS5cclxuICAgICAqIEByZXR1cm5zIHRoZSBjaGVja3N1bSBhcyB0cnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVDaGVja3N1bSh0cml0cywgY2hlY2tzdW1MZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBrZXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXCJrZXJsXCIpO1xyXG4gICAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIGtlcmwuYWJzb3JiKHRyaXRzLCAwLCB0cml0cy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrc3VtVHJpdHMgPSBuZXcgSW50OEFycmF5KGtlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKSk7XHJcbiAgICAgICAga2VybC5zcXVlZXplKGNoZWNrc3VtVHJpdHMsIDAsIGNoZWNrc3VtVHJpdHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoY2hlY2tzdW1Ucml0cykudG9Ucnl0ZXMoKS50b1N0cmluZygpLnN1YnN0cmluZyg4MSAtIGNoZWNrc3VtTGVuZ3RoLCA4MSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5BZGRyZXNzSGVscGVyID0gQWRkcmVzc0hlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVdSa2NtVnpjMGhsYkhCbGNpNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5b1pXeHdaWEp6TDJGa1pISmxjM05JWld4d1pYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVGQkxHdEdRVUVyUlR0QlFVTXZSU3d5UkVGQmQwUTdRVUZGZUVRN096czdSMEZKUnp0QlFVTklPMGxCUTBrN096czdPMDlCUzBjN1NVRkRTU3hOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETEV0QlFXZENMRVZCUVVVc1kwRkJjMEk3VVVGRGFrVXNUVUZCVFN4SlFVRkpMRWRCUVVjc05rSkJRV0VzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRGNrUXNTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8xRkJSV3hDTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhGUVVGRkxFTkJRVU1zUlVGQlJTeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkZjRU1zVFVGQlRTeGhRVUZoTEVkQlFVY3NTVUZCU1N4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKRkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNZVUZCWVN4RlFVRkZMRU5CUVVNc1JVRkJSU3hoUVVGaExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZGY2tRc1QwRkJUeXhoUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZOQlFWTXNRMEZCUXl4RlFVRkZMRWRCUVVjc1kwRkJZeXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzBsQlEyNUhMRU5CUVVNN1EwRkRTanRCUVd4Q1JDeHpRMEZyUWtNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFycmF5SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlclwiKTtcclxuY29uc3Qgb2JqZWN0SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXJcIik7XHJcbmNvbnN0IHNwb25nZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5XCIpO1xyXG5jb25zdCBpc3NfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2hhc2gvaXNzXCIpO1xyXG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzXCIpO1xyXG5jb25zdCBidW5kbGVfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2J1bmRsZVwiKTtcclxuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvaGFzaFwiKTtcclxuY29uc3Qgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRcIik7XHJcbmNvbnN0IHRhZ18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdGFnXCIpO1xyXG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb25cIik7XHJcbmNvbnN0IHRyaXRzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0c1wiKTtcclxuY29uc3QgdHJ5dGVOdW1iZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlTnVtYmVyXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuY29uc3QgaG1hY0N1cmxfMSA9IHJlcXVpcmUoXCIuLi9zaWduL2htYWNDdXJsXCIpO1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciBzaWduaW5nIGJ1bmRsZXMuXHJcbiAqIENvbnZlcnRlZCBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pb3RhLmxpYi5qcy9ibG9iL21hc3Rlci9saWIvY3J5cHRvL3NpZ25pbmcvc2lnbmluZy5qc1xyXG4gKi9cclxuY2xhc3MgQnVuZGxlSGVscGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogSXMgdGhlIGJ1bmRsZSB2YWxpZC5cclxuICAgICAqIEBwYXJhbSBidW5kbGUgVGhlIGJ1bmRsZSB0byBjaGVjayBmb3IgdmFsaWRpdHkuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBidW5kbGUgaXMgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1ZhbGlkKGJ1bmRsZSkge1xyXG4gICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYnVuZGxlLCBidW5kbGVfMS5CdW5kbGUpICYmIGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChidW5kbGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKSkge1xyXG4gICAgICAgICAgICBsZXQgdG90YWxTdW0gPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBrZXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXCJrZXJsXCIpO1xyXG4gICAgICAgICAgICBrZXJsLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgLy8gUHJlcGFyZSBmb3Igc2lnbmF0dXJlIHZhbGlkYXRpb25cclxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlc1RvVmFsaWRhdGUgPSBbXTtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGggJiYgaXNWYWxpZDsgdCsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidW5kbGVUeCA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbdF07XHJcbiAgICAgICAgICAgICAgICB0b3RhbFN1bSArPSBidW5kbGVUeC52YWx1ZS50b051bWJlcigpO1xyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudEluZGV4IGhhcyB0byBiZSBlcXVhbCB0byB0aGUgaW5kZXggaW4gdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVuZGxlVHguY3VycmVudEluZGV4LnRvTnVtYmVyKCkgIT09IHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRyYW5zYWN0aW9uIHRyeXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNUeFRyeXRlcyA9IGJ1bmRsZVR4LnRvVHJ5dGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWJzb3JiIGJ1bmRsZSBoYXNoICsgdmFsdWUgKyB0aW1lc3RhbXAgKyBsYXN0SW5kZXggKyBjdXJyZW50SW5kZXggdHJ5dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNUeFRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHRoaXNUeFRyeXRlcy5zdWIoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCwgMTYyKSkudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtlcmwuYWJzb3JiKHRoaXNUeFRyaXRzLCAwLCB0aGlzVHhUcml0cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGlucHV0IHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bmRsZVR4LnZhbHVlLnRvTnVtYmVyKCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NpZ25hdHVyZVRvVmFsaWRhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBidW5kbGVUeC5hZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50czogW2J1bmRsZVR4LnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgc3Vic2VxdWVudCB0eHMgd2l0aCB0aGUgcmVtYWluaW5nIHNpZ25hdHVyZSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdDsgaSA8IGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdCdW5kbGVUeCA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbmV3IHR4IGlzIHBhcnQgb2YgdGhlIHNpZ25hdHVyZSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0J1bmRsZVR4LmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PSBidW5kbGVUeC5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIG5ld0J1bmRsZVR4LnZhbHVlLnRvTnVtYmVyKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaWduYXR1cmVUb1ZhbGlkYXRlLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMucHVzaChuZXdCdW5kbGVUeC5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZXNUb1ZhbGlkYXRlLnB1c2gobmV3U2lnbmF0dXJlVG9WYWxpZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB0b3RhbCBzdW0sIGlmIG5vdCBlcXVhbCAwIHJldHVybiBlcnJvclxyXG4gICAgICAgICAgICBpZiAodG90YWxTdW0gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgYnVuZGxlIGhhc2ggZnJvbSB0aGUgYnVuZGxlIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVuZGxlRnJvbVR4cyA9IG5ldyBJbnQ4QXJyYXkoa2VybC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpKTtcclxuICAgICAgICAgICAgICAgIGtlcmwuc3F1ZWV6ZShidW5kbGVGcm9tVHhzLCAwLCBidW5kbGVGcm9tVHhzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidW5kbGVGcm9tVHhzVHJ5dGVzID0gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoYnVuZGxlRnJvbVR4cykudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYnVuZGxlIGhhc2ggaXMgdGhlIHNhbWUgYXMgcmV0dXJuZWQgYnkgdHggb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidW5kbGVIYXNoID0gYnVuZGxlLnRyYW5zYWN0aW9uc1swXS5idW5kbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVuZGxlRnJvbVR4c1RyeXRlcyAhPT0gYnVuZGxlSGFzaC50b1RyeXRlcygpLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBMYXN0IHR4IGluIHRoZSBidW5kbGUgc2hvdWxkIGhhdmUgY3VycmVudEluZGV4ID09PSBsYXN0SW5kZXhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVuZGxlLnRyYW5zYWN0aW9uc1tidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLmN1cnJlbnRJbmRleC50b051bWJlcigpICE9PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zW2J1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoIC0gMV0ubGFzdEluZGV4LnRvTnVtYmVyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNpZ25hdHVyZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVzVG9WYWxpZGF0ZS5sZW5ndGggJiYgaXNWYWxpZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlID0gaXNzXzEuSVNTLnZhbGlkYXRlU2lnbmF0dXJlcyhzaWduYXR1cmVzVG9WYWxpZGF0ZVtpXS5hZGRyZXNzLCBzaWduYXR1cmVzVG9WYWxpZGF0ZVtpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCBidW5kbGVIYXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFNpZ25hdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgc2lnbmF0dXJlcyBmb3IgZWFjaCBvZiB0aGUgY28tc2lnbmVycyBpbiB0aGUgbXVsdGktc2lnbmF0dXJlIHRvIGluZGVwZW5kZW50bHkgdmVyaWZ5IHRoYXQgYSBnZW5lcmF0ZWRcclxuICAgICAqIHRyYW5zYWN0aW9uIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgc2lnbmF0dXJlcyBvZiB0aGUgY28tc2lnbmVycyBpcyB2YWxpZC5cclxuICAgICAqIEBwYXJhbSBzaWduZWRCdW5kbGUgVGhlIHNpZ25lZCBidW5kbGUgdG8gY2hlY2sgdGhlIHNpZ25hdHVyZXMuXHJcbiAgICAgKiBAcGFyYW0gaW5wdXRBZGRyZXNzIFRoZSBhZGRyZXNzIHVzZWQgdG8gaW5pdGlhdGUgdGhlIHRyYW5zZmVyLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpcyB0aGUgc2lnbmF0dXJlcyBhcmUgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB2YWxpZGF0ZVNpZ25hdHVyZXMoc2lnbmVkQnVuZGxlLCBpbnB1dEFkZHJlc3MpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNpZ25lZEJ1bmRsZSwgYnVuZGxlXzEuQnVuZGxlKSAmJlxyXG4gICAgICAgICAgICBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoc2lnbmVkQnVuZGxlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikgJiZcclxuICAgICAgICAgICAgb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShpbnB1dEFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xyXG4gICAgICAgICAgICBsZXQgYnVuZGxlSGFzaDtcclxuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlRnJhZ21lbnRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0QWRkcmVzc1RyeXRlcyA9IGlucHV0QWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmVkQnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ25lZEJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IGlucHV0QWRkcmVzc1RyeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1bmRsZUhhc2ggPSBzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zW2ldLmJ1bmRsZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSByZWFjaGVkIHJlbWFpbmRlciBidW5kbGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbmVkQnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuRU1QVFkudG9Ucnl0ZXMoKS50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVGcmFnbWVudHMucHVzaChzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zW2ldLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJ1bmRsZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBpc3NfMS5JU1MudmFsaWRhdGVTaWduYXR1cmVzKGlucHV0QWRkcmVzcywgc2lnbmF0dXJlRnJhZ21lbnRzLCBidW5kbGVIYXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZSBhIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSB0aW1lU2VydmljZSBUbyB1c2UgZm9yIHN0YW1waW5nIHRoZSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gYWRkIHRvIHRoZSBidW5kbGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwcmVwYXJlQnVuZGxlKHRpbWVTZXJ2aWNlLCB0cmFuc2ZlcnMpIHtcclxuICAgICAgICBjb25zdCBidW5kbGUgPSBuZXcgYnVuZGxlXzEuQnVuZGxlKCk7XHJcbiAgICAgICAgbGV0IGxhc3RUYWc7XHJcbiAgICAgICAgbGV0IHRvdGFsVmFsdWUgPSAwO1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMgPSBbXTtcclxuICAgICAgICAvLyAgSXRlcmF0ZSBvdmVyIGFsbCB0cmFuc2ZlcnMsIGdldCB0b3RhbFZhbHVlXHJcbiAgICAgICAgLy8gIGFuZCBwcmVwYXJlIHRoZSBNZXNzYWdlcywgbWVzc2FnZSBhbmQgdGFnXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2ZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZU1lc3NhZ2VMZW5ndGggPSAxO1xyXG4gICAgICAgICAgICAvLyBJZiBtZXNzYWdlIGxvbmdlciB0aGFuIDIxODcgdHJ5dGVzLCBpbmNyZWFzZSBzaWduYXR1cmVNZXNzYWdlTGVuZ3RoIChhZGQgMm5kIHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gdHJhbnNmZXJzW2ldLm1lc3NhZ2UudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2VTdHJpbmcubGVuZ3RoID4gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCkge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRvdGFsIGxlbmd0aCwgbWVzc2FnZSAvIG1heExlbmd0aCAoMjE4NyB0cnl0ZXMpXHJcbiAgICAgICAgICAgICAgICBzaWduYXR1cmVNZXNzYWdlTGVuZ3RoICs9IE1hdGguZmxvb3IobWVzc2FnZVN0cmluZy5sZW5ndGggLyBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKTtcclxuICAgICAgICAgICAgICAgIGxldCBtc2dDb3B5ID0gbWVzc2FnZVN0cmluZztcclxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIHRoZXJlIGlzIHN0aWxsIGEgbWVzc2FnZSwgY29weSBpdFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG1zZ0NvcHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnQgPSBtc2dDb3B5LnNsaWNlKDAsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ0NvcHkgPSBtc2dDb3B5LnNsaWNlKHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgsIG1zZ0NvcHkubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQYWQgcmVtYWluZGVyIG9mIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZyYWdtZW50Lmxlbmd0aCA8IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCArPSBcIjlcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cy5wdXNoKHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGZyYWdtZW50KSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gRWxzZSwgZ2V0IHNpbmdsZSBmcmFnbWVudCB3aXRoIDIxODcgb2YgOSdzIHRyeXRlc1xyXG4gICAgICAgICAgICAgICAgbGV0IGZyYWdtZW50ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBtZXNzYWdlU3RyaW5nLnNsaWNlKDAsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZyYWdtZW50Lmxlbmd0aCA8IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ICs9IFwiOVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cy5wdXNoKHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGZyYWdtZW50KSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGdldCBjdXJyZW50IHRpbWVzdGFtcCBpbiBzZWNvbmRzXHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IodGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkgLyAxMDAwKTtcclxuICAgICAgICAgICAgbGFzdFRhZyA9IHRyYW5zZmVyc1tpXS50YWc7XHJcbiAgICAgICAgICAgIC8vIEFkZCBmaXJzdCBlbnRyaWVzIHRvIHRoZSBidW5kbGVcclxuICAgICAgICAgICAgYnVuZGxlLmFkZFRyYW5zYWN0aW9ucyhzaWduYXR1cmVNZXNzYWdlTGVuZ3RoLCB0cmFuc2ZlcnNbaV0uYWRkcmVzcywgdHJhbnNmZXJzW2ldLnZhbHVlLCB0cmFuc2ZlcnNbaV0udGFnLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAvLyBTdW0gdXAgdG90YWwgdmFsdWVcclxuICAgICAgICAgICAgdG90YWxWYWx1ZSArPSB0cmFuc2ZlcnNbaV0udmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGJ1bmRsZSwgdG90YWxWYWx1ZSwgbGFzdFRhZywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduIHRoZSBpbnB1dCBvZiB0aGUgYnVuZGxlLlxyXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gdXNlIGZvciBzaWduaW5nLlxyXG4gICAgICogQHBhcmFtIGJ1bmRsZSBUaGUgYnVuZGxlIHRvIHNpZ24uXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJPcHRpb25zIEFkZGl0aW9uYWwgdHJhbnNmZXIgb3B0aW9ucy5cclxuICAgICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzIFRoZSBzaWduYXR1cmUgbWVzc2FnZSBmcmFnZW10bnMuXHJcbiAgICAgKiBAcGFyYW0gaW5wdXRzIFRoZSBpbnB1dCBmb3IgdXNlLlxyXG4gICAgICogQHBhcmFtIGFkZGVkSE1BQyBIYXMgYW4gSE1BQyBiZWVuIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2lnbklucHV0cyhzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgaW5wdXRzLCBhZGRlZEhNQUMpIHtcclxuICAgICAgICBCdW5kbGVIZWxwZXIuZmluYWxpemVCdW5kbGUoYnVuZGxlKTtcclxuICAgICAgICBidW5kbGUuYWRkU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzKTtcclxuICAgICAgICAvLyAgSGVyZSB3ZSBkbyB0aGUgYWN0dWFsIHNpZ25pbmcgb2YgdGhlIGlucHV0c1xyXG4gICAgICAgIC8vICBJdGVyYXRlIG92ZXIgYWxsIGJ1bmRsZSB0cmFuc2FjdGlvbnMsIGZpbmQgdGhlIGlucHV0c1xyXG4gICAgICAgIC8vICBHZXQgdGhlIGNvcnJlc3BvbmRpbmcgcHJpdmF0ZSBrZXkgYW5kIGNhbGN1bGF0ZSB0aGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChidW5kbGUudHJhbnNhY3Rpb25zW2ldLnZhbHVlLnRvTnVtYmVyKCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzVHJ5dGVzID0gYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY29ycmVzcG9uZGluZyBrZXlJbmRleCBhbmQgc2VjdXJpdHkgb2YgdGhlIGFkZHJlc3NcclxuICAgICAgICAgICAgICAgIGxldCBrZXlJbmRleDtcclxuICAgICAgICAgICAgICAgIGxldCBrZXlTZWN1cml0eTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0c1trXS5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA9PT0gYWRkcmVzc1RyeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlJbmRleCA9IGlucHV0c1trXS5rZXlJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5U2VjdXJpdHkgPSBpbnB1dHNba10uc2VjdXJpdHkgPyBpbnB1dHNba10uc2VjdXJpdHkgOiB0cmFuc2Zlck9wdGlvbnMuc2VjdXJpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEdldCBjb3JyZXNwb25kaW5nIHByaXZhdGUga2V5IG9mIGFkZHJlc3NcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGlzc18xLklTUy5rZXkoc2VlZCwga2V5SW5kZXgsIGtleVNlY3VyaXR5KTtcclxuICAgICAgICAgICAgICAgIEJ1bmRsZUhlbHBlci5zaWduVHJhbnNhY3Rpb25zKGJ1bmRsZSwgaSwgMCwga2V5LCBhZGRyZXNzVHJ5dGVzLCBrZXlTZWN1cml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZGVkSE1BQykge1xyXG4gICAgICAgICAgICBjb25zdCBobWFjID0gbmV3IGhtYWNDdXJsXzEuSG1hY0N1cmwodHJhbnNmZXJPcHRpb25zLmhtYWNLZXkpO1xyXG4gICAgICAgICAgICBobWFjLmFkZEhNQUMoYnVuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpZ24gdGhlIHRyc25hY3Rpb25zXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIHRvIHNpZ24uXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0LlxyXG4gICAgICogQHBhcmFtIGZpcnN0VW5zaWduZWRJbmRleCBUaGUgZmlyc3QgdW5zaWduZWQgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ga2V5VHJpdHMgVGhlIGtleSB0cml0cy5cclxuICAgICAqIEBwYXJhbSBhZGRyZXNzVHJ5dGVzIFRoZSBhZGRyZXNzIHRyeXRlcy5cclxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzaWduVHJhbnNhY3Rpb25zKGJ1bmRsZSwgaW5kZXgsIGZpcnN0VW5zaWduZWRJbmRleCwga2V5VHJpdHMsIGFkZHJlc3NUcnl0ZXMsIHNlY3VyaXR5KSB7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlSGFzaCA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbaW5kZXhdLmJ1bmRsZTtcclxuICAgICAgICAvLyAgR2V0IHRoZSBub3JtYWxpemVkIGJ1bmRsZSBoYXNoXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEJ1bmRsZUhhc2ggPSBpc3NfMS5JU1Mubm9ybWFsaXplZEJ1bmRsZShidW5kbGVIYXNoKTtcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzID0gW107XHJcbiAgICAgICAgLy8gU3BsaXQgaGFzaCBpbnRvIDMgZnJhZ21lbnRzXHJcbiAgICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCAzOyBsKyspIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50c1tsXSA9IG5vcm1hbGl6ZWRCdW5kbGVIYXNoLnNsaWNlKGwgKiAyNywgKGwgKyAxKSAqIDI3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIEZpcnN0IDY1NjEgdHJpdHMgZm9yIHRoZSBmaXJzdEZyYWdtZW50XHJcbiAgICAgICAgY29uc3QgZmlyc3RGcmFnbWVudCA9IGtleVRyaXRzLnNsaWNlKDAsIDY1NjEpO1xyXG4gICAgICAgIC8vICBGaXJzdCBidW5kbGUgZnJhZ21lbnQgdXNlcyB0aGUgZmlyc3QgMjcgdHJ5dGVzXHJcbiAgICAgICAgY29uc3QgZmlyc3RCdW5kbGVGcmFnbWVudCA9IG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudHNbZmlyc3RVbnNpZ25lZEluZGV4XTtcclxuICAgICAgICAvLyAgQ2FsY3VsYXRlIHRoZSBuZXcgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IHdpdGggdGhlIGZpcnN0IGJ1bmRsZSBmcmFnbWVudFxyXG4gICAgICAgIGNvbnN0IGZpcnN0U2lnbmVkRnJhZ21lbnQgPSBpc3NfMS5JU1Muc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KGZpcnN0QnVuZGxlRnJhZ21lbnQsIGZpcnN0RnJhZ21lbnQpO1xyXG4gICAgICAgIC8vICBDb252ZXJ0IHNpZ25hdHVyZSB0byB0cnl0ZXMgYW5kIGFzc2lnbiB0aGUgbmV3IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFxyXG4gICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnNbaW5kZXhdLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5mcm9tVHJ5dGVzKHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGZpcnN0U2lnbmVkRnJhZ21lbnQpLnRvVHJ5dGVzKCkpO1xyXG4gICAgICAgIC8vIGlmIHVzZXIgY2hvb3NlcyBoaWdoZXIgdGhhbiAyNy10cnl0ZSBzZWN1cml0eVxyXG4gICAgICAgIC8vIGZvciBlYWNoIHNlY3VyaXR5IGxldmVsLCBhZGQgYW4gYWRkaXRpb25hbCBzaWduYXR1cmVcclxuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHNlY3VyaXR5OyBqKyspIHtcclxuICAgICAgICAgICAgLy8gIEJlY2F1c2UgdGhlIHNpZ25hdHVyZSBpcyA+IDIxODcgdHJ5dGVzLCB3ZSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vICBmaW5kIHRoZSBzdWJzZXF1ZW50IHRyYW5zYWN0aW9uIHRvIGFkZCB0aGUgcmVtYWluZGVyIG9mIHRoZSBzaWduYXR1cmVcclxuICAgICAgICAgICAgLy8gIFNhbWUgYWRkcmVzcyBhcyB3ZWxsIGFzIHZhbHVlID0gMCAoYXMgd2UgYWxyZWFkeSBzcGVudCB0aGUgaW5wdXQpXHJcbiAgICAgICAgICAgIGlmIChidW5kbGUudHJhbnNhY3Rpb25zW2luZGV4ICsgal0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IGFkZHJlc3NUcnl0ZXNcclxuICAgICAgICAgICAgICAgICYmIGJ1bmRsZS50cmFuc2FjdGlvbnNbaW5kZXggKyBqXS52YWx1ZS50b051bWJlcigpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG5leHQgNjU2MSB0cml0c1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEZyYWdtZW50ID0ga2V5VHJpdHMuc2xpY2UoNjU2MSAqIGosIChqICsgMSkgKiA2NTYxKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdW5kbGVGcmFnbWVudCA9IG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudHNbal07XHJcbiAgICAgICAgICAgICAgICAvLyAgQ2FsY3VsYXRlIHRoZSBuZXcgc2lnbmF0dXJlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2lnbmVkRnJhZ21lbnQgPSBpc3NfMS5JU1Muc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KG5leHRCdW5kbGVGcmFnbWVudCwgbmV4dEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgIC8vICBDb252ZXJ0IHNpZ25hdHVyZSB0byB0cnl0ZXMgYW5kIGFzc2lnbiBpdCBhZ2FpbiB0byB0aGlzIGJ1bmRsZSBlbnRyeVxyXG4gICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tpbmRleCArIGpdLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5mcm9tVHJ5dGVzKHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KG5leHRTaWduZWRGcmFnbWVudCkudG9Ucnl0ZXMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsaXplIGEgYnVuZGxlLlxyXG4gICAgICogQHBhcmFtIGJ1bmRsZSBUaGUgYnVuZGxlIHRvIGZpbmFsaXplLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZmluYWxpemVCdW5kbGUoYnVuZGxlKSB7XHJcbiAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgdmFsaWRCdW5kbGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKCF2YWxpZEJ1bmRsZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwia2VybFwiKTtcclxuICAgICAgICAgICAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5jdXJyZW50SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5sYXN0SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBidW5kbGVFc3NlbmNlID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBidW5kbGUudHJhbnNhY3Rpb25zW2ldLnZhbHVlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSArIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uQ0hFQ0tfVkFMVUVcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyBidW5kbGUudHJhbnNhY3Rpb25zW2ldLm9ic29sZXRlVGFnLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0udGltZXN0YW1wLnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uY3VycmVudEluZGV4LnRvVHJ5dGVzKCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0ubGFzdEluZGV4LnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkpLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICBrZXJsLmFic29yYihidW5kbGVFc3NlbmNlLCAwLCBidW5kbGVFc3NlbmNlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoVHJpdHMgPSBuZXcgSW50OEFycmF5KGtlcmwuZ2V0Q29uc3RhbnQoXCJIQVNIX0xFTkdUSFwiKSk7XHJcbiAgICAgICAgICAgICAgICBrZXJsLnNxdWVlemUoaGFzaFRyaXRzLCAwLCBoYXNoVHJpdHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGhhc2hUcml0cykudG9Ucnl0ZXMoKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zW2ldLmJ1bmRsZSA9IGhhc2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSGFzaCA9IGlzc18xLklTUy5ub3JtYWxpemVkQnVuZGxlKGhhc2gpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRIYXNoLmluZGV4T2YoMTMgLyogPSBNICovKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlY3VyZSBidW5kbGUuIEluY3JlbWVudCBUYWcgYW5kIHJlY29tcHV0ZSBidW5kbGUgaGFzaC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmNyZWFzZWRUYWcgPSB0cml0c18xLlRyaXRzLmFkZCh0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoYnVuZGxlLnRyYW5zYWN0aW9uc1swXS5vYnNvbGV0ZVRhZy50b1RyeXRlcygpKSwgdHJpdHNfMS5Ucml0cy5mcm9tTnVtYmVyQXJyYXkoWzFdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1swXS5vYnNvbGV0ZVRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKGluY3JlYXNlZFRhZy50b1RyeXRlcygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkQnVuZGxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5CdW5kbGVIZWxwZXIuTlVNQkVSX09GX0ZSQUdNRU5UX0NIVU5LUyA9IDI3O1xyXG5leHBvcnRzLkJ1bmRsZUhlbHBlciA9IEJ1bmRsZUhlbHBlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWW5WdVpHeGxTR1ZzY0dWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJobGJIQmxjbk12WW5WdVpHeGxTR1ZzY0dWeUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdRVUZCUVN3d1JVRkJkVVU3UVVGRGRrVXNORVZCUVhsRk8wRkJSWHBGTEd0R1FVRXJSVHRCUVVNdlJTeDVSRUZCYzBRN1FVRkRkRVFzSzBSQlFUUkVPMEZCUlRWRUxEWkVRVUV3UkR0QlFVTXhSQ3g1UkVGQmMwUTdRVUZGZEVRc2FVZEJRVGhHTzBGQlF6bEdMSFZFUVVGdlJEdEJRVU53UkN4MVJVRkJiMFU3UVVGRmNFVXNNa1JCUVhkRU8wRkJRM2hFTEhWRlFVRnZSVHRCUVVOd1JTdzJSRUZCTUVRN1FVRkRNVVFzSzBOQlFUUkRPMEZCUnpWRE96czdSMEZIUnp0QlFVTklPMGxCUjBrN096czdUMEZKUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQll6dFJRVU5vUXl4SlFVRkpMRTlCUVU4c1IwRkJSeXhMUVVGTExFTkJRVU03VVVGRmNFSXNTVUZCU1N3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNaVUZCVFN4RFFVRkRMRWxCUVVrc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRmxCUVZrc1JVRkJSU3g1UWtGQlZ5eERRVUZETEVWQlFVVTdXVUZET1VZc1NVRkJTU3hSUVVGUkxFZEJRVWNzUTBGQlF5eERRVUZETzFsQlJXcENMRTFCUVUwc1NVRkJTU3hIUVVGSExEWkNRVUZoTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFsQlEzSkVMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF6dFpRVVZzUWl4dFEwRkJiVU03V1VGRGJrTXNUVUZCVFN4dlFrRkJiMElzUjBGQmEwWXNSVUZCUlN4RFFVRkRPMWxCUlM5SExFOUJRVThzUjBGQlJ5eEpRVUZKTEVOQlFVTTdXVUZEWml4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhOUVVGTkxFbEJRVWtzVDBGQlR5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMmRDUVVNMVJDeE5RVUZOTEZGQlFWRXNSMEZCUnl4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjRReXhSUVVGUkxFbEJRVWtzVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRuUWtGRmRFTXNlVVJCUVhsRU8yZENRVU42UkN4SlFVRkpMRkZCUVZFc1EwRkJReXhaUVVGWkxFTkJRVU1zVVVGQlVTeEZRVUZGTEV0QlFVc3NRMEZCUXl4RlFVRkZPMjlDUVVONFF5eFBRVUZQTEVkQlFVY3NTMEZCU3l4RFFVRkRPMmxDUVVOdVFqdHhRa0ZCVFR0dlFrRkRTQ3cyUWtGQk5rSTdiMEpCUXpkQ0xFMUJRVTBzV1VGQldTeEhRVUZITEZGQlFWRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenR2UWtGRmVrTXNORVZCUVRSRk8yOUNRVU0xUlN4TlFVRk5MRmRCUVZjc1IwRkJSeXhoUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc2JVUkJRWGRDTEVOQlFVTXNUVUZCVFN4RlFVRkZMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEVOQlFVTTdiMEpCUTNaSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNc1JVRkJSU3hYUVVGWExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdiMEpCUldoRUxEWkNRVUUyUWp0dlFrRkROMElzU1VGQlNTeFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hIUVVGSExFTkJRVU1zUlVGQlJUdDNRa0ZETDBJc1RVRkJUU3h6UWtGQmMwSXNSMEZCWjBZN05FSkJRM2hITEU5QlFVOHNSVUZCUlN4UlFVRlJMRU5CUVVNc1QwRkJUenMwUWtGRGVrSXNlVUpCUVhsQ0xFVkJRVVVzUTBGQlF5eFJRVUZSTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU03ZVVKQlEycEZMRU5CUVVNN2QwSkJSVVlzWjBWQlFXZEZPM2RDUVVOb1JTeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGT3pSQ1FVTnlSQ3hOUVVGTkxGZEJRVmNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6czBRa0ZGTDBNc2IwUkJRVzlFT3pSQ1FVTndSQ3hKUVVGSkxGZEJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFdEJRVXNzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVU3YlVOQlEycEdMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEV0QlFVc3NRMEZCUXl4RlFVRkZPMmREUVVOMlF5eHpRa0ZCYzBJc1EwRkJReXg1UWtGQmVVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExIZENRVUYzUWl4RFFVRkRMRU5CUVVNN05rSkJReTlHTzNsQ1FVTktPM2RDUVVWRUxHOUNRVUZ2UWl4RFFVRkRMRWxCUVVrc1EwRkJReXh6UWtGQmMwSXNRMEZCUXl4RFFVRkRPM0ZDUVVOeVJEdHBRa0ZEU2p0aFFVTktPMWxCUlVRc2JVUkJRVzFFTzFsQlEyNUVMRWxCUVVrc1VVRkJVU3hMUVVGTExFTkJRVU1zUlVGQlJUdG5Ra0ZEYUVJc1QwRkJUeXhIUVVGSExFdEJRVXNzUTBGQlF6dGhRVU51UWp0cFFrRkJUVHRuUWtGRFNDeHRSRUZCYlVRN1owSkJRMjVFTEUxQlFVMHNZVUZCWVN4SFFVRkhMRWxCUVVrc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrVXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhoUVVGaExFVkJRVVVzUTBGQlF5eEZRVUZGTEdGQlFXRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRuUWtGRmNrUXNUVUZCVFN4dFFrRkJiVUlzUjBGQlJ5eGhRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMmRDUVVWcVJpdzBSRUZCTkVRN1owSkJRelZFTEUxQlFVMHNWVUZCVlN4SFFVRkhMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRPMmRDUVVOcVJDeEpRVUZKTEcxQ1FVRnRRaXhMUVVGTExGVkJRVlVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJSVHR2UWtGRE1VUXNUMEZCVHl4SFFVRkhMRXRCUVVzc1EwRkJRenRwUWtGRGJrSTdjVUpCUVUwN2IwSkJRMGdzSzBSQlFTdEVPMjlDUVVNdlJDeEpRVUZKTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1dVRkJXU3hEUVVGRExGRkJRVkVzUlVGQlJUdDNRa0ZEZGtVc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RlFVRkZMRVZCUVVVN2QwSkJRemxGTEU5QlFVOHNSMEZCUnl4TFFVRkxMRU5CUVVNN2NVSkJRMjVDTzNsQ1FVRk5PM2RDUVVOSUxEQkNRVUV3UWp0M1FrRkRNVUlzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExHOUNRVUZ2UWl4RFFVRkRMRTFCUVUwc1NVRkJTU3hQUVVGUExFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdORUpCUXpkRUxFMUJRVTBzWjBKQlFXZENMRWRCUVVjc1UwRkJSeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMRzlDUVVGdlFpeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkRMMElzYjBKQlFXOUNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFYbENMRVZCUTJwRUxGVkJRVlVzUTBGQlF5eERRVUZET3pSQ1FVVTFSQ3hKUVVGSkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVN1owTkJRMjVDTEU5QlFVOHNSMEZCUnl4TFFVRkxMRU5CUVVNN05rSkJRMjVDTzNsQ1FVTktPM0ZDUVVOS08ybENRVU5LTzJGQlEwbzdVMEZEU2p0UlFVVkVMRTlCUVU4c1QwRkJUeXhEUVVGRE8wbEJRMjVDTEVOQlFVTTdTVUZGUkRzN096czdPMDlCVFVjN1NVRkRTU3hOUVVGTkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1dVRkJiMElzUlVGQlJTeFpRVUZ4UWp0UlFVTjRSU3hKUVVGSkxFOUJRVThzUjBGQlJ5eExRVUZMTEVOQlFVTTdVVUZEY0VJc1NVRkJTU3d5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4WlFVRlpMRVZCUVVVc1pVRkJUU3hEUVVGRE8xbEJRM3BETEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExGbEJRVmtzUTBGQlF5eFpRVUZaTEVWQlFVVXNlVUpCUVZjc1EwRkJRenRaUVVNelJDd3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFVkJRVVVzYVVKQlFVOHNRMEZCUXl4RlFVRkZPMWxCUXpWRExFbEJRVWtzVlVGQlZTeERRVUZETzFsQlEyWXNUVUZCVFN4clFrRkJhMElzUjBGQlJ5eEZRVUZGTEVOQlFVTTdXVUZET1VJc1RVRkJUU3hyUWtGQmEwSXNSMEZCUnl4WlFVRlpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdXVUZGT1VRc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRmxCUVZrc1EwRkJReXhaUVVGWkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMmRDUVVOMlJDeEpRVUZKTEZsQlFWa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hMUVVGTExHdENRVUZyUWl4RlFVRkZPMjlDUVVOdVJpeFZRVUZWTEVkQlFVY3NXVUZCV1N4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTTdiMEpCUldwRUxHbERRVUZwUXp0dlFrRkRha01zU1VGQlNTeFpRVUZaTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExIZENRVUYzUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJUdDNRa0ZETTBVc2JVUkJRWGRDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeEZRVUZGTzNkQ1FVTjBSQ3hOUVVGTk8zRkNRVU5VTzI5Q1FVVkVMR3RDUVVGclFpeERRVUZETEVsQlFVa3NRMEZCUXl4WlFVRlpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEhkQ1FVRjNRaXhEUVVGRExFTkJRVU03YVVKQlEyeEdPMkZCUTBvN1dVRkZSQ3hKUVVGSkxGVkJRVlVzUlVGQlJUdG5Ra0ZEV2l4UFFVRlBMRWRCUVVjc1UwRkJSeXhEUVVGRExHdENRVUZyUWl4RFFVRkRMRmxCUVZrc1JVRkJSU3hyUWtGQmEwSXNSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRoUVVOc1JqdFRRVU5LTzFGQlJVUXNUMEZCVHl4UFFVRlBMRU5CUVVNN1NVRkRia0lzUTBGQlF6dEpRVVZFT3pzN08wOUJTVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRmRCUVhsQ0xFVkJRVVVzVTBGQmNVSTdVVUZGZUVVc1RVRkJUU3hOUVVGTkxFZEJRVWNzU1VGQlNTeGxRVUZOTEVWQlFVVXNRMEZCUXp0UlFVTTFRaXhKUVVGSkxFOUJRVmtzUTBGQlF6dFJRVVZxUWl4SlFVRkpMRlZCUVZVc1IwRkJWeXhEUVVGRExFTkJRVU03VVVGRE0wSXNUVUZCVFN4NVFrRkJlVUlzUjBGQkswSXNSVUZCUlN4RFFVRkRPMUZCUldwRkxEaERRVUU0UXp0UlFVTTVReXcyUTBGQk5rTTdVVUZETjBNc1MwRkJTeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRk5CUVZNc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdXVUZEZGtNc1NVRkJTU3h6UWtGQmMwSXNSMEZCUnl4RFFVRkRMRU5CUVVNN1dVRkZMMElzTkVaQlFUUkdPMWxCUXpWR0xFMUJRVTBzWVVGQllTeEhRVUZITEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdXVUZEZEVRc1NVRkJTU3hoUVVGaExFTkJRVU1zVFVGQlRTeEhRVUZITEcxRVFVRjNRaXhEUVVGRExFMUJRVTBzUlVGQlJUdG5Ra0ZEZUVRc2MwUkJRWE5FTzJkQ1FVTjBSQ3h6UWtGQmMwSXNTVUZCU1N4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExHRkJRV0VzUTBGQlF5eE5RVUZOTEVkQlFVY3NiVVJCUVhkQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdaMEpCUlRkR0xFbEJRVWtzVDBGQlR5eEhRVUZITEdGQlFXRXNRMEZCUXp0blFrRkZOVUlzTUVOQlFUQkRPMmRDUVVNeFF5eFBRVUZQTEU5QlFVOHNSVUZCUlR0dlFrRkRXaXhKUVVGSkxGRkJRVkVzUjBGQlJ5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1JVRkJSU3h0UkVGQmQwSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenR2UWtGRGFrVXNUMEZCVHl4SFFVRkhMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zYlVSQlFYZENMRU5CUVVNc1RVRkJUU3hGUVVGRkxFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0dlFrRkZla1VzTkVKQlFUUkNPMjlDUVVNMVFpeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hSUVVGUkxFTkJRVU1zVFVGQlRTeEhRVUZITEcxRVFVRjNRaXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0M1FrRkRjRVVzVVVGQlVTeEpRVUZKTEVkQlFVY3NRMEZCUXp0eFFrRkRia0k3YjBKQlJVUXNlVUpCUVhsQ0xFTkJRVU1zU1VGQlNTeERRVUZETEcxRVFVRjNRaXhEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHBRa0ZEY0VjN1lVRkRTanRwUWtGQlRUdG5Ra0ZEU0N4dlJFRkJiMFE3WjBKQlEzQkVMRWxCUVVrc1VVRkJVU3hIUVVGSExFVkJRVVVzUTBGQlF6dG5Ra0ZGYkVJc1NVRkJTU3hoUVVGaExFVkJRVVU3YjBKQlEyWXNVVUZCVVN4SFFVRkhMR0ZCUVdFc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTEcxRVFVRjNRaXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzJsQ1FVTjBSVHRuUWtGRlJDeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hSUVVGUkxFTkJRVU1zVFVGQlRTeEhRVUZITEcxRVFVRjNRaXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0dlFrRkRjRVVzVVVGQlVTeEpRVUZKTEVkQlFVY3NRMEZCUXp0cFFrRkRia0k3WjBKQlJVUXNlVUpCUVhsQ0xFTkJRVU1zU1VGQlNTeERRVUZETEcxRVFVRjNRaXhEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dGhRVU53Unp0WlFVVkVMRzFEUVVGdFF6dFpRVU51UXl4TlFVRk5MRk5CUVZNc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZkQlFWY3NRMEZCUXl4WlFVRlpMRVZCUVVVc1IwRkJSeXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVVZvUlN4UFFVRlBMRWRCUVVjc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXp0WlFVVXpRaXhyUTBGQmEwTTdXVUZEYkVNc1RVRkJUU3hEUVVGRExHVkJRV1VzUTBGQlF5eHpRa0ZCYzBJc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0WlFVVjBTQ3h4UWtGQmNVSTdXVUZEY2tJc1ZVRkJWU3hKUVVGSkxGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNN1UwRkRjRU03VVVGRlJDeFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRlZCUVZVc1JVRkJSU3hQUVVGUExFVkJRVVVzZVVKQlFYbENMRVZCUVVVc1EwRkJRenRKUVVOMFJTeERRVUZETzBsQlJVUTdPenM3T3pzN08wOUJVVWM3U1VGRFNTeE5RVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVZVc1JVRkRWaXhOUVVGakxFVkJRMlFzWlVGQlowTXNSVUZEYUVNc2VVSkJRWEZFTEVWQlEzSkVMRTFCUVdVc1JVRkRaaXhUUVVGclFqdFJRVU4yUXl4WlFVRlpMRU5CUVVNc1kwRkJZeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlEzQkRMRTFCUVUwc1EwRkJReXcwUWtGQk5FSXNRMEZCUXl4NVFrRkJlVUlzUTBGQlF5eERRVUZETzFGQlJTOUVMQ3REUVVFclF6dFJRVU12UXl4NVJFRkJlVVE3VVVGRGVrUXNaMFpCUVdkR08xRkJRMmhHTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVU5xUkN4SlFVRkpMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hIUVVGSExFTkJRVU1zUlVGQlJUdG5Ra0ZETjBNc1RVRkJUU3hoUVVGaExFZEJRVWNzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1owSkJSVE5GTERaRVFVRTJSRHRuUWtGRE4wUXNTVUZCU1N4UlFVRlJMRU5CUVVNN1owSkJRMklzU1VGQlNTeFhRVUZYTEVOQlFVTTdaMEpCUTJoQ0xFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNSVUZCUlN4RlFVRkZPMjlDUVVWd1F5eEpRVUZKTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRXRCUVVzc1lVRkJZU3hGUVVGRk8zZENRVVV6UkN4UlFVRlJMRWRCUVVjc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXp0M1FrRkRPVUlzVjBGQlZ5eEhRVUZITEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEdWQlFXVXNRMEZCUXl4UlFVRlJMRU5CUVVNN2QwSkJRMnBHTEUxQlFVMDdjVUpCUTFRN2FVSkJRMG83WjBKQlJVUXNNa05CUVRKRE8yZENRVU16UXl4TlFVRk5MRWRCUVVjc1IwRkJSeXhUUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVsQlFVa3NSVUZCUlN4UlFVRlJMRVZCUVVVc1YwRkJWeXhEUVVGRExFTkJRVU03WjBKQlJXcEVMRmxCUVZrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEhRVUZITEVWQlFVVXNZVUZCWVN4RlFVRkZMRmRCUVZjc1EwRkJReXhEUVVGRE8yRkJRMmhHTzFOQlEwbzdVVUZGUkN4SlFVRkpMRk5CUVZNc1JVRkJSVHRaUVVOWUxFMUJRVTBzU1VGQlNTeEhRVUZITEVsQlFVa3NiVUpCUVZFc1EwRkJReXhsUVVGbExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEYmtRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0VFFVTjRRanRKUVVOTUxFTkJRVU03U1VGRlJEczdPenM3T3pzN1QwRlJSenRKUVVOSkxFMUJRVTBzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhOUVVGakxFVkJRVVVzUzBGQllTeEZRVUZGTEd0Q1FVRXdRaXhGUVVGRkxGRkJRVzFDTEVWQlFVVXNZVUZCY1VJc1JVRkJSU3hSUVVGNVFqdFJRVU16U2l4TlFVRk5MRlZCUVZVc1IwRkJSeXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVWeVJDeHJRMEZCYTBNN1VVRkRiRU1zVFVGQlRTeHZRa0ZCYjBJc1IwRkJSeXhUUVVGSExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRE9VUXNUVUZCVFN4NVFrRkJlVUlzUjBGQlowSXNSVUZCUlN4RFFVRkRPMUZCUld4RUxEaENRVUU0UWp0UlFVTTVRaXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlEzaENMSGxDUVVGNVFpeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRzlDUVVGdlFpeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRMjVHTzFGQlJVUXNNRU5CUVRCRE8xRkJRekZETEUxQlFVMHNZVUZCWVN4SFFVRkhMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUlRsRExHdEVRVUZyUkR0UlFVTnNSQ3hOUVVGTkxHMUNRVUZ0UWl4SFFVRkhMSGxDUVVGNVFpeERRVUZETEd0Q1FVRnJRaXhEUVVGRExFTkJRVU03VVVGRk1VVXNOa1ZCUVRaRk8xRkJRemRGTEUxQlFVMHNiVUpCUVcxQ0xFZEJRVWNzVTBGQlJ5eERRVUZETEhkQ1FVRjNRaXhEUVVGRExHMUNRVUZ0UWl4RlFVRkZMR0ZCUVdFc1EwRkJReXhEUVVGRE8xRkJSVGRHTERKRlFVRXlSVHRSUVVNelJTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExIZENRVUYzUWl4SFFVRkhMRzFFUVVGM1FpeERRVUZETEZWQlFWVXNRMEZCUXl4aFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExHMUNRVUZ0UWl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVVV6U1N4blJFRkJaMFE3VVVGRGFFUXNkVVJCUVhWRU8xRkJRM1pFTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1dVRkZMMElzYzBSQlFYTkVPMWxCUTNSRUxIbEZRVUY1UlR0WlFVTjZSU3h4UlVGQmNVVTdXVUZEY2tVc1NVRkJTU3hOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEV0QlFVc3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRXRCUVVzc1lVRkJZVHR0UWtGRGRFVXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hMUVVGTExFTkJRVU1zUlVGQlJUdG5Ra0ZGTDBRc01FSkJRVEJDTzJkQ1FVTXhRaXhOUVVGTkxGbEJRVmtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFTkJRVU03WjBKQlJUbEVMRTFCUVUwc2EwSkJRV3RDTEVkQlFVY3NlVUpCUVhsQ0xFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUlhoRUxDdENRVUVyUWp0blFrRkRMMElzVFVGQlRTeHJRa0ZCYTBJc1IwRkJSeXhUUVVGSExFTkJRVU1zZDBKQlFYZENMRU5CUVVNc2EwSkJRV3RDTEVWQlFVVXNXVUZCV1N4RFFVRkRMRU5CUVVNN1owSkJSVEZHTEhkRlFVRjNSVHRuUWtGRGVFVXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhMUVVGTExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNkMEpCUVhkQ0xFZEJRVWNzYlVSQlFYZENMRU5CUVVNc1ZVRkJWU3hEUVVGRExHRkJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRPMkZCUTJwS08xTkJRMG83U1VGRFRDeERRVUZETzBsQlJVUTdPenRQUVVkSE8wbEJRMGtzVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXl4TlFVRmpPMUZCUTNaRExFbEJRVWtzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRMmhETEVsQlFVa3NWMEZCVnl4SFFVRkhMRXRCUVVzc1EwRkJRenRaUVVWNFFpeFBRVUZQTEVOQlFVTXNWMEZCVnl4RlFVRkZPMmRDUVVWcVFpeE5RVUZOTEVsQlFVa3NSMEZCUnl3MlFrRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRuUWtGRGNrUXNTVUZCU1N4RFFVRkRMRlZCUVZVc1JVRkJSU3hEUVVGRE8yZENRVVZzUWl4TFFVRkxMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVkQlFVY3NUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF5eEZRVUZGTEVWQlFVVTdiMEpCUTJwRUxFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1dVRkJXU3hIUVVGSExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU5vUlN4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNSMEZCUnl4NVFrRkJWeXhEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZGTVVZc1RVRkJUU3hoUVVGaExFZEJRVWNzWVVGQlN5eERRVUZETEZWQlFWVXNRMEZCUXl4bFFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVOd1JDeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN01FSkJRMnhFTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hIUVVGSExIbENRVUZYTEVOQlFVTXNWMEZCVnpzd1FrRkROVVVzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZPekJDUVVONFJDeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVN01FSkJRM1JFTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zV1VGQldTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSVHN3UWtGRGVrUXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRek5FTEVOQlFVTXNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJRenR2UWtGRFlpeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMR0ZCUVdFc1JVRkJSU3hEUVVGRExFVkJRVVVzWVVGQllTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmxDUVVOMlJEdG5Ra0ZGUkN4TlFVRk5MRk5CUVZNc1IwRkJSeXhKUVVGSkxGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEycEZMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTXNSVUZCUlN4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlJUZERMRTFCUVUwc1NVRkJTU3hIUVVGSExGZEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNZVUZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRPMmRDUVVOd1JTeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3YjBKQlEycEVMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJRenRwUWtGRGVFTTdaMEpCUlVRc1RVRkJUU3hqUVVGakxFZEJRVWNzVTBGQlJ5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkQ1FVTnNSQ3hKUVVGSkxHTkJRV01zUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlN4RFFVRkRMRk5CUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eEZRVUZGTzI5Q1FVTTNReXcwUkVGQk5FUTdiMEpCUXpWRUxFMUJRVTBzV1VGQldTeEhRVUZITEdGQlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1lVRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RlFVRkZMR0ZCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRelZJTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVjBGQlZ5eEhRVUZITEZOQlFVY3NRMEZCUXl4VlFVRlZMRU5CUVVNc1dVRkJXU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdhVUpCUTJoR08zRkNRVUZOTzI5Q1FVTklMRmRCUVZjc1IwRkJSeXhKUVVGSkxFTkJRVU03YVVKQlEzUkNPMkZCUTBvN1UwRkRTanRKUVVOTUxFTkJRVU03TzBGQmNGZHpRaXh6UTBGQmVVSXNSMEZCVnl4RlFVRkZMRU5CUVVNN1FVRkViRVVzYjBOQmMxZERJbjA9IiwiZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIENvbWJpbmVkIGluZGV4IG9mIGFsbCB0aGUgbW9kdWxlcy5cclxuICovXHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Vycm9yL2J1c2luZXNzRXJyb3JcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZWxwZXJzL2FkZHJlc3NIZWxwZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9oZWxwZXJzL2J1bmRsZUhlbHBlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL211bHRpU2lnL211bHRpU2lnQWRkcmVzc1wiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL211bHRpU2lnL211bHRpU2lnQ2xpZW50XCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vc2lnbi9obWFjQ3VybFwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbkNsaWVudFwiKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNWtaWGd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmFXNWtaWGd1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096dEJRVUZCT3p0SFFVVkhPMEZCUTBnc01rTkJRWE5ETzBGQlEzUkRMRFpEUVVGM1F6dEJRVU40UXl3MFEwRkJkVU03UVVGRmRrTXNaMFJCUVRKRE8wRkJRek5ETEN0RFFVRXdRenRCUVVNeFF5eHhRMEZCWjBNN1FVRkRhRU1zYzBSQlFXbEVJbjA9IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBzcG9uZ2VGYWN0b3J5XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jcnlwdG8vZGlzdC9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeVwiKTtcclxuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYWRkcmVzc1wiKTtcclxuY29uc3QgdHJpdHNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyaXRzXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuY29uc3QgYnVzaW5lc3NFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2J1c2luZXNzRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBBZGRyZXNzIHVzaW5nIG11bHRpcGxlIHNpZ25hdHVyZXMuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aVNpZ0FkZHJlc3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIE11bHRpU2lnQWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fa2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFwia2VybFwiKTtcclxuICAgICAgICB0aGlzLl9oYXNoTGVuZ3RoID0gdGhpcy5fa2VybC5nZXRDb25zdGFudChcIkhBU0hfTEVOR1RIXCIpO1xyXG4gICAgICAgIHRoaXMuX2tlcmwuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvcmIga2V5IGRpZ2VzdHMuXHJcbiAgICAgKiBAcGFyYW0gZGlnZXN0cyBUaGUgZGlnZXN0cyBoYXNoZXMgdG8gYWJzb3JiLlxyXG4gICAgICovXHJcbiAgICBhYnNvcmIoZGlnZXN0cykge1xyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKGRpZ2VzdHMsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGRpZ2VzdHMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHR5cGUgVHJ5dGVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2VzdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGlnZXN0VHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoZGlnZXN0c1tpXSkudG9BcnJheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXJsLmFic29yYihkaWdlc3RUcml0cywgMCwgZGlnZXN0VHJpdHMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsaXplcyBhbmQgcmV0dXJucyB0aGUgbXVsdGlzaWcgYWRkcmVzcyBpbiB0cnl0ZXMuXHJcbiAgICAgKiBAcGFyYW0gZGlnZXN0cyBUaGUgZmluYWwgZGlnZXN0cyBoYXNoZXMgdG8gYWJzb3JiLlxyXG4gICAgICogQHJldHVybnMgVGhlIG11bHRpIHNpZ25hdHVyZSBhZGRyZXNzLlxyXG4gICAgICovXHJcbiAgICBmaW5hbGl6ZShkaWdlc3RzKSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShkaWdlc3RzKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFic29yYihkaWdlc3RzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc1RyaXRzID0gbmV3IEludDhBcnJheSh0aGlzLl9oYXNoTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9rZXJsLnNxdWVlemUoYWRkcmVzc1RyaXRzLCAwLCBhZGRyZXNzVHJpdHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gYWRkcmVzc18xLkFkZHJlc3MuZnJvbVRyeXRlcyh0cml0c18xLlRyaXRzLmZyb21BcnJheShhZGRyZXNzVHJpdHMpLnRvVHJ5dGVzKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTXVsdGlTaWdBZGRyZXNzID0gTXVsdGlTaWdBZGRyZXNzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liWFZzZEdsVGFXZEJaR1J5WlhOekxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDIxMWJIUnBVMmxuTDIxMWJIUnBVMmxuUVdSa2NtVnpjeTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNNRVZCUVhWRk8wRkJRM1pGTERSRlFVRjVSVHRCUVVONlJTeHJSa0ZCSzBVN1FVRkZMMFVzSzBSQlFUUkVPMEZCUXpWRUxESkVRVUYzUkR0QlFVTjRSQ3cyUkVGQk1FUTdRVUZETVVRc01FUkJRWFZFTzBGQlJYWkVPenRIUVVWSE8wRkJRMGc3U1VGUFNUczdUMEZGUnp0SlFVTklPMUZCUTBrc1NVRkJTU3hEUVVGRExFdEJRVXNzUjBGQlJ5dzJRa0ZCWVN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTnlSQ3hKUVVGSkxFTkJRVU1zVjBGQlZ5eEhRVUZITEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJWeXhEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETzFGQlEzcEVMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTTdTVUZETlVJc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkpMRTFCUVUwc1EwRkJReXhQUVVGcFFqdFJRVU16UWl4SlFVRkpMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RlFVRkZMR1ZCUVUwc1EwRkJReXhGUVVGRk8xbEJRM1pETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExDdERRVUVyUXl4RFFVRkRMRU5CUVVNN1UwRkROVVU3VVVGRFJDeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRaUVVOeVF5eE5RVUZOTEZkQlFWY3NSMEZCUnl4aFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8xbEJSVE5FTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExGZEJRVmNzUlVGQlJTeERRVUZETEVWQlFVVXNWMEZCVnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xTkJRM3BFTzBsQlEwd3NRMEZCUXp0SlFVVkVPenM3TzA5QlNVYzdTVUZEU1N4UlFVRlJMRU5CUVVNc1QwRkJhMEk3VVVGRE9VSXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RlFVRkZPMWxCUTJoRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1UwRkRlRUk3VVVGRlJDeE5RVUZOTEZsQlFWa3NSMEZCUnl4SlFVRkpMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZEY2tRc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNXVUZCV1N4RlFVRkZMRU5CUVVNc1JVRkJSU3haUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZGZWtRc1QwRkJUeXhwUWtGQlR5eERRVUZETEZWQlFWVXNRMEZCUXl4aFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1NVRkRlRVVzUTBGQlF6dERRVU5LTzBGQk9VTkVMREJEUVRoRFF5SjkiLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFycmF5SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlclwiKTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCB0aW1lU2VydmljZV8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L3NlcnZpY2VzL3RpbWVTZXJ2aWNlXCIpO1xyXG5jb25zdCBpc3NfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2hhc2gvaXNzXCIpO1xyXG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzXCIpO1xyXG5jb25zdCBidW5kbGVfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2J1bmRsZVwiKTtcclxuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvaGFzaFwiKTtcclxuY29uc3Qgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRcIik7XHJcbmNvbnN0IHRhZ18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdGFnXCIpO1xyXG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb25cIik7XHJcbmNvbnN0IHRyYW5zZmVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cmFuc2ZlclwiKTtcclxuY29uc3QgdHJpdHNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyaXRzXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuY29uc3QgYnVzaW5lc3NFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2J1c2luZXNzRXJyb3JcIik7XHJcbmNvbnN0IGJ1bmRsZUhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvYnVuZGxlSGVscGVyXCIpO1xyXG5jb25zdCBtdWx0aVNpZ0FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL211bHRpU2lnQWRkcmVzc1wiKTtcclxuLyoqXHJcbiAqIE11bHRpcGxlIHNpZ25hdHVyZXMuXHJcbiAqIENvbnZlcnRlZCBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pb3RhLmxpYi5qcy9ibG9iL21hc3Rlci9saWIvbXVsdGlzaWcvbXVsdGlzaWcuanNcclxuICovXHJcbmNsYXNzIE11bHRpU2lnQ2xpZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBNdWx0aVNpZ0NsaWVudC5cclxuICAgICAqIEBwYXJhbSBhcGlDbGllbnQgQW4gQVBJIENsaWVudCB0byBjb21tdW5pY2F0ZSB0aHJvdWdoLlxyXG4gICAgICogQHBhcmFtIHRpbWVTZXJ2aWNlIEEgY2xhc3Mgd2hpY2ggY2FuIHByb3ZpZGUgdGhlIHRpbWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgdGltZVNlcnZpY2UgPSBuZXcgdGltZVNlcnZpY2VfMS5UaW1lU2VydmljZSgpKSB7XHJcbiAgICAgICAgdGhpcy5fYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xyXG4gICAgICAgIHRoaXMuX3RpbWVTZXJ2aWNlID0gdGltZVNlcnZpY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUga2V5IHZhbHVlIG9mIGEgc2VlZC5cclxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdldCB0aGUga2V5IGZvci5cclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgYWRkcmVzcyBpbmRleCB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIHRvIHVzZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgZm9yIHRoZSBrZXkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRLZXkoc2VlZCwgaW5kZXgsIHNlY3VyaXR5KSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlZWQsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc2VlZCBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGluZGV4KSB8fCBpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGluZGV4IHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgMSB8fCBzZWN1cml0eSA+IDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlY3VyaXR5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzXCIsIHsgc2VjdXJpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cml0c18xLlRyaXRzLmZyb21BcnJheShpc3NfMS5JU1Mua2V5KHNlZWQsIGluZGV4LCBzZWN1cml0eSkpLnRvVHJ5dGVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGlnZXN0IHZhbHVlIG9mIGEgc2VlZC5cclxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdldCB0aGUgZGlnZXN0IGZvci5cclxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgYWRkcmVzcyBpbmRleCB0byB1c2UuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIHRvIHVzZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgZm9yIHRoZSBkaWdlc3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXREaWdlc3Qoc2VlZCwgaW5kZXgsIHNlY3VyaXR5KSB7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlZWQsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc2VlZCBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGluZGV4KSB8fCBpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGluZGV4IHNob3VsZCBiZSBhIG51bWJlciA+PSAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgMSB8fCBzZWN1cml0eSA+IDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlY3VyaXR5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzXCIsIHsgc2VjdXJpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleSA9IGlzc18xLklTUy5rZXkoc2VlZCwgaW5kZXgsIHNlY3VyaXR5KTtcclxuICAgICAgICByZXR1cm4gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoaXNzXzEuSVNTLmRpZ2VzdHMoa2V5KSkudG9Ucnl0ZXMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgYWRkcmVzcy5cclxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlIGFnYWluc3QgdGhlIGRpZ2VzdHMuXHJcbiAgICAgKiBAcGFyYW0gZGlnZXN0cyBUaGUgZGlnZXN0cyB0byB1c2UgdG8gdmFsaWRhdGUgdGhlIGFkZHJlc3MuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBhZGRyZXNzIG1hdGNoZXMgdGhlIGRpZ2VzdHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcywgZGlnZXN0cykge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGFkZHJlc3Mgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEFkZHJlc3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKGRpZ2VzdHMsIHRyeXRlc18xLlRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGRpZ2VzdHMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHR5cGUgVHJ5dGVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09XHJcbiAgICAgICAgICAgIG5ldyBtdWx0aVNpZ0FkZHJlc3NfMS5NdWx0aVNpZ0FkZHJlc3MoKS5maW5hbGl6ZShkaWdlc3RzKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGNvc2lnbmVyIHNpZ25hdHVyZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYnVuZGxlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBidW5kbGUgVGhlIGJ1bmRsZSB0byBzaWduLlxyXG4gICAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MgdG8gbWF0Y2ggdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBzaWduIHRoZSB0cmFuc2FjdGlvbnMgd2l0aC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFkZFNpZ25hdHVyZShidW5kbGUsIGFkZHJlc3MsIGtleSkge1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShidW5kbGUsIGJ1bmRsZV8xLkJ1bmRsZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGJ1bmRsZSBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgQnVuZGxlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChidW5kbGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYnVuZGxlLnRyYW5zYWN0aW9ucyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdHlwZSBUcmFuc2FjdGlvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYWRkcmVzcyBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgQWRkcmVzc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGtleSwgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUga2V5IHNob3VsZCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBUcnl0ZXNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleVRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKGtleSkudG9BcnJheSgpO1xyXG4gICAgICAgIC8vIEdldCB0aGUgc2VjdXJpdHkgdXNlZCBmb3IgdGhlIHByaXZhdGUga2V5XHJcbiAgICAgICAgLy8gMSBzZWN1cml0eSBsZXZlbCA9IDIxODcgdHJ5dGVzXHJcbiAgICAgICAgY29uc3Qgc2VjdXJpdHkgPSBrZXlUcml0cy5sZW5ndGggLyAzIC8gMjE4NztcclxuICAgICAgICAvLyBGaXJzdCBnZXQgdGhlIHRvdGFsIG51bWJlciBvZiBhbHJlYWR5IHNpZ25lZCB0cmFuc2FjdGlvbnNcclxuICAgICAgICAvLyB1c2UgdGhhdCBmb3IgdGhlIGJ1bmRsZSBoYXNoIGNhbGN1bGF0aW9uIGFzIHdlbGwgYXMga25vd2luZ1xyXG4gICAgICAgIC8vIHdoZXJlIHRvIGFkZCB0aGUgc2lnbmF0dXJlXHJcbiAgICAgICAgbGV0IG51bVNpZ25lZFR4cyA9IDA7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc1RyeXRlcyA9IGFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA9PT0gYWRkcmVzc1RyeXRlcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LnRvVHJ5dGVzKCkudG9TdHJpbmcoKSAhPT0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkVNUFRZLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2lnbmVkLCBpbmNyZWFzZSBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtU2lnbmVkVHhzKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuc2lnblRyYW5zYWN0aW9ucyhidW5kbGUsIGksIG51bVNpZ25lZFR4cyAlIDMsIGtleVRyaXRzLCBhZGRyZXNzVHJ5dGVzLCBzZWN1cml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYXRlcyB0aGUgY3JlYXRpb24gb2YgYSBuZXcgdHJhbnNmZXIgYnkgZ2VuZXJhdGluZyBhbiBlbXB0eSBidW5kbGUgd2l0aCB0aGUgY29ycmVjdCBudW1iZXJcclxuICAgICAqIG9mIGJ1bmRsZSBlbnRyaWVzIHRvIGJlIGxhdGVyIHVzZWQgZm9yIHRoZSBzaWduaW5nIHByb2Nlc3MuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBBZGRyZXNzIHdoaWNoIGhhcyBzdWZmaWNpZW50IGJhbGFuY2UgYW5kIGlzIGNvbnRyb2xsZWQgYnkgdGhlIGNvLXNpZ25lcnMuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHlTdW0gdGhlIHN1bSBvZiB0aGUgc2VjdXJpdHkgbGV2ZWxzIGZyb20gYWxsIGNvc2lnbmVycyBjaG9zZW4gZHVyaW5nIHRoZSBwcml2YXRlIGtleSBnZW5lcmF0aW9uIChnZXRLZXkgLyBnZXREaWdlc3QpXHJcbiAgICAgKiBAcGFyYW0gYmFsYW5jZSBUaGUgYmFsYW5jZSBhdmFpbGFibGUgZm9yIHRoZSB0cmFuc2ZlciwgaWYgMCB3aWxsIGNhbGwgZ2V0QmFsYW5jZXMgdG8gbG9va3VwIGF2YWlsYWJsZS5cclxuICAgICAqIEBwYXJhbSB0cmFuc2ZlcnMgVGhlIHRyYW5zZmVycyB0byBwZXJmb3JtLlxyXG4gICAgICogQHBhcmFtIHJlbWFpbmRlckFkZHJlc3MgSWYgdGhlcmUgaXMgYSByZW1haW5kZXIgYWZ0ZXIgdGhlIHRyYW5zZmVyIHRoZW4gc2VuZCB0aGUgYW1vdW50IHRvIHRoaXMgYWRkcmVzcy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcHJlcGFyZVRyYW5zZmVyKGFkZHJlc3MsIHNlY3VyaXR5U3VtLCBiYWxhbmNlLCB0cmFuc2ZlcnMsIHJlbWFpbmRlckFkZHJlc3MpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYWRkcmVzcywgYWRkcmVzc18xLkFkZHJlc3MpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBBZGRyZXNzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHlTdW0pIHx8IHNlY3VyaXR5U3VtIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc2VjdXJpdHlTdW0gc2hvdWxkIGJlIGEgbnVtYmVyID49IDBcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihiYWxhbmNlKSB8fCBiYWxhbmNlIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYmFsYW5jZSBzaG91bGQgYmUgYSBudW1iZXIgPj0gMFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQodHJhbnNmZXJzLCB0cmFuc2Zlcl8xLlRyYW5zZmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJhbnNmZXJzIHNob3VsZCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyYW5zZmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlbWFpbmRlckFkZHJlc3MpICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHJlbWFpbmRlckFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgcmVtYWluZGVyQWRkcmVzcyBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgQWRkcmVzc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW1wdHlUcnl0ZXMgPSB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcIlwiKTtcclxuICAgICAgICAvLyBJZiBtZXNzYWdlIG9yIHRhZyBpcyBub3Qgc3VwcGxpZWQsIHByb3ZpZGUgaXRcclxuICAgICAgICB0cmFuc2ZlcnMuZm9yRWFjaCgodHJhbnNmZXIpID0+IHtcclxuICAgICAgICAgICAgdHJhbnNmZXIubWVzc2FnZSA9IHRyYW5zZmVyLm1lc3NhZ2UgPyB0cmFuc2Zlci5tZXNzYWdlIDogZW1wdHlUcnl0ZXM7XHJcbiAgICAgICAgICAgIHRyYW5zZmVyLnRhZyA9IHRyYW5zZmVyLnRhZyB8fCB0YWdfMS5UYWcuRU1QVFk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcHJlcGFyZWQgPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIucHJlcGFyZUJ1bmRsZSh0aGlzLl90aW1lU2VydmljZSwgdHJhbnNmZXJzKTtcclxuICAgICAgICBpZiAocHJlcGFyZWQudG90YWxWYWx1ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdG90YWwgdHJhbnNmZXIgdmFsdWUgaXMgMCwgdGhlIHRyYW5zZmVyIGRvZXMgbm90IHJlcXVpcmUgYSBzaWduYXR1cmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdG90YWxCYWxhbmNlID0gYmFsYW5jZTtcclxuICAgICAgICAgICAgaWYgKHRvdGFsQmFsYW5jZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC5nZXRCYWxhbmNlcyhyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIHRvdGFsQmFsYW5jZSA9IHBhcnNlSW50KHJlc3BvbnNlLmJhbGFuY2VzWzBdLCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZXBhcmVkLnRvdGFsVmFsdWUgPiB0b3RhbEJhbGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIk5vdCBlbm91Z2ggYmFsYW5jZSB0byBzYXRpc2Z5IHRoZSB2YWx1ZVwiLCB7IHRvdGFsVmFsdWU6IHByZXBhcmVkLnRvdGFsVmFsdWUsIHRvdGFsQmFsYW5jZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKHRoaXMuX3RpbWVTZXJ2aWNlLm1zU2luY2VFcG9jaCgpIC8gMTAwMCk7XHJcbiAgICAgICAgICAgIC8vIEFkZCBpbnB1dCBhcyBidW5kbGUgZW50cnlcclxuICAgICAgICAgICAgLy8gT25seSBhIHNpbmdsZSBlbnRyeSwgc2lnbmF0dXJlcyB3aWxsIGJlIGFkZGVkIGxhdGVyXHJcbiAgICAgICAgICAgIHByZXBhcmVkLmJ1bmRsZS5hZGRUcmFuc2FjdGlvbnMoc2VjdXJpdHlTdW0sIGFkZHJlc3MsIC10b3RhbEJhbGFuY2UsIHByZXBhcmVkLmxhc3RUYWcsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluZGVyIHZhbHVlXHJcbiAgICAgICAgICAgIC8vIEFkZCBleHRyYSBvdXRwdXQgdG8gc2VuZCByZW1haW5pbmcgZnVuZHMgdG9cclxuICAgICAgICAgICAgaWYgKHRvdGFsQmFsYW5jZSA+IHByZXBhcmVkLnRvdGFsVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZW1haW5kZXJBZGRyZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRyYW5zZmVyIGhhcyByZW1haW5kZXIgYnV0IG5vIHJlbWFpbmRlciBhZGRyZXNzIHdhcyBwcm92aWRlZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXBhcmVkLmJ1bmRsZS5hZGRUcmFuc2FjdGlvbnMoMSwgcmVtYWluZGVyQWRkcmVzcywgdG90YWxCYWxhbmNlIC0gcHJlcGFyZWQudG90YWxWYWx1ZSwgcHJlcGFyZWQubGFzdFRhZywgdGltZXN0YW1wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuZmluYWxpemVCdW5kbGUocHJlcGFyZWQuYnVuZGxlKTtcclxuICAgICAgICAgICAgcHJlcGFyZWQuYnVuZGxlLmFkZFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMocHJlcGFyZWQuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcmVwYXJlZC5idW5kbGU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NdWx0aVNpZ0NsaWVudCA9IE11bHRpU2lnQ2xpZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liWFZzZEdsVGFXZERiR2xsYm5RdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YlhWc2RHbFRhV2N2YlhWc2RHbFRhV2REYkdsbGJuUXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRCUVVWQkxEQkZRVUYxUlR0QlFVTjJSU3cwUlVGQmVVVTdRVUZEZWtVc05FVkJRWGxGTzBGQlJYcEZMREpGUVVGM1JUdEJRVU40UlN4NVJFRkJjMFE3UVVGRGRFUXNLMFJCUVRSRU8wRkJSVFZFTERaRVFVRXdSRHRCUVVNeFJDeDVSRUZCYzBRN1FVRkRkRVFzYVVkQlFUaEdPMEZCUXpsR0xIVkVRVUZ2UkR0QlFVTndSQ3gxUlVGQmIwVTdRVUZEY0VVc2FVVkJRVGhFTzBGQlF6bEVMREpFUVVGM1JEdEJRVU40UkN3MlJFRkJNRVE3UVVGRE1VUXNNRVJCUVhWRU8wRkJRM1pFTERCRVFVRjFSRHRCUVVOMlJDeDFSRUZCYjBRN1FVRkZjRVE3T3p0SFFVZEhPMEZCUTBnN1NVRk5TVHM3T3p0UFFVbEhPMGxCUTBnc1dVRkJXU3hUUVVGeFFpeEZRVUZGTEdOQlFUUkNMRWxCUVVrc2VVSkJRVmNzUlVGQlJUdFJRVU0xUlN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hIUVVGSExGTkJRVk1zUTBGQlF6dFJRVU0xUWl4SlFVRkpMRU5CUVVNc1dVRkJXU3hIUVVGSExGZEJRVmNzUTBGQlF6dEpRVU53UXl4RFFVRkRPMGxCUlVRN096czdPenRQUVUxSE8wbEJRMGtzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRlZMRVZCUVVVc1MwRkJZU3hGUVVGRkxGRkJRWGxDTzFGQlEzSkZMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRVZCUVVVc1YwRkJTU3hEUVVGRExFVkJRVVU3V1VGRGJFTXNUVUZCVFN4SlFVRkpMRFpDUVVGaExFTkJRVU1zTWtOQlFUSkRMRU5CUVVNc1EwRkJRenRUUVVONFJUdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4TFFVRkxMRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRemRETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHMURRVUZ0UXl4RFFVRkRMRU5CUVVNN1UwRkRhRVU3VVVGRFJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NVVUZCVVN4SFFVRkhMRU5CUVVNc1NVRkJTU3hSUVVGUkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlEyNUZMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhORFFVRnpReXhGUVVGRkxFVkJRVVVzVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTnFSanRSUVVWRUxFOUJRVThzWVVGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4VFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUlVGQlJTeExRVUZMTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dEpRVU4wUlN4RFFVRkRPMGxCUlVRN096czdPenRQUVUxSE8wbEJRMGtzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRlZMRVZCUVVVc1MwRkJZU3hGUVVGRkxGRkJRWGxDTzFGQlEzaEZMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRVZCUVVVc1YwRkJTU3hEUVVGRExFVkJRVVU3V1VGRGJFTXNUVUZCVFN4SlFVRkpMRFpDUVVGaExFTkJRVU1zTWtOQlFUSkRMRU5CUVVNc1EwRkJRenRUUVVONFJUdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4TFFVRkxMRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRemRETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHMURRVUZ0UXl4RFFVRkRMRU5CUVVNN1UwRkRhRVU3VVVGRFJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NVVUZCVVN4SFFVRkhMRU5CUVVNc1NVRkJTU3hSUVVGUkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlEyNUZMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhORFFVRnpReXhGUVVGRkxFVkJRVVVzVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTnFSanRSUVVWRUxFMUJRVTBzUjBGQlJ5eEhRVUZITEZOQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFdEJRVXNzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0UlFVVXpReXhQUVVGUExHRkJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNVMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRPMGxCUTNoRUxFTkJRVU03U1VGRlJEczdPenM3VDBGTFJ6dEpRVU5KTEUxQlFVMHNRMEZCUXl4bFFVRmxMRU5CUVVNc1QwRkJaMElzUlVGQlJTeFBRVUZwUWp0UlFVTTNSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhGUVVGRkxHbENRVUZQTEVOQlFVTXNSVUZCUlR0WlFVTjRReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4cFJFRkJhVVFzUTBGQlF5eERRVUZETzFOQlF6bEZPMUZCUTBRc1NVRkJTU3hEUVVGRExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1JVRkJSU3hsUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU4yUXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5d3JRMEZCSzBNc1EwRkJReXhEUVVGRE8xTkJRelZGTzFGQlJVUXNUMEZCVHl4UFFVRlBMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTzFsQlEzQkNMRWxCUVVrc2FVTkJRV1VzUlVGQlJTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXp0SlFVTnNSaXhEUVVGRE8wbEJSVVE3T3pzN08wOUJTMGM3U1VGRFNTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVdNc1JVRkJSU3hQUVVGblFpeEZRVUZGTEVkQlFWYzdVVUZEY0VVc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSU3hsUVVGTkxFTkJRVU1zUlVGQlJUdFpRVU4wUXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5d3JRMEZCSzBNc1EwRkJReXhEUVVGRE8xTkJRelZGTzFGQlJVUXNTVUZCU1N4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4WlFVRlpMRVZCUVVVc2VVSkJRVmNzUTBGQlF5eEZRVUZGTzFsQlEzaEVMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEdkRlFVRm5SU3hEUVVGRExFTkJRVU03VTBGRE4wWTdVVUZGUkN4SlFVRkpMRU5CUVVNc01rSkJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMR2xDUVVGUExFTkJRVU1zUlVGQlJUdFpRVU40UXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5eHBSRUZCYVVRc1EwRkJReXhEUVVGRE8xTkJRemxGTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NSVUZCUlN4bFFVRk5MRU5CUVVNc1JVRkJSVHRaUVVOdVF5eE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXcwUTBGQk5FTXNRMEZCUXl4RFFVRkRPMU5CUTNwRk8xRkJSVVFzVFVGQlRTeFJRVUZSTEVkQlFVY3NZVUZCU3l4RFFVRkRMRlZCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXp0UlFVVnFSQ3cwUTBGQk5FTTdVVUZETlVNc2FVTkJRV2xETzFGQlEycERMRTFCUVUwc1VVRkJVU3hIUVVGSExGRkJRVkVzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVVMVF5dzBSRUZCTkVRN1VVRkROVVFzT0VSQlFUaEVPMUZCUXpsRUxEWkNRVUUyUWp0UlFVTTNRaXhKUVVGSkxGbEJRVmtzUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZGY2tJc1RVRkJUU3hoUVVGaExFZEJRVWNzVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xRkJSWEJFTEV0QlFVc3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUlVGQlJUdFpRVU5xUkN4SlFVRkpMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeExRVUZMTEdGQlFXRXNSVUZCUlR0blFrRkRlRVVzU1VGQlNTeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExIZENRVUYzUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeExRVUZMTEcxRVFVRjNRaXhEUVVGRExFdEJRVXNzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1JVRkJSVHR2UWtGRGFFa3NjVVJCUVhGRU8yOUNRVU55UkN4WlFVRlpMRVZCUVVVc1EwRkJRenRwUWtGRGJFSTdjVUpCUVUwN2IwSkJRMGdzTWtKQlFWa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRmxCUVZrc1IwRkJSeXhEUVVGRExFVkJRVVVzVVVGQlVTeEZRVUZGTEdGQlFXRXNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenR2UWtGRE9VWXNUVUZCVFR0cFFrRkRWRHRoUVVOS08xTkJRMG83U1VGRFRDeERRVUZETzBsQlJVUTdPenM3T3pzN08wOUJVVWM3U1VGRFNTeExRVUZMTEVOQlFVTXNaVUZCWlN4RFFVRkRMRTlCUVdkQ0xFVkJRVVVzVjBGQmJVSXNSVUZCUlN4UFFVRmxMRVZCUVVVc1UwRkJjVUlzUlVGQlJTeG5Ra0ZCTUVJN1VVRkRiRWtzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeHBRa0ZCVHl4RFFVRkRMRVZCUVVVN1dVRkRlRU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2FVUkJRV2xFTEVOQlFVTXNRMEZCUXp0VFFVTTVSVHRSUVVORUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhYUVVGWExFTkJRVU1zU1VGQlNTeFhRVUZYTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUTNwRUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMSGxEUVVGNVF5eERRVUZETEVOQlFVTTdVMEZEZEVVN1VVRkRSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzVDBGQlR5eEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTnFSQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4eFEwRkJjVU1zUTBGQlF5eERRVUZETzFOQlEyeEZPMUZCUTBRc1NVRkJTU3hEUVVGRExIbENRVUZYTEVOQlFVTXNUMEZCVHl4RFFVRkRMRk5CUVZNc1JVRkJSU3h0UWtGQlVTeERRVUZETEVWQlFVVTdXVUZETTBNc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNiVVJCUVcxRUxFTkJRVU1zUTBGQlF6dFRRVU5vUmp0UlFVTkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4blFrRkJaMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zWjBKQlFXZENMRVZCUVVVc2FVSkJRVThzUTBGQlF5eEZRVUZGTzFsQlF6VkdMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETERCRVFVRXdSQ3hEUVVGRExFTkJRVU03VTBGRGRrWTdVVUZGUkN4TlFVRk5MRmRCUVZjc1IwRkJSeXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUlRGRExHZEVRVUZuUkR0UlFVTm9SQ3hUUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNVVUZCVVN4RlFVRkZMRVZCUVVVN1dVRkRNMElzVVVGQlVTeERRVUZETEU5QlFVOHNSMEZCUnl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFTkJRVU03V1VGRGNrVXNVVUZCVVN4RFFVRkRMRWRCUVVjc1IwRkJSeXhSUVVGUkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEZOQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkROME1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGU0N4TlFVRk5MRkZCUVZFc1IwRkJSeXd5UWtGQldTeERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFGQlJURkZMRWxCUVVrc1VVRkJVU3hEUVVGRExGVkJRVlVzUzBGQlN5eERRVUZETEVWQlFVVTdXVUZETTBJc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNNRVZCUVRCRkxFTkJRVU1zUTBGQlF6dFRRVU4yUnp0aFFVRk5PMWxCUTBnc1NVRkJTU3haUVVGWkxFZEJRVWNzVDBGQlR5eERRVUZETzFsQlF6TkNMRWxCUVVrc1dVRkJXU3hMUVVGTExFTkJRVU1zUlVGQlJUdG5Ra0ZEY0VJc1RVRkJUU3hQUVVGUExFZEJRWGRDTzI5Q1FVTnFReXhUUVVGVExFVkJRVVVzUTBGQlJTeFBRVUZQTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVVU3YjBKQlF6VkRMRk5CUVZNc1JVRkJSU3hIUVVGSE8ybENRVU5xUWl4RFFVRkRPMmRDUVVWR0xFMUJRVTBzVVVGQlVTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhYUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdaMEpCUlRWRUxGbEJRVmtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNVVUZCVVN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0aFFVTnlSRHRaUVVWRUxFbEJRVWtzVVVGQlVTeERRVUZETEZWQlFWVXNSMEZCUnl4WlFVRlpMRVZCUVVVN1owSkJRM0JETEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExIbERRVUY1UXl4RlFVRkZMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGRkJRVkVzUTBGQlF5eFZRVUZWTEVWQlFVVXNXVUZCV1N4RlFVRkZMRU5CUVVNc1EwRkJRenRoUVVONlNEdFpRVVZFTEUxQlFVMHNVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4WlFVRlpMRVZCUVVVc1IwRkJSeXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVVYwUlN3MFFrRkJORUk3V1VGRE5VSXNjMFJCUVhORU8xbEJRM1JFTEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGRExGZEJRVmNzUlVGQlJTeFBRVUZQTEVWQlFVVXNRMEZCUXl4WlFVRlpMRVZCUVVVc1VVRkJVU3hEUVVGRExFOUJRVThzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0WlFVVnNSeXhuUTBGQlowTTdXVUZEYUVNc09FTkJRVGhETzFsQlF6bERMRWxCUVVrc1dVRkJXU3hIUVVGSExGRkJRVkVzUTBGQlF5eFZRVUZWTEVWQlFVVTdaMEpCUTNCRExFbEJRVWtzTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNSVUZCUlR0dlFrRkRlRU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc09FUkJRVGhFTEVOQlFVTXNRMEZCUXp0cFFrRkRNMFk3WjBKQlJVUXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eEZRVUZGTEdkQ1FVRm5RaXhGUVVGRkxGbEJRVmtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNWVUZCVlN4RlFVRkZMRkZCUVZFc1EwRkJReXhQUVVGUExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTTdZVUZEZWtnN1dVRkZSQ3d5UWtGQldTeERRVUZETEdOQlFXTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03V1VGRE4wTXNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXcwUWtGQk5FSXNRMEZCUXl4UlFVRlJMRU5CUVVNc2VVSkJRWGxDTEVOQlFVTXNRMEZCUXp0VFFVTndSanRSUVVWRUxFOUJRVThzVVVGQlVTeERRVUZETEUxQlFVMHNRMEZCUXp0SlFVTXpRaXhEUVVGRE8wTkJSVW83UVVFM1RVUXNkME5CTmsxREluMD0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHNwb25nZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5XCIpO1xyXG5jb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFwiKTtcclxuY29uc3QgdHJpdHNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyaXRzXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuLyoqXHJcbiAqIEhhc2hlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgdXNpbmcgQ3VybC5cclxuICovXHJcbmNsYXNzIEhtYWNDdXJsIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBIbWFjQ3VybC5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBzZWVkIHdpdGguXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xyXG4gICAgICAgIHRoaXMuX2tleVRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKGtleSkudG9BcnJheSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYnVuZGxlIHRvIHRoZSBITUFDLlxyXG4gICAgICovXHJcbiAgICBhZGRITUFDKGJ1bmRsZSkge1xyXG4gICAgICAgIGNvbnN0IGN1cmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcImN1cmxcIiwgSG1hY0N1cmwuSE1BQ19ST1VORFMpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hMZW5ndGggPSBjdXJsLmdldENvbnN0YW50KFwiSEFTSF9MRU5HVEhcIik7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5VHJpdHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChidW5kbGUudHJhbnNhY3Rpb25zW2ldLnZhbHVlLnRvTnVtYmVyKCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidW5kbGVIYXNoVHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5idW5kbGUudG9Ucnl0ZXMoKSkudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaG1hYyA9IG5ldyBJbnQ4QXJyYXkoaGFzaExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJsLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIGN1cmwuYWJzb3JiKGtleSwgMCwga2V5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjdXJsLmFic29yYihidW5kbGVIYXNoVHJpdHMsIDAsIGJ1bmRsZUhhc2hUcml0cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY3VybC5zcXVlZXplKGhtYWMsIDAsIGhtYWMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhtYWNUcnl0ZXMgPSB0cml0c18xLlRyaXRzLmZyb21BcnJheShobWFjKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQudG9Ucnl0ZXMoKS50b1N0cmluZygpLnN1YnN0cmluZyg4MSwgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCk7XHJcbiAgICAgICAgICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zW2ldLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoaG1hY1RyeXRlcyArIHJlc3QpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiBAaW50ZXJuYWwgKi9cclxuSG1hY0N1cmwuSE1BQ19ST1VORFMgPSAyNztcclxuZXhwb3J0cy5IbWFjQ3VybCA9IEhtYWNDdXJsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhRzFoWTBOMWNtd3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdmMybG5iaTlvYldGalEzVnliQzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBGQlFVRXNhMFpCUVN0Rk8wRkJSUzlGTEdsSFFVRTRSanRCUVVNNVJpd3lSRUZCZDBRN1FVRkRlRVFzTmtSQlFUQkVPMEZCUlRGRU96dEhRVVZITzBGQlEwZzdTVUZOU1RzN08wOUJSMGM3U1VGRFNDeFpRVUZaTEVkQlFWYzdVVUZEYmtJc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eGhRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETzBsQlEzSkVMRU5CUVVNN1NVRkZSRHM3VDBGRlJ6dEpRVU5KTEU5QlFVOHNRMEZCUXl4TlFVRmpPMUZCUTNwQ0xFMUJRVTBzU1VGQlNTeEhRVUZITERaQ1FVRmhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNSVUZCUlN4UlFVRlJMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU03VVVGRE0wVXNUVUZCVFN4VlFVRlZMRWRCUVVjc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXp0UlFVTnVSQ3hOUVVGTkxFZEJRVWNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUXpOQ0xFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRaUVVOcVJDeEpRVUZKTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4SFFVRkhMRU5CUVVNc1JVRkJSVHRuUWtGRE4wTXNUVUZCVFN4bFFVRmxMRWRCUVVjc1lVRkJTeXhEUVVGRExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8yZENRVU0zUml4TlFVRk5MRWxCUVVrc1IwRkJSeXhKUVVGSkxGTkJRVk1zUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXp0blFrRkRka01zU1VGQlNTeERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMmRDUVVOc1FpeEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExFVkJRVVVzUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVOb1F5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMR1ZCUVdVc1JVRkJSU3hEUVVGRExFVkJRVVVzWlVGQlpTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVONFJDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRExFVkJRVVVzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVOdVF5eE5RVUZOTEZWQlFWVXNSMEZCUnl4aFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8yZENRVU12UkN4TlFVRk5MRWxCUVVrc1IwRkJSeXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMSGRDUVVGM1FpeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGTkJRVk1zUTBGQlF5eEZRVUZGTEVWQlFVVXNiVVJCUVhkQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdaMEpCUTJ4SkxFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc2QwSkJRWGRDTzI5Q1FVTXpReXh0UkVGQmQwSXNRMEZCUXl4VlFVRlZMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eFZRVUZWTEVkQlFVY3NTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRoUVVOcVJqdFRRVU5LTzBsQlEwd3NRMEZCUXpzN1FVRnNRMFFzWlVGQlpUdEJRVU5UTEc5Q1FVRlhMRWRCUVZjc1JVRkJSU3hEUVVGRE8wRkJSbkpFTERSQ1FXOURReUo5IiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBhcnJheUhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXJcIik7XHJcbmNvbnN0IG51bWJlckhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyXCIpO1xyXG5jb25zdCBvYmplY3RIZWxwZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlclwiKTtcclxuY29uc3QgY3J5cHRvRXJyb3JfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yXCIpO1xyXG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9oYXNoXCIpO1xyXG5jb25zdCB0cnl0ZXNfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlc1wiKTtcclxuY29uc3QgYnVzaW5lc3NFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9yL2J1c2luZXNzRXJyb3JcIik7XHJcbi8qKlxyXG4gKiBQcm9vZk9mV29yayBpbXBsZW1lbnRhdGlvbiB1c2luZyBBUEkuXHJcbiAqL1xyXG5jbGFzcyBQcm9vZk9mV29ya0FwaSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBQcm9vZk9mV29yay5cclxuICAgICAqIEBwYXJhbSBhcGlDbGllbnQgVGhlIEFQSSBjbGllbnQgdG8gc2VuZCB0aGUgcmVxdWVzdCB0aHJvdWdoLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoYXBpQ2xpZW50KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYXBpQ2xpZW50IG11c3Qgbm90IGJlIGVtcHR5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hcGlDbGllbnQgPSBhcGlDbGllbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG93IHRoZSBwcm9vZiBvZiB3b3JrIHRvIHBlcmZvcm0gYW55IGluaXRpYWxpemF0aW9uLlxyXG4gICAgICogV2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtIGEgcHJvb2Ygb2Ygd29yayBvbiB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB0cnVua1RyYW5zYWN0aW9uIFRoZSB0cnVua1RyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHBvdy5cclxuICAgICAqIEBwYXJhbSBicmFuY2hUcmFuc2FjdGlvbiBUaGUgYnJhbmNoVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxyXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHBvdyBvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcHJvZHVjZWQgYnkgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHBvdyh0cnVua1RyYW5zYWN0aW9uLCBicmFuY2hUcmFuc2FjdGlvbiwgdHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJ1bmtUcmFuc2FjdGlvbiwgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFwiVGhlIHRydW5rVHJhbnNhY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYnJhbmNoVHJhbnNhY3Rpb24sIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSBicmFuY2hUcmFuc2FjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcIlRoZSB0cnl0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgbWluV2VpZ2h0TWFnbml0dWRlIG11c3QgYmUgPiAwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhdHRhY2hUb1RhbmdsZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIHRydW5rVHJhbnNhY3Rpb246IHRydW5rVHJhbnNhY3Rpb24udG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgYnJhbmNoVHJhbnNhY3Rpb246IGJyYW5jaFRyYW5zYWN0aW9uLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIG1pbldlaWdodE1hZ25pdHVkZTogbWluV2VpZ2h0TWFnbml0dWRlLFxyXG4gICAgICAgICAgICB0cnl0ZXM6IHRyeXRlcy5tYXAodCA9PiB0LnRvU3RyaW5nKCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBhdHRhY2hUb1RhbmdsZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmF0dGFjaFRvVGFuZ2xlKGF0dGFjaFRvVGFuZ2xlUmVxdWVzdCk7XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGF0dGFjaFRvVGFuZ2xlUmVzcG9uc2UpIHx8IGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNFbXB0eShhdHRhY2hUb1RhbmdsZVJlc3BvbnNlLnRyeXRlcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXCJUaGUgYXR0YWNoVG9UYW5nbGVSZXF1ZXN0IGRpZCBub3QgcmV0dXJuIGFueSB0cnl0ZXNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYXR0YWNoVG9UYW5nbGVSZXNwb25zZS50cnl0ZXMubWFwKHJldHVyblRyeXRlcyA9PiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhyZXR1cm5Ucnl0ZXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Qcm9vZk9mV29ya0FwaSA9IFByb29mT2ZXb3JrQXBpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljSEp2YjJaUFpsZHZjbXRCY0drdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12ZEhKaGJuTmhZM1JwYjI1ekwzQnliMjltVDJaWGIzSnJRWEJwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRkZRU3d3UlVGQmRVVTdRVUZEZGtVc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVU42UlN3d1JVRkJkVVU3UVVGRmRrVXNlVVJCUVhORU8wRkJRM1JFTERaRVFVRXdSRHRCUVVNeFJDd3dSRUZCZFVRN1FVRkZka1E3TzBkQlJVYzdRVUZEU0R0SlFVbEpPenM3VDBGSFJ6dEpRVU5JTEZsQlFWa3NVMEZCY1VJN1VVRkROMElzU1VGQlNTd3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhUUVVGVExFTkJRVU1zUlVGQlJUdFpRVU5xUXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5eHBRMEZCYVVNc1EwRkJReXhEUVVGRE8xTkJRemxFTzFGQlEwUXNTVUZCU1N4RFFVRkRMRlZCUVZVc1IwRkJSeXhUUVVGVExFTkJRVU03U1VGRGFFTXNRMEZCUXp0SlFVVkVPenM3VDBGSFJ6dEpRVU5KTEV0QlFVc3NRMEZCUXl4VlFVRlZPMUZCUTI1Q0xFOUJRVThzVDBGQlR5eERRVUZETEU5QlFVOHNSVUZCUlN4RFFVRkRPMGxCUXpkQ0xFTkJRVU03U1VGRlJEczdPenM3T3p0UFFVOUhPMGxCUTBrc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eG5Ra0ZCYzBJc1JVRkJSU3hwUWtGQmRVSXNSVUZCUlN4TlFVRm5RaXhGUVVGRkxHdENRVUV3UWp0UlFVTXhSeXhKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1owSkJRV2RDTEVWQlFVVXNWMEZCU1N4RFFVRkRMRVZCUVVVN1dVRkRPVU1zVFVGQlRTeEpRVUZKTEhsQ1FVRlhMRU5CUVVNc2NVUkJRWEZFTEVOQlFVTXNRMEZCUXp0VFFVTm9SanRSUVVORUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhwUWtGQmFVSXNSVUZCUlN4WFFVRkpMRU5CUVVNc1JVRkJSVHRaUVVNdlF5eE5RVUZOTEVsQlFVa3NlVUpCUVZjc1EwRkJReXh6UkVGQmMwUXNRMEZCUXl4RFFVRkRPMU5CUTJwR08xRkJRMFFzU1VGQlNTeERRVUZETEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUlVGQlJTeGxRVUZOTEVOQlFVTXNSVUZCUlR0WlFVTjBReXhOUVVGTkxFbEJRVWtzZVVKQlFWY3NRMEZCUXl3MFEwRkJORU1zUTBGQlF5eERRVUZETzFOQlEzWkZPMUZCUTBRc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNVMEZCVXl4RFFVRkRMR3RDUVVGclFpeERRVUZETEVsQlFVa3NhMEpCUVd0Q0xFbEJRVWtzUTBGQlF5eEZRVUZGTzFsQlEzaEZMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEc5RFFVRnZReXhEUVVGRExFTkJRVU03VTBGREwwUTdVVUZGUkN4TlFVRk5MSEZDUVVGeFFpeEhRVUV5UWp0WlFVTnNSQ3huUWtGQlowSXNSVUZCUlN4blFrRkJaMElzUTBGQlF5eFJRVUZSTEVWQlFVVTdXVUZETjBNc2FVSkJRV2xDTEVWQlFVVXNhVUpCUVdsQ0xFTkJRVU1zVVVGQlVTeEZRVUZGTzFsQlF5OURMR3RDUVVGclFpeEZRVUZGTEd0Q1FVRnJRanRaUVVOMFF5eE5RVUZOTEVWQlFVVXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRUUVVONFF5eERRVUZETzFGQlJVWXNUVUZCVFN4elFrRkJjMElzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1kwRkJZeXhEUVVGRExIRkNRVUZ4UWl4RFFVRkRMRU5CUVVNN1VVRkZNMFlzU1VGQlNTd3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXh6UWtGQmMwSXNRMEZCUXl4SlFVRkpMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEhOQ1FVRnpRaXhEUVVGRExFMUJRVTBzUTBGQlF5eEZRVUZGTzFsQlEzQkhMRTFCUVUwc1NVRkJTU3g1UWtGQlZ5eERRVUZETEhGRVFVRnhSQ3hEUVVGRExFTkJRVU03VTBGRGFFWTdZVUZCVFR0WlFVTklMRTlCUVU4c2MwSkJRWE5DTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhaUVVGWkxFTkJRVU1zUlVGQlJTeERRVUZETEdWQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF6dFRRVU0zUmp0SlFVTk1MRU5CUVVNN1EwRkRTanRCUVRWRVJDeDNRMEUwUkVNaWZRPT0iLCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IGFycmF5SGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlclwiKTtcclxuY29uc3QgbnVtYmVySGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXJcIik7XHJcbmNvbnN0IG9iamVjdEhlbHBlcl8xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyXCIpO1xyXG5jb25zdCBudWxsTG9nZ2VyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3QvbG9nZ2Vycy9udWxsTG9nZ2VyXCIpO1xyXG5jb25zdCBiYWNrZ3JvdW5kVGFza1NlcnZpY2VfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2NvcmUvZGlzdC9zZXJ2aWNlcy9iYWNrZ3JvdW5kVGFza1NlcnZpY2VcIik7XHJcbmNvbnN0IHRpbWVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jb3JlL2Rpc3Qvc2VydmljZXMvdGltZVNlcnZpY2VcIik7XHJcbmNvbnN0IGlzc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvaGFzaC9pc3NcIik7XHJcbmNvbnN0IHRyYW5zYWN0aW9uSGVscGVyXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9jcnlwdG8vZGlzdC9oZWxwZXJzL3RyYW5zYWN0aW9uSGVscGVyXCIpO1xyXG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzXCIpO1xyXG5jb25zdCBhZGRyZXNzU2VjdXJpdHlfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2FkZHJlc3NTZWN1cml0eVwiKTtcclxuY29uc3QgYnVuZGxlXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9idW5kbGVcIik7XHJcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2hhc2hcIik7XHJcbmNvbnN0IGlucHV0XzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9pbnB1dFwiKTtcclxuY29uc3QgdGFnXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90YWdcIik7XHJcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cmFuc2FjdGlvblwiKTtcclxuY29uc3QgdHJhbnNmZXJfMSA9IHJlcXVpcmUoXCJAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyYW5zZmVyXCIpO1xyXG5jb25zdCB0cml0c18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHNcIik7XHJcbmNvbnN0IHRyeXRlc18xID0gcmVxdWlyZShcIkBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzXCIpO1xyXG5jb25zdCBidXNpbmVzc0Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3IvYnVzaW5lc3NFcnJvclwiKTtcclxuY29uc3QgYWRkcmVzc0hlbHBlcl8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvYWRkcmVzc0hlbHBlclwiKTtcclxuY29uc3QgYnVuZGxlSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9idW5kbGVIZWxwZXJcIik7XHJcbmNvbnN0IHByb29mT2ZXb3JrQXBpXzEgPSByZXF1aXJlKFwiLi9wcm9vZk9mV29ya0FwaVwiKTtcclxuLyoqXHJcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIElUcmFuc2FjdGlvbkNsaWVudC5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uQ2xpZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBUcmFuc2FjdGlvbkNsaWVudC5cclxuICAgICAqIEBwYXJhbSBhcGlDbGllbnQgQW4gQVBJIENsaWVudCB0byBjb21tdW5pY2F0ZSB0aHJvdWdoLlxyXG4gICAgICogQHBhcmFtIHByb29mT2ZXb3JrIFByb29mIG9mIHdvcmsgbW9kdWxlIHRvIHVzZSwgaWYgdW5kZWZpbmVkIHdpbGwgdXNlIHJlbW90ZS5cclxuICAgICAqIEBwYXJhbSB0aW1lU2VydmljZSBBIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIHRoZSB0aW1lLlxyXG4gICAgICogQHBhcmFtIGJhY2tncm91bmRUYXNrU2VydmljZSBBIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIGJhY2tncm91bmQgdGFza3MuXHJcbiAgICAgKiBAcGFyYW0gbG9nZ2VyIExvZ2dlciB0byBzZW5kIHRyYW5zYWN0aW9uIGluZm8gdG8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgcHJvb2ZPZldvcmssIHRpbWVTZXJ2aWNlLCBiYWNrZ3JvdW5kVGFza1NlcnZpY2UsIGxvZ2dlcikge1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShhcGlDbGllbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBhcGlDbGllbnQgbXVzdCBub3QgYmUgZW1wdHlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FwaUNsaWVudCA9IGFwaUNsaWVudDtcclxuICAgICAgICB0aGlzLl9wcm9vZk9mV29yayA9IHByb29mT2ZXb3JrIHx8IG5ldyBwcm9vZk9mV29ya0FwaV8xLlByb29mT2ZXb3JrQXBpKGFwaUNsaWVudCk7XHJcbiAgICAgICAgdGhpcy5fdGltZVNlcnZpY2UgPSB0aW1lU2VydmljZSB8fCBuZXcgdGltZVNlcnZpY2VfMS5UaW1lU2VydmljZSgpO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRUYXNrU2VydmljZSA9IGJhY2tncm91bmRUYXNrU2VydmljZSB8fCBuZXcgYmFja2dyb3VuZFRhc2tTZXJ2aWNlXzEuQmFja2dyb3VuZFRhc2tTZXJ2aWNlKCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyIHx8IG5ldyBudWxsTG9nZ2VyXzEuTnVsbExvZ2dlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9uIGluIHByb2dyZXNzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBhIGxpc3Qgb2YgaGFzaGVzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25zSW5Qcm9ncmVzcygpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc0luUHJvZ3Jlc3NcIik7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0VGlwcygpO1xyXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS5oYXNoZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3BvbnNlLmhhc2hlcy5tYXAoaGFzaCA9PiBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKGhhc2gpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0VHJhbnNhY3Rpb25zSW5Qcm9ncmVzc1wiLCByZXNwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc0luUHJvZ3Jlc3NcIiwgW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSB0cmFuc2FjdGlvbnMgd2hpY2ggbWF0Y2ggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgcmV0dXJuLiBBbGwgaW5wdXQgdmFsdWVzIGFyZSBsaXN0cyxcclxuICAgICAqIGZvciB3aGljaCBhIGxpc3Qgb2YgcmV0dXJuIHZhbHVlcyAodHJhbnNhY3Rpb24gaGFzaGVzKSwgaW4gdGhlIHNhbWUgb3JkZXIsIGlzIHJldHVybmVkIGZvciBhbGxcclxuICAgICAqIGluZGl2aWR1YWwgZWxlbWVudHMuIFVzaW5nIG11bHRpcGxlIG9mIHRoZXNlIGlucHV0IGZpZWxkcyByZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBidW5kbGVzIEJ1bmRsZXMgdG8gbG9va3VwIHRyYW5zYWN0aW9uIGhhc2hlcyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIEFkZHJlc3NlcyB0byBsb29rdXAgdHJhbnNhY3Rpb24gaGFzaGVzIGZvci5cclxuICAgICAqIEBwYXJhbSB0YWdzIFRhZ3MgdG8gbG9va3VwIHRyYW5zYWN0aW9uIGhhc2hlcyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYXBwcm92ZWVzIEFwcHJvdmVlcyB0byBsb29rdXAgdHJhbnNhY3Rpb24gaGFzaGVzIGZvci5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBhIGxpc3Qgb2YgaGFzaGVzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmluZFRyYW5zYWN0aW9ucyhidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6ZmluZFRyYW5zYWN0aW9uc1wiLCBidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcyk7XHJcbiAgICAgICAgY29uc3QgaGFzQnVuZGxlID0gYnVuZGxlcyAhPT0gdW5kZWZpbmVkICYmIGJ1bmRsZXMgIT09IG51bGwgJiYgYnVuZGxlcy5sZW5ndGggPiAwO1xyXG4gICAgICAgIGNvbnN0IGhhc0FkZHJlc3NlcyA9IGFkZHJlc3NlcyAhPT0gdW5kZWZpbmVkICYmIGFkZHJlc3NlcyAhPT0gbnVsbCAmJiBhZGRyZXNzZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBjb25zdCBoYXNUYWdzID0gdGFncyAhPT0gdW5kZWZpbmVkICYmIHRhZ3MgIT09IG51bGwgJiYgdGFncy5sZW5ndGggPiAwO1xyXG4gICAgICAgIGNvbnN0IGhhc0FwcHJvdmVlcyA9IGFwcHJvdmVlcyAhPT0gdW5kZWZpbmVkICYmIGFwcHJvdmVlcyAhPT0gbnVsbCAmJiBhcHByb3ZlZXMubGVuZ3RoID4gMDtcclxuICAgICAgICBpZiAoaGFzQnVuZGxlICYmICFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYnVuZGxlcywgaGFzaF8xLkhhc2gpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBidW5kbGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzQWRkcmVzc2VzICYmICFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYWRkcmVzc2VzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGFkZHJlc3NlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgQWRkcmVzc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc1RhZ3MgJiYgIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh0YWdzLCB0YWdfMS5UYWcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSB0YWdzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBUYWdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNBcHByb3ZlZXMgJiYgIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChhcHByb3ZlZXMsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYXBwcm92ZWVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWhhc0J1bmRsZSAmJiAhaGFzQWRkcmVzc2VzICYmICFoYXNUYWdzICYmICFoYXNBcHByb3ZlZXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiWW91IG11c3QgcHJvdmlkZSBidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3Mgb3IgYXBwcm92ZWVzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBidW5kbGVzOiBoYXNCdW5kbGUgPyBidW5kbGVzLm1hcChidW5kbGUgPT4gYnVuZGxlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFkZHJlc3NlczogaGFzQWRkcmVzc2VzID8gYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IGFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgdGFnczogaGFzVGFncyA/IHRhZ3MubWFwKHRhZyA9PiB0YWcudG9Ucnl0ZXMoKS50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgYXBwcm92ZWVzOiBoYXNBcHByb3ZlZXMgPyBhcHByb3ZlZXMubWFwKGFwcHJvdmVlID0+IGFwcHJvdmVlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkgOiB1bmRlZmluZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmZpbmRUcmFuc2FjdGlvbnMocmVxdWVzdCk7XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmhhc2hlcykge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwID0gcmVzcG9uc2UuaGFzaGVzLm1hcChoYXNoID0+IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoaGFzaCkpKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpmaW5kVHJhbnNhY3Rpb25zXCIsIHJlc3ApO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6ZmluZFRyYW5zYWN0aW9uc1wiLCBbXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdHJhbnNhY3Rpb24gZGV0YWlscyBvZiBzcGVjaWZpYyB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldFRyYW5zYWN0aW9uc09iamVjdHModHJhbnNhY3Rpb25IYXNoZXMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc09iamVjdHNcIiwgdHJhbnNhY3Rpb25IYXNoZXMpO1xyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zYWN0aW9uSGFzaGVzLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRyYW5zYWN0aW9uSGFzaGVzIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBIYXNoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBoYXNoZXM6IHRyYW5zYWN0aW9uSGFzaGVzLm1hcChoYXNoID0+IGhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0VHJ5dGVzKHJlcXVlc3QpO1xyXG4gICAgICAgIGlmIChyZXNwb25zZSAmJiByZXNwb25zZS50cnl0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlc3BvbnNlLnRyeXRlcy5tYXAodHJ5dGVzID0+IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cnl0ZXMpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0VHJhbnNhY3Rpb25zT2JqZWN0c1wiLCByZXNwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zYWN0aW9uc09iamVjdHNcIiwgW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGluY2x1c2lvbiBzdGF0ZXMgb2YgYSBsaXN0IG9mIHRyYW5zYWN0aW9uIGhhc2hlcy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgaW5jbHVzaW9uIHN0YXRlcyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldExhdGVzdEluY2x1c2lvbih0cmFuc2FjdGlvbkhhc2hlcykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6dHJhbnNhY3Rpb25IYXNoZXNcIik7XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQodHJhbnNhY3Rpb25IYXNoZXMsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb25IYXNoZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5vZGVJbmZvID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldE5vZGVJbmZvKCk7XHJcbiAgICAgICAgaWYgKG5vZGVJbmZvICYmIG51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobm9kZUluZm8ubGF0ZXN0U29saWRTdWJ0YW5nbGVNaWxlc3RvbmUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9uSGFzaGVzLm1hcChoYXNoID0+IGhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpKSxcclxuICAgICAgICAgICAgICAgIHRpcHM6IFtub2RlSW5mby5sYXRlc3RTb2xpZFN1YnRhbmdsZU1pbGVzdG9uZV1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0SW5jbHVzaW9uU3RhdGVzKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OnRyYW5zYWN0aW9uSGFzaGVzXCIsIHJlc3BvbnNlLnN0YXRlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uuc3RhdGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50Ojp0cmFuc2FjdGlvbkhhc2hlc1wiLCBbXSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIlRoZSBub2RlIGNvdWxkIG5vdCBwcm92aWRlIHRoZSBsYXRlc3RTb2xpZFN1YnRhbmdsZU1pbGVzdG9uZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhZGRyZXNzZXMgd2l0aCBpbmRleC1iYXNlZCBvciB1c2luZyBhcGlzLlxyXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gZ2VuZXJhdGUgdGhlIGFkZHJlc3NlcyBmcm9tLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBpbmNsdWRlQ2hlY2tzdW0gSW5jbHVkZXMgdGhlIGNoZWNrc3VtIG9uIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHRoZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIGFkZHJlc3NlcyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldE5ld0FkZHJlc3Moc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldE5ld0FkZHJlc3NcIiwgc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoc3RhcnRJbmRleCkgJiYgIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc3RhcnRJbmRleCwgTnVtYmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc3RhcnRJbmRleCBtdXN0IGJlIGFuIGludGVnZXJcIiwgeyBzdGFydEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsb2NhbFN0YXJ0SW5kZXggPSBzdGFydEluZGV4IHx8IDA7XHJcbiAgICAgICAgaWYgKGxvY2FsU3RhcnRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHN0YXJ0SW5kZXggbXVzdCBiZSA+PSAwXCIsIHsgbG9jYWxTdGFydEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoYXNFbmRJbmRleCA9IG51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoZW5kSW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsU2VjdXJpdHkgPSBzZWN1cml0eSB8fCBhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubWVkaXVtO1xyXG4gICAgICAgIGxldCBhZGRyZXNzZXM7XHJcbiAgICAgICAgaWYgKGhhc0VuZEluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihlbmRJbmRleCkgfHwgZW5kSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgZW5kSW5kZXggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIsIHsgZW5kSW5kZXggfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdG90YWwgPSBlbmRJbmRleCAtIHN0YXJ0SW5kZXggKyAxO1xyXG4gICAgICAgICAgICBpZiAodG90YWwgPD0gMCB8fCB0b3RhbCA+IFRyYW5zYWN0aW9uQ2xpZW50Lk1BWF9JTlBVVFMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihgVGhlIHRvdGFsIG11c3QgYmUgPiAwIGFuZCA8PSAke1RyYW5zYWN0aW9uQ2xpZW50Lk1BWF9JTlBVVFN9YCwgeyB0b3RhbCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3Nlc0J5SW5kZXgoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgbG9jYWxTZWN1cml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3Nlc1RvVW51c2VkKHNlZWQsIHN0YXJ0SW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgbG9jYWxTZWN1cml0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0TmV3QWRkcmVzc1wiLCBhZGRyZXNzZXMpO1xyXG4gICAgICAgIHJldHVybiBhZGRyZXNzZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBuZXcgYWRkcmVzc2VzIGluZGV4LWJhc2VkLlxyXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gZ2VuZXJhdGUgdGhlIGFkZHJlc3NlcyBmcm9tLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBpbmNsdWRlQ2hlY2tzdW0gSW5jbHVkZXMgdGhlIGNoZWNrc3VtIG9uIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHRoZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIGFkZHJlc3NlcyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEFkZHJlc3Nlc0J5SW5kZXgoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldEFkZHJlc3Nlc0J5SW5kZXhcIiwgc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydEluZGV4KSB8fCBzdGFydEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc3RhcnRJbmRleCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIiwgeyBzdGFydEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoZW5kSW5kZXgpIHx8IGVuZEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgZW5kSW5kZXggbXVzdCBiZSBhIG51bWJlciA+PSAwXCIsIHsgZW5kSW5kZXggfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRvdGFsID0gZW5kSW5kZXggLSBzdGFydEluZGV4ICsgMTtcclxuICAgICAgICBpZiAodG90YWwgPD0gMCB8fCB0b3RhbCA+IFRyYW5zYWN0aW9uQ2xpZW50Lk1BWF9JTlBVVFMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKGBUaGUgdG90YWwgbXVzdCBiZSA+IDAgYW5kIDw9ICR7VHJhbnNhY3Rpb25DbGllbnQuTUFYX0lOUFVUU31gLCB7IHRvdGFsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgMSB8fCBzZWN1cml0eSA+IDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlY3VyaXR5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzXCIsIHsgc2VjdXJpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xyXG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaCh0aGlzLmdlbmVyYXRlQWRkcmVzcyhzZWVkLCBzdGFydEluZGV4ICsgaSwgc2VjdXJpdHksIGluY2x1ZGVDaGVja3N1bSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmdldEFkZHJlc3Nlc0J5SW5kZXhcIiwgYWRkcmVzc2VzKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFkZHJlc3Nlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBuZXcgYWRkcmVzcyB3aGljaCBoYXZlbnQgYmVlbiB1c2VkIHVzaW5nIGFwaXMuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZW5lcmF0ZSB0aGUgYWRkcmVzc2VzIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggdG8gZ2VuZXJhdGUgYWRkcmVzc2VzLlxyXG4gICAgICogQHBhcmFtIGluY2x1ZGVDaGVja3N1bSBJbmNsdWRlcyB0aGUgY2hlY2tzdW0gb24gYWRkcmVzc2VzLlxyXG4gICAgICogQHBhcmFtIHNlY3VyaXR5IFRoZSBzZWN1cml0eSBsZXZlbCBhdCB3aGljaCB0byBjcmVhdGUgdGhlIGFkZHJlc3Nlcy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gYW4gYWRkcmVzc2VzIGxpc3QsIHRoZSBmaXJzdCB1bnVzZWQgYWRkcmVzcyBpcyB0aGUgbGFzdCBpbiB0aGUgbGlzdCBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEFkZHJlc3Nlc1RvVW51c2VkKHNlZWQsIHN0YXJ0SW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldEFkZHJlc3Nlc1RvVW51c2VkXCIsIHNlZWQsIHN0YXJ0SW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydEluZGV4KSB8fCBzdGFydEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc3RhcnRJbmRleCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIiwgeyBzdGFydEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgMSB8fCBzZWN1cml0eSA+IDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlY3VyaXR5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzXCIsIHsgc2VjdXJpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2NhbFN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xyXG4gICAgICAgIGxldCBpc1VzZWQ7XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5nZW5lcmF0ZUFkZHJlc3Moc2VlZCwgbG9jYWxTdGFydEluZGV4KyssIHNlY3VyaXR5LCBpbmNsdWRlQ2hlY2tzdW0pO1xyXG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc05vQ2hlY2tzdW0gPSBhZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY29uc3Qgc3BlbnRGcm9tUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW2FkZHJlc3NOb0NoZWNrc3VtXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBzcGVudEZyb21SZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC53ZXJlQWRkcmVzc2VzU3BlbnRGcm9tKHNwZW50RnJvbVJlcXVlc3QpO1xyXG4gICAgICAgICAgICBpc1VzZWQgPSBzcGVudEZyb21SZXNwb25zZSAmJiBzcGVudEZyb21SZXNwb25zZS5zdGF0ZXMgJiYgc3BlbnRGcm9tUmVzcG9uc2Uuc3RhdGVzLmxlbmd0aCA+IDAgPyBzcGVudEZyb21SZXNwb25zZS5zdGF0ZXNbMF0gOiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFpc1VzZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRUcmFuc2FjdGlvbnNSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW2FkZHJlc3NOb0NoZWNrc3VtXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmRSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC5maW5kVHJhbnNhY3Rpb25zKGZpbmRUcmFuc2FjdGlvbnNSZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIGlzVXNlZCA9IGZpbmRSZXNwb25zZSAmJiBmaW5kUmVzcG9uc2UuaGFzaGVzICYmIGZpbmRSZXNwb25zZS5oYXNoZXMubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGlzVXNlZCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBZGRyZXNzZXNUb1VudXNlZFwiLCBhZGRyZXNzZXMpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkcmVzc2VzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBpbnB1dCBkYXRhIGZvciBhIHJhbmdlIG9mIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdldCB0aGUgaW5wdXQgZGF0YSBmb3IuXHJcbiAgICAgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggdG8gZ2V0IHRoZSBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCB0byBnZXQgdGhlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgdXNlZCB0byBjcmVhdGUgdGhlIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwYXJhbSB0b3RhbFJlcXVpcmVkIFRoZSB0aHJlc2hvbGQgYXQgd2hpY2ggdG90YWwgYmFsYW5jZSB0byBzdG9wIGdhdGhlcmluZyBhZGRyZXNzZXMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBpbnB1dHMgZm9yIGVhY2ggYWRkcmVzcyBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldElucHV0cyhzZWVkLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc2VjdXJpdHksIHRvdGFsUmVxdWlyZWQpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldElucHV0c1wiLCBzZWVkLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc2VjdXJpdHksIHRvdGFsUmVxdWlyZWQpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydEluZGV4KSB8fCBzdGFydEluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc3RhcnRJbmRleCBtdXN0IGJlIGEgbnVtYmVyID49IDBcIiwgeyBzdGFydEluZGV4IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc2VjdXJpdHkpIHx8IHNlY3VyaXR5IDwgMSB8fCBzZWN1cml0eSA+IDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlY3VyaXR5IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAzXCIsIHsgc2VjdXJpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcih0b3RhbFJlcXVpcmVkKSB8fCB0b3RhbFJlcXVpcmVkIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdG90YWxSZXF1aXJlZCBtdXN0IGJlID49IDBcIiwgeyB0b3RhbFJlcXVpcmVkIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmdldE5ld0FkZHJlc3Moc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGZhbHNlLCBzZWN1cml0eSk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGFkZCA9PiBhZGQudG9Ucnl0ZXMoKS50b1N0cmluZygpKSxcclxuICAgICAgICAgICAgdGhyZXNob2xkOiAxMDBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldEJhbGFuY2VzKHJlcXVlc3QpO1xyXG4gICAgICAgIGNvbnN0IGlucHV0cyA9IFtdO1xyXG4gICAgICAgIGxldCB0b3RhbEJhbGFuY2UgPSAwO1xyXG4gICAgICAgIGlmIChyZXNwb25zZSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IHBhcnNlSW50KHJlc3BvbnNlLmJhbGFuY2VzW2ldLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChpbnB1dF8xLklucHV0LmZyb21QYXJhbXMoYWRkcmVzc2VzW2ldLCBzZWN1cml0eSwgc3RhcnRJbmRleCArIGksIGJhbGFuY2UpKTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbEJhbGFuY2UgKz0gYmFsYW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxSZXF1aXJlZCA+IDAgJiYgdG90YWxCYWxhbmNlID49IHRvdGFsUmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3AgPSB7IGlucHV0cywgdG90YWxCYWxhbmNlIH07XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRJbnB1dHNcIiwgcmVzcCk7XHJcbiAgICAgICAgaWYgKHRvdGFsUmVxdWlyZWQgPiAwICYmIHRvdGFsQmFsYW5jZSA8IHRvdGFsUmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiTm90IGVub3VnaCBjb21iaW5lZCBiYWxhbmNlIGluIHRoZSBhZGRyZXNzZXMgdG8gc2F0aXNmeSB0aGUgdG90YWwgcmVxdWlyZWRcIiwgeyB0b3RhbFJlcXVpcmVkLCB0b3RhbEJhbGFuY2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlcyB0cmFuc2ZlciBieSBnZW5lcmF0aW5nIGJ1bmRsZSwgZmluZGluZyBhbmQgc2lnbmluZyBpbnB1dHMuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBwcmVwYXJlIHRoZSB0cmFuc2ZlciBmb3IuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gcHJlcGFyZS5cclxuICAgICAqIEBwYXJhbSB0cmFuc2Zlck9wdGlvbnNcclxuICAgICAqICAgICAgQHByb3BlcnR5IGlucHV0cyBMaXN0IG9mIGlucHV0cyB1c2VkIGZvciBmdW5kaW5nIHRoZSB0cmFuc2Zlci5cclxuICAgICAqICAgICAgQHByb3BlcnR5IHNlY3VyaXR5IFNlY3VyaXR5IGxldmVsIHRvIGJlIHVzZWQgZm9yIHRoZSBwcml2YXRlIGtleSAvIGFkZHJlc3Nlcy5cclxuICAgICAqICAgICAgQHByb3BlcnR5IHJlbWFpbmRlckFkZHJlc3MgSWYgZGVmaW5lZCwgdGhpcyBhZGRyZXNzIHdpbGwgYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgcmVtYWluZGVyIHZhbHVlIChvZiB0aGUgaW5wdXRzKSB0by5cclxuICAgICAqICAgICAgQHByb3BlcnR5IGhtYWNLZXkgSG1hYyBrZXkgdG8gc2lnbiB0aGUgYnVuZGxlLlxyXG4gICAgICogICAgICBAcHJvcGVydHkgcmVmZXJlbmNlIFRoZSB0cmFuc2FjdGlvbiB0byByZWZlcmVuY2UuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBhcnJheSBvZiBUcnl0ZXMgZm9yIHRoZSB0cmFuc2ZlciBvciByZWplY3RzIHdpdGggZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHByZXBhcmVUcmFuc2ZlcnMoc2VlZCwgdHJhbnNmZXJzLCB0cmFuc2Zlck9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OnByZXBhcmVUcmFuc2ZlcnNcIiwgc2VlZCwgdHJhbnNmZXJzLCB0cmFuc2Zlck9wdGlvbnMpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zZmVycywgdHJhbnNmZXJfMS5UcmFuc2ZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRyYW5zZmVycyBtdXN0IGJlIGFuIGFycmF5IG9mIFRyYW5zZmVyIG9iamVjdHNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxvY2FsVHJhbnNmZXJPcHRpb25zID0gdHJhbnNmZXJPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGxvY2FsVHJhbnNmZXJPcHRpb25zLnNlY3VyaXR5ID0gbG9jYWxUcmFuc2Zlck9wdGlvbnMuc2VjdXJpdHkgfHwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5Lm1lZGl1bTtcclxuICAgICAgICBjb25zdCBlbXB0eVRyeXRlcyA9IHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKFwiXCIpO1xyXG4gICAgICAgIGNvbnN0IGFkZEhNQUMgPSAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobG9jYWxUcmFuc2Zlck9wdGlvbnMuaG1hY0tleSk7XHJcbiAgICAgICAgbGV0IGFkZGVkSE1BQyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIElmIG1lc3NhZ2Ugb3IgdGFnIGlzIG5vdCBzdXBwbGllZCwgcHJvdmlkZSBpdFxyXG4gICAgICAgIHRyYW5zZmVycy5mb3JFYWNoKHRyYW5zZmVyID0+IHtcclxuICAgICAgICAgICAgdHJhbnNmZXIubWVzc2FnZSA9IHRyYW5zZmVyLm1lc3NhZ2UgPyB0cmFuc2Zlci5tZXNzYWdlIDogZW1wdHlUcnl0ZXM7XHJcbiAgICAgICAgICAgIHRyYW5zZmVyLnRhZyA9IHRyYW5zZmVyLnRhZyB8fCB0YWdfMS5UYWcuRU1QVFk7XHJcbiAgICAgICAgICAgIGlmIChhZGRITUFDICYmIHRyYW5zZmVyLnZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmZXIubWVzc2FnZSA9IHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKFRyYW5zYWN0aW9uQ2xpZW50Lk5VTExfSEFTSF9UUllURVMgKyB0cmFuc2Zlci5tZXNzYWdlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgYWRkZWRITUFDID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBidW5kbGVcclxuICAgICAgICBjb25zdCBwcmVwYXJlZCA9IGJ1bmRsZUhlbHBlcl8xLkJ1bmRsZUhlbHBlci5wcmVwYXJlQnVuZGxlKHRoaXMuX3RpbWVTZXJ2aWNlLCB0cmFuc2ZlcnMpO1xyXG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IHByZXBhcmVkLmJ1bmRsZTtcclxuICAgICAgICBjb25zdCBsYXN0VGFnID0gcHJlcGFyZWQubGFzdFRhZztcclxuICAgICAgICBjb25zdCB0b3RhbFZhbHVlID0gcHJlcGFyZWQudG90YWxWYWx1ZTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzID0gcHJlcGFyZWQuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cztcclxuICAgICAgICAvLyBHZXQgaW5wdXRzIGlmIHdlIGFyZSBzZW5kaW5nIHRva2Vuc1xyXG4gICAgICAgIGlmICh0b3RhbFZhbHVlID4gMCkge1xyXG4gICAgICAgICAgICAvLyAgQ2FzZSAxOiB1c2VyIHByb3ZpZGVkIGlucHV0c1xyXG4gICAgICAgICAgICAvLyAgVmFsaWRhdGUgdGhlIGlucHV0cyBieSBjYWxsaW5nIGdldEJhbGFuY2VzXHJcbiAgICAgICAgICAgIGlmIChsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHMubWFwKGlucHV0ID0+IGlucHV0LmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpKSxcclxuICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEwMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldEJhbGFuY2VzKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlybWVkSW5wdXRzID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxCYWxhbmNlID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZXMuYmFsYW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gcGFyc2VJbnQoYmFsYW5jZXMuYmFsYW5jZXNbaV0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpbnB1dCBoYXMgYmFsYW5jZSwgYWRkIGl0IHRvIGNvbmZpcm1lZElucHV0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiYWxhbmNlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEJhbGFuY2UgKz0gYmFsYW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxUcmFuc2Zlck9wdGlvbnMuaW5wdXRzW2ldLmJhbGFuY2UgPSBiYWxhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtZWRJbnB1dHMucHVzaChsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHJlYWNoZWQgdGhlIGludGVuZGVkIGlucHV0IHZhbHVlLCBicmVhayBvdXQgb2YgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxCYWxhbmNlID49IHRvdGFsVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIG5vdCBlbm91Z2ggYmFsYW5jZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsVmFsdWUgPiB0b3RhbEJhbGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJOb3QgZW5vdWdoIGJhbGFuY2UgaW4gdGhlIGlucHV0IGFkZHJlc3NlcyB0byBzYXRpc2Z5IHRoZSB0b3RhbCBmb3IgdGhlIHRyYW5zZmVyXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hZGRSZW1haW5kZXIoc2VlZCwgYnVuZGxlLCBsb2NhbFRyYW5zZmVyT3B0aW9ucywgY29uZmlybWVkSW5wdXRzLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCB0b3RhbFZhbHVlLCBsYXN0VGFnLCBhZGRlZEhNQUMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gaW5wdXRzIHN1cHBsaWVkIHNvIHdlIG5lZWQgdG8gZ2V0IHNvbWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRJbnB1dHMoc2VlZCwgMCwgdW5kZWZpbmVkLCBsb2NhbFRyYW5zZmVyT3B0aW9ucy5zZWN1cml0eSwgdG90YWxWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFkZFJlbWFpbmRlcihzZWVkLCBidW5kbGUsIGxvY2FsVHJhbnNmZXJPcHRpb25zLCBpbnB1dHNSZXNwb25zZS5pbnB1dHMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIHRvdGFsVmFsdWUsIGxhc3RUYWcsIGFkZGVkSE1BQyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGlucHV0IHJlcXVpcmVkLCBkb24ndCBzaWduIGFuZCBzaW1wbHkgZmluYWxpemUgdGhlIGJ1bmRsZVxyXG4gICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuZmluYWxpemVCdW5kbGUoYnVuZGxlKTtcclxuICAgICAgICAgICAgYnVuZGxlLmFkZFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnMgPSBidW5kbGUudHJhbnNhY3Rpb25zLnJldmVyc2UoKTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OnByZXBhcmVUcmFuc2ZlcnNcIiwgYnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gYnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIHRyYW5zYWN0aW9ucyB0byB0aGUgdGFuZ2xlIGJ5IGRvaW5nIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIHRvIGF0dGFjaC5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgdG8gc2VuZCB3aXRoIHRoZSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBhdHRhY2hUb1RhbmdsZShidW5kbGUsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHJlZmVyZW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6YXR0YWNoVG9UYW5nbGVcIiwgYnVuZGxlLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShidW5kbGUsIGJ1bmRsZV8xLkJ1bmRsZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGJ1bmRsZSBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgQnVuZGxlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChidW5kbGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgYnVuZGxlLnRyYW5zYWN0aW9ucyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgVHJhbnNhY3Rpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihkZXB0aCkgfHwgZGVwdGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgZGVwdGggbXVzdCBiZSBhIG51bWJlciA+IDBcIiwgeyBkZXB0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIG1pbldlaWdodE1hZ25pdHVkZSBtdXN0IGJlIGEgbnVtYmVyID4gMFwiLCB7IG1pbldlaWdodE1hZ25pdHVkZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zVG9BcHByb3ZlUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgZGVwdGgsXHJcbiAgICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlID8gcmVmZXJlbmNlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zVG9BcHByb3ZlID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldFRyYW5zYWN0aW9uc1RvQXBwcm92ZSh0cmFuc2FjdGlvbnNUb0FwcHJvdmVSZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBhbGxUcnl0ZXMgPSBhd2FpdCB0aGlzLl9wcm9vZk9mV29yay5wb3coaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cmFuc2FjdGlvbnNUb0FwcHJvdmUudHJ1bmtUcmFuc2FjdGlvbikpLCBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyYW5zYWN0aW9uc1RvQXBwcm92ZS5icmFuY2hUcmFuc2FjdGlvbikpLCBidW5kbGUudHJhbnNhY3Rpb25zLm1hcCh0ID0+IHQudG9Ucnl0ZXMoKSksIG1pbldlaWdodE1hZ25pdHVkZSk7XHJcbiAgICAgICAgY29uc3QgcG93VHJhbnNhY3Rpb25zID0gYWxsVHJ5dGVzLm1hcChyZXR1cm5Ucnl0ZXMgPT4gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHJldHVyblRyeXRlcykpO1xyXG4gICAgICAgIGNvbnN0IG5ld0J1bmRsZSA9IG5ldyBidW5kbGVfMS5CdW5kbGUoKTtcclxuICAgICAgICBuZXdCdW5kbGUudHJhbnNhY3Rpb25zID0gcG93VHJhbnNhY3Rpb25zO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6YXR0YWNoVG9UYW5nbGVcIiwgbmV3QnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gbmV3QnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcGVyIGZ1bmN0aW9uIHRoYXQgZG9lcyBhdHRhY2hUb1RhbmdsZSBhbmQgdGhlbiBzdG9yZXMgYW5kIGJyb2FkY2FzdHMgdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBidW5kbGUgVGhlIGJ1bmRsZSBvZiB0cmFuc2FjdGlvbnMgdG8gc2VuZC5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgdG8gc2VuZCB3aXRoIHRoZSB0cmFuc2FjdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb25zKGJ1bmRsZSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgcmVmZXJlbmNlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpzZW5kVHJhbnNhY3Rpb25zXCIsIGJ1bmRsZSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgcmVmZXJlbmNlKTtcclxuICAgICAgICBjb25zdCBhdHRhY2hlZFRyYW5zYWN0aW9uc0J1bmRsZSA9IGF3YWl0IHRoaXMuYXR0YWNoVG9UYW5nbGUoYnVuZGxlLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIGNvbnN0IHN0b3JlVHJhbnNhY3Rpb25zUmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgdHJ5dGVzOiBhdHRhY2hlZFRyYW5zYWN0aW9uc0J1bmRsZS50cmFuc2FjdGlvbnMubWFwKHQgPT4gdC50b1RyeXRlcygpLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhd2FpdCB0aGlzLl9hcGlDbGllbnQuc3RvcmVUcmFuc2FjdGlvbnMoc3RvcmVUcmFuc2FjdGlvbnNSZXF1ZXN0KTtcclxuICAgICAgICBjb25zdCBicm9hZGNhc3RUcmFuc2FjdGlvbnNSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICB0cnl0ZXM6IHN0b3JlVHJhbnNhY3Rpb25zUmVxdWVzdC50cnl0ZXNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaUNsaWVudC5icm9hZGNhc3RUcmFuc2FjdGlvbnMoYnJvYWRjYXN0VHJhbnNhY3Rpb25zUmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpzZW5kVHJhbnNhY3Rpb25zXCIsIGF0dGFjaGVkVHJhbnNhY3Rpb25zQnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gYXR0YWNoZWRUcmFuc2FjdGlvbnNCdW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgZnVuY3Rpb24gdGhhdCBkb2VzIHByZXBhcmVUcmFuc2ZlcnMgYW5kIHRoZW4gc2VuZFRyYW5zYWN0aW9ucy5cclxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIHNlbmQgdGhlIHRyYW5zZmVyIGZvci5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gc2VuZC5cclxuICAgICAqIEBwYXJhbSB0cmFuc2Zlck9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdHJhbnNmZXIuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBpbnB1dHMgTGlzdCBvZiBpbnB1dHMgdXNlZCBmb3IgZnVuZGluZyB0aGUgdHJhbnNmZXIuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBzZWN1cml0eSBTZWN1cml0eSBsZXZlbCB0byBiZSB1c2VkIGZvciB0aGUgcHJpdmF0ZSBrZXkgLyBhZGRyZXNzZXMuXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSByZW1haW5kZXJBZGRyZXNzIElmIGRlZmluZWQsIHRoaXMgYWRkcmVzcyB3aWxsIGJlIHVzZWQgZm9yIHNlbmRpbmcgdGhlIHJlbWFpbmRlciB2YWx1ZSAob2YgdGhlIGlucHV0cykgdG8uXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBobWFjS2V5IEhtYWMga2V5IHRvIHNpZ24gdGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSB0byBzZW5kIHdpdGggdGhlIHRyYW5zYWN0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBzZW5kVHJhbnNmZXIoc2VlZCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCB0cmFuc2Zlck9wdGlvbnMsIHJlZmVyZW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6c2VuZFRyYW5zZmVyXCIsIHNlZWQsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyVHJ5dGVzID0gYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNmZXJzKHNlZWQsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zKTtcclxuICAgICAgICBjb25zdCBzZW50QnVuZGxlID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb25zKHRyYW5zZmVyVHJ5dGVzLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6c2VuZFRyYW5zZmVyXCIsIHNlbnRCdW5kbGUpO1xyXG4gICAgICAgIHJldHVybiBzZW50QnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIG91dCBpZiBhIHRyYW5zYWN0aW9uIGlzIHByb21vdGFibGUuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25UYWlsIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBwcm9tb3RlZC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcHJvbW90YWJsZSByZWplY3RzIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGlzUHJvbW90YWJsZSh0cmFuc2FjdGlvblRhaWwpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmlzUHJvbW90YWJsZVwiLCB0cmFuc2FjdGlvblRhaWwpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cmFuc2FjdGlvblRhaWwsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb25UYWlsIG11c3QgYmUgYW4gb2JqZWN0IG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hlY2tDb25zaXN0ZW5jeVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIHRhaWxzOiBbdHJhbnNhY3Rpb25UYWlsLnRvVHJ5dGVzKCkudG9TdHJpbmcoKV1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGNoZWNrQ29uc2lzdGVuY3lSZXNwb25zZSA9IGF3YWl0IHRoaXMuX2FwaUNsaWVudC5jaGVja0NvbnNpc3RlbmN5KGNoZWNrQ29uc2lzdGVuY3lSZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmlzUHJvbW90YWJsZVwiLCBjaGVja0NvbnNpc3RlbmN5UmVzcG9uc2Uuc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBjaGVja0NvbnNpc3RlbmN5UmVzcG9uc2Uuc3RhdGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB5b3Ugc2hvdWxkIHJlcGxheSBhIHRyYW5zYWN0aW9uIG9yIG1ha2UgYSBuZXcgb25lIChlaXRoZXIgd2l0aCB0aGUgc2FtZSBpbnB1dCwgb3IgYSBkaWZmZXJlbnQgb25lKS5cclxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgSW5wdXQgYWRkcmVzcyB5b3Ugd2FudCB0byBoYXZlIHRlc3RlZC5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgYWRkcmVzc2VzIGFyZSByZWF0dGFjaGFibGUgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBpc1JlYXR0YWNoYWJsZShhZGRyZXNzZXMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmlzUmVhdHRhY2hhYmxlXCIsIGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYWRkcmVzc2VzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIGFkZHJlc3NlcyBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEFkZHJlc3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJzVHhzTWFwID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYWRkcmVzc1N0cmluZyA9IGFkZHJlc3Nlc1tpXS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGFkZHJzVHhzTWFwW2FkZHJlc3NTdHJpbmddID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGF3YWl0IHRoaXMuZmluZFRyYW5zYWN0aW9uT2JqZWN0cyh1bmRlZmluZWQsIGFkZHJlc3Nlcyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVUcmFuc2FjdGlvbnMgPSBbXTtcclxuICAgICAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnZhbHVlLnRvTnVtYmVyKCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eEFkZHJlc3MgPSB0cmFuc2FjdGlvbi5hZGRyZXNzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHhIYXNoID0gdHJhbnNhY3Rpb25IZWxwZXJfMS5UcmFuc2FjdGlvbkhlbHBlci5oYXNoKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGFkZHJzVHhzTWFwW3R4QWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCldLnB1c2godHhIYXNoKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlVHJhbnNhY3Rpb25zLnB1c2godHhIYXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCByZXN1bHRzO1xyXG4gICAgICAgIGlmICh2YWx1ZVRyYW5zYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluY2x1c2lvblN0YXRlcyA9IGF3YWl0IHRoaXMuZ2V0TGF0ZXN0SW5jbHVzaW9uKHZhbHVlVHJhbnNhY3Rpb25zKTtcclxuICAgICAgICAgICAgcmVzdWx0cyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBzaG91bGRSZWF0dGFjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eHMgPSBhZGRyc1R4c01hcFthZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4SW5kZXggPSB2YWx1ZVRyYW5zYWN0aW9ucy5pbmRleE9mKHR4c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVhdHRhY2ggPSAhaW5jbHVzaW9uU3RhdGVzW3R4SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmVhdHRhY2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZFJlYXR0YWNoO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmlzUmVhdHRhY2hhYmxlXCIsIHJlc3VsdHMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9tb3RlcyBhIHRyYW5zYWN0aW9uIGJ5IGFkZGluZyBzcGFtIG9uIHRvcCBvZiBpdCwgYXMgbG9uZyBhcyBpdCBpcyBwcm9tb3RhYmxlLlxyXG4gICAgICogV2lsbCBwcm9tb3RlIGJ5IGFkZGluZyB0cmFuc2ZlcnMgb24gdG9wIG9mIHRoZSBjdXJyZW50IG9uZSB3aXRoIGRlbGF5IGludGVydmFsLlxyXG4gICAgICogVXNlIHByb21vdGVPcHRpb25zLmludGVycnVwdCB0byB0ZXJtaW5hdGUgdGhlIHByb21vdGlvbi5cclxuICAgICAqIElmIHByb21vdGVPcHRpb25zLmRlbGF5IGlzIHNldCB0byAwIG9ubHkgb25lIHByb21vdGlvbiB0cmFuc2ZlciB3aWxsIGJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25UYWlsIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBwcm9tb3RlZC5cclxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cclxuICAgICAqIEBwYXJhbSBtaW5XZWlnaHRNYWduaXR1ZGUgVGhlIG1pbmltdW0gd2VpZ2h0IG1hZ25pdHVkZSBmb3IgdGhlIHByb29mIG9mIHdvcmsuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gc2VuZC5cclxuICAgICAqIEBwYXJhbSBwcm9tb3RlT3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBwcm9tb3RlLlxyXG4gICAgICogICAgICBAcHJvcGVydHkgZGVsYXkgRGVsYXkgYmV0d2VlbiBwcm9tb3Rpb24gdHJhbnNmZXJzXHJcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBpbnRlcnJ1cHQgRmxhZyBvciBtZXRob2QgdG8gdGVybWluYXRlIHByb21vdGlvbi5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBwcm9tb3RlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25UYWlsLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCB0cmFuc2ZlcnMsIHByb21vdGVPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50Ojpwcm9tb3RlVHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb25UYWlsLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCB0cmFuc2ZlcnMsIHByb21vdGVPcHRpb25zKTtcclxuICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJhbnNhY3Rpb25UYWlsLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHRyYW5zYWN0aW9uVGFpbCBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihkZXB0aCkgfHwgZGVwdGggPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgZGVwdGggbXVzdCBiZSBhIG51bWJlciA+IDBcIiwgeyBkZXB0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIG1pbldlaWdodE1hZ25pdHVkZSBtdXN0IGJlIGEgbnVtYmVyID4gMFwiLCB7IG1pbldlaWdodE1hZ25pdHVkZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQodHJhbnNmZXJzLCB0cmFuc2Zlcl8xLlRyYW5zZmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJhbnNmZXJzIG11c3QgYW4gYXJyYXkgb2YgVHJhbnNmZXIgb2JqZWN0c1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbG9jYWxQcm9tb3RlT3B0aW9ucyA9IHByb21vdGVPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShsb2NhbFByb21vdGVPcHRpb25zLmludGVycnVwdCkpIHtcclxuICAgICAgICAgICAgbG9jYWxQcm9tb3RlT3B0aW9ucy5pbnRlcnJ1cHQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvY2FsUHJvbW90ZU9wdGlvbnMuaW50ZXJydXB0ID09PSBmYWxzZSB8fCAodHlwZW9mIGxvY2FsUHJvbW90ZU9wdGlvbnMuaW50ZXJydXB0ID09PSBcImZ1bmN0aW9uXCIgJiYgIWxvY2FsUHJvbW90ZU9wdGlvbnMuaW50ZXJydXB0KCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUHJvbW90YWJsZSA9IGF3YWl0IHRoaXMuaXNQcm9tb3RhYmxlKHRyYW5zYWN0aW9uVGFpbCk7XHJcbiAgICAgICAgICAgIGlmIChpc1Byb21vdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRUcmFuc2ZlclJlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNmZXIoaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cmFuc2ZlcnNbMF0uYWRkcmVzcy50b1RyeXRlcygpKSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCB1bmRlZmluZWQsIHRyYW5zYWN0aW9uVGFpbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsb2NhbFByb21vdGVPcHRpb25zLmRlbGF5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYWNrZ3JvdW5kVGFza1NlcnZpY2UuY3JlYXRlKGFzeW5jICgpID0+IHRoaXMucHJvbW90ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uVGFpbCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCBsb2NhbFByb21vdGVPcHRpb25zKSwgbG9jYWxQcm9tb3RlT3B0aW9ucy5kZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OnByb21vdGVUcmFuc2FjdGlvblwiLCBzZW5kVHJhbnNmZXJSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRUcmFuc2ZlclJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVHJhbnNhY3Rpb24gaXMgbm90IHByb21vdGFibGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6cHJvbW90ZVRyYW5zYWN0aW9uXCIsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhc3NvY2lhdGVkIGJ1bmRsZSB0cmFuc2FjdGlvbnMgb2YgYSBzaW5nbGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgKiBEb2VzIHZhbGlkYXRpb24gb2Ygc2lnbmF0dXJlcywgdG90YWwgc3VtIGFzIHdlbGwgYXMgYnVuZGxlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBIYXNoIG9mIGEgdHJ1bmsgb3IgYSB0YWlsIHRyYW5zYWN0aW9uIG9mIGEgYnVuZGxlLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgYnVuZGxlIHRyYW5zYWN0aW9ucyBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdldEJ1bmRsZSh0cmFuc2FjdGlvbkhhc2gpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldEJ1bmRsZVwiLCB0cmFuc2FjdGlvbkhhc2gpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cmFuc2FjdGlvbkhhc2gsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJhbnNhY3Rpb25IYXNoIG11c3QgYmUgYW4gb2JqZWN0IG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gYXdhaXQgdGhpcy50cmF2ZXJzZUJ1bmRsZSh0cmFuc2FjdGlvbkhhc2gpO1xyXG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IG5ldyBidW5kbGVfMS5CdW5kbGUoKTtcclxuICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zO1xyXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuaXNWYWxpZChidW5kbGUpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJJbnZhbGlkIGJ1bmRsZSBwcm92aWRlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRCdW5kbGVcIiwgYnVuZGxlKTtcclxuICAgICAgICByZXR1cm4gYnVuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZSB0aGUgQnVuZGxlIGJ5IGdvaW5nIGRvd24gdGhlIHRydW5rVHJhbnNhY3Rpb25zIHVudGlsXHJcbiAgICAgKiB0aGUgYnVuZGxlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGlzIG5vIGxvbmdlciB0aGUgc2FtZS5cclxuICAgICAqIEBwYXJhbSB0cnVua1RyYW5zYWN0aW9uIEhhc2ggb2YgYSB0cnVuayBvciBhIHRhaWwgdHJhbnNhY3Rpb24gb2YgYSBidW5kbGUuXHJcbiAgICAgKiBAcGFyYW0gYnVuZGxlSGFzaCBUaGUgYnVuZGxlIGhhc2ggdG8gbWF0Y2guXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBidW5kbGUgdHJhbnNhY3Rpb25zIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJhdmVyc2VCdW5kbGUodHJ1bmtUcmFuc2FjdGlvbiwgYnVuZGxlSGFzaCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6dHJhdmVyc2VCdW5kbGVcIiwgdHJ1bmtUcmFuc2FjdGlvbiwgYnVuZGxlSGFzaCk7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRydW5rVHJhbnNhY3Rpb24sIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgdHJ1bmtUcmFuc2FjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFsbEJ1bmRsZVRyYW5zYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIGxldCBuZXdUcnVua1RyYW5zYWN0aW9uID0gdHJ1bmtUcmFuc2FjdGlvbjtcclxuICAgICAgICBsZXQgbmV3QnVuZGxlSGFzaCA9IGJ1bmRsZUhhc2g7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBjb25zdCBnZXRUcnl0ZXNSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgaGFzaGVzOiBbbmV3VHJ1bmtUcmFuc2FjdGlvbi50b1RyeXRlcygpLnRvU3RyaW5nKCldXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGdldFRyeXRlc1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5fYXBpQ2xpZW50LmdldFRyeXRlcyhnZXRUcnl0ZXNSZXF1ZXN0KTtcclxuICAgICAgICAgICAgY29uc3QgdHJ5dGVzID0gIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGdldFRyeXRlc1Jlc3BvbnNlKSAmJlxyXG4gICAgICAgICAgICAgICAgIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGdldFRyeXRlc1Jlc3BvbnNlLnRyeXRlcykgJiZcclxuICAgICAgICAgICAgICAgIGdldFRyeXRlc1Jlc3BvbnNlLnRyeXRlcy5sZW5ndGggPiAwID8gZ2V0VHJ5dGVzUmVzcG9uc2UudHJ5dGVzWzBdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodHJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiQnVuZGxlIHRyYW5zYWN0aW9ucyBub3QgdmlzaWJsZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uT2JqZWN0ID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyeXRlcykpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgZmlyc3QgdHJhbnNhY3Rpb24gdG8gc2VhcmNoIGlzIG5vdCBhIHRhaWwsIHJldHVybiBlcnJvclxyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzSGFzaCA9ICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShuZXdCdW5kbGVIYXNoKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFzSGFzaCAmJiB0cmFuc2FjdGlvbk9iamVjdC5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcIkludmFsaWQgdGFpbCB0cmFuc2FjdGlvbiBzdXBwbGllZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIG5vIGJ1bmRsZSBoYXNoLCBkZWZpbmUgaXRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsQnVuZGxlSGFzaCA9IGhhc0hhc2ggPyBuZXdCdW5kbGVIYXNoIDogdHJhbnNhY3Rpb25PYmplY3QuYnVuZGxlO1xyXG4gICAgICAgICAgICAgICAgbmV3VHJ1bmtUcmFuc2FjdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIG5ld0J1bmRsZUhhc2ggPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBzYW1lIGJ1bmRsZSBoYXNoIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxCdW5kbGVIYXNoLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA9PT0gdHJhbnNhY3Rpb25PYmplY3QuYnVuZGxlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0cmFuc2FjdGlvbiBvYmplY3QgdG8gYnVuZGxlXHJcbiAgICAgICAgICAgICAgICAgICAgYWxsQnVuZGxlVHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb25PYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgZWxlbWVudCB0aGVuIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uT2JqZWN0Lmxhc3RJbmRleC50b051bWJlcigpICE9PSAwIHx8IHRyYW5zYWN0aW9uT2JqZWN0LmN1cnJlbnRJbmRleC50b051bWJlcigpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1RydW5rVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbk9iamVjdC50cnVua1RyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdCdW5kbGVIYXNoID0gbG9jYWxCdW5kbGVIYXNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKG5ld1RydW5rVHJhbnNhY3Rpb24gIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50Ojp0cmF2ZXJzZUJ1bmRsZVwiLCBhbGxCdW5kbGVUcmFuc2FjdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBhbGxCdW5kbGVUcmFuc2FjdGlvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgd2hpY2ggZ2V0cyBhIGJ1bmRsZSBhbmQgdGhlbiByZXBsYXlzIGEgdHJhbnNmZXIgYnkgZG9pbmcgUHJvb2Ygb2YgV29yayBhZ2Fpbi5cclxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbkhhc2ggVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIHByb21vdGVkLlxyXG4gICAgICogQHBhcmFtIGRlcHRoIFZhbHVlIHRoYXQgZGV0ZXJtaW5lcyBob3cgZmFyIHRvIGdvIGZvciB0aXAgc2VsZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIG1pbldlaWdodE1hZ25pdHVkZSBUaGUgbWluaW11bSB3ZWlnaHQgbWFnbml0dWRlIGZvciB0aGUgcHJvb2Ygb2Ygd29yay5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWF0dGFjaEJ1bmRsZSh0cmFuc2FjdGlvbkhhc2gsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OnJlYXR0YWNoQnVuZGxlXCIsIHRyYW5zYWN0aW9uSGFzaCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSk7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlID0gYXdhaXQgdGhpcy5nZXRCdW5kbGUodHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zID0gYnVuZGxlLnRyYW5zYWN0aW9ucy5yZXZlcnNlKCk7XHJcbiAgICAgICAgY29uc3Qgc2VuZFRyYW5zYWN0aW9uc1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5zZW5kVHJhbnNhY3Rpb25zKGJ1bmRsZSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpyZWF0dGFjaEJ1bmRsZVwiLCBzZW5kVHJhbnNhY3Rpb25zUmVzcG9uc2UpO1xyXG4gICAgICAgIHJldHVybiBzZW5kVHJhbnNhY3Rpb25zUmVzcG9uc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBwZXIgd2hpY2ggZ2V0cyBhIGJ1bmRsZSBhbmQgdGhlbiBicm9hZGNhc3RzIGl0LlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgcmUtYnJvYWRjYXN0LlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYnJvYWRjYXN0QnVuZGxlKHRyYW5zYWN0aW9uSGFzaCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6cmVicm9hZGNhc3RCdW5kbGVcIiwgdHJhbnNhY3Rpb25IYXNoKTtcclxuICAgICAgICBjb25zdCBidW5kbGUgPSBhd2FpdCB0aGlzLmdldEJ1bmRsZSh0cmFuc2FjdGlvbkhhc2gpO1xyXG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdFRyYW5zYWN0aW9uc1JlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIHRyeXRlczogYnVuZGxlLnRyYW5zYWN0aW9ucy5yZXZlcnNlKCkubWFwKGJ0ID0+IGJ0LnRvVHJ5dGVzKCkudG9TdHJpbmcoKSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2FwaUNsaWVudC5icm9hZGNhc3RUcmFuc2FjdGlvbnMoYnJvYWRjYXN0VHJhbnNhY3Rpb25zUmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpyZWJyb2FkY2FzdEJ1bmRsZVwiLCBidW5kbGUpO1xyXG4gICAgICAgIHJldHVybiBidW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2FjdGlvbiBvYmplY3RzIGJ5IGZpc3QgcGVyZm9ybWluZyBhIGZpbmRUcmFuc2FjdGlvbnMgY2FsbC5cclxuICAgICAqIEBwYXJhbSBidW5kbGVzIEJ1bmRsZXMgdG8gbG9va3VwIHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIEFkZHJlc3NlcyB0byBsb29rdXAgdHJhbnNhY3Rpb25zIGZvci5cclxuICAgICAqIEBwYXJhbSB0YWdzIFRhZ3MgdG8gbG9va3VwIHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gYXBwcm92ZWVzIEFwcHJvdmVlcyB0byBsb29rdXAgdHJhbnNhY3Rpb25zIGZvci5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZmluZFRyYW5zYWN0aW9uT2JqZWN0cyhidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPT09PiBUcmFuc2FjdGlvbkNsaWVudDo6ZmluZFRyYW5zYWN0aW9uT2JqZWN0c1wiLCBidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcyk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gYXdhaXQgdGhpcy5maW5kVHJhbnNhY3Rpb25zKGJ1bmRsZXMsIGFkZHJlc3NlcywgdGFncywgYXBwcm92ZWVzKTtcclxuICAgICAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb25zT2JqZWN0cyh0cmFuc2FjdGlvbnMpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIjw9PT0gVHJhbnNhY3Rpb25DbGllbnQ6OmZpbmRUcmFuc2FjdGlvbk9iamVjdHNcIiwgcmVzcCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpmaW5kVHJhbnNhY3Rpb25PYmplY3RzXCIsIFtdKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRyYW5zZmVycyB3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgc2VlZC4gVGhlIHRyYW5zZmVycyBhcmUgZGV0ZXJtaW5lZCBieSBlaXRoZXIgY2FsY3VsYXRpbmdcclxuICAgICAqIGRldGVybWluaXN0aWNhbGx5IHdoaWNoIGFkZHJlc3NlcyB3ZXJlIGFscmVhZHkgdXNlZCwgb3IgYnkgcHJvdmlkaW5nIGEgbGlzdCBvZiBpbmRleGVzIHRvIGdldCB0aGVcclxuICAgICAqIGFkZHJlc3NlcyBhbmQgdGhlIGFzc29jaWF0ZWQgdHJhbnNmZXJzIGZyb20uIFRoZSB0cmFuc2ZlcnMgYXJlIHNvcnRlZCBieSB0aGVpciB0aW1lc3RhbXAuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3JcclxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIGZvciB0aGUgdHJhbnNmZXJzLlxyXG4gICAgICogQHBhcmFtIGluY2x1c2lvblN0YXRlcyBEbyB5b3Ugd2FudCBpbmNsdXNpb24gc3RhdGVzIGluIHRoZSBidW5kbGVzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmVxdWVzdGVkIGJ1bmRsZXMgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRUcmFuc2ZlcnMoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNlY3VyaXR5LCBpbmNsdXNpb25TdGF0ZXMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIj09PT4gVHJhbnNhY3Rpb25DbGllbnQ6OmdldFRyYW5zZmVyc1wiLCBzZWVkLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc2VjdXJpdHksIGluY2x1c2lvblN0YXRlcyk7XHJcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlZWQsIGhhc2hfMS5IYXNoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXCJUaGUgc2VlZCBtdXN0IGJlIG9mIHR5cGUgSGFzaFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvY2FsU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XHJcbiAgICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxvY2FsU3RhcnRJbmRleCkpIHtcclxuICAgICAgICAgICAgbG9jYWxTdGFydEluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy5nZXROZXdBZGRyZXNzKHNlZWQsIGxvY2FsU3RhcnRJbmRleCwgZW5kSW5kZXgsIGZhbHNlLCBzZWN1cml0eSk7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlcyA9IGF3YWl0IHRoaXMuYnVuZGxlc0Zyb21BZGRyZXNzZXMoYWRkcmVzc2VzLCBpbmNsdXNpb25TdGF0ZXMpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiPD09PSBUcmFuc2FjdGlvbkNsaWVudDo6Z2V0VHJhbnNmZXJzXCIsIGJ1bmRsZXMpO1xyXG4gICAgICAgIHJldHVybiBidW5kbGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1pbGFyIHRvIGdldFRyYW5zZmVycywganVzdCB0aGF0IGl0IHJldHVybnMgYWRkaXRpb25hbCBhY2NvdW50IGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3JcclxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIGZvciB0aGUgdHJhbnNmZXJzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgYWNjb3VudCBkYXRhIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0QWNjb3VudERhdGEoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNlY3VyaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI9PT0+IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBY2NvdW50RGF0YVwiLCBzZWVkLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc2VjdXJpdHkpO1xyXG4gICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2NhbFN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xyXG4gICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsb2NhbFN0YXJ0SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGxvY2FsU3RhcnRJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IHRoaXMuZ2V0TmV3QWRkcmVzcyhzZWVkLCBsb2NhbFN0YXJ0SW5kZXgsIGVuZEluZGV4LCBmYWxzZSwgc2VjdXJpdHkgfHwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5Lm1lZGl1bSk7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlcyA9IGF3YWl0IHRoaXMuYnVuZGxlc0Zyb21BZGRyZXNzZXMoYWRkcmVzc2VzLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBhY2NvdW50RGF0YSA9IHtcclxuICAgICAgICAgICAgbGF0ZXN0QWRkcmVzczogYWRkcmVzc2VzLnBvcCgpLFxyXG4gICAgICAgICAgICBhZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIHRyYW5zZmVyczogYnVuZGxlcyxcclxuICAgICAgICAgICAgaW5wdXRzOiBbXSxcclxuICAgICAgICAgICAgYmFsYW5jZTogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYmFsYW5jZVJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIGFkZHJlc3NlczogYWNjb3VudERhdGEuYWRkcmVzc2VzLm1hcChhZGQgPT4gYWRkLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSksXHJcbiAgICAgICAgICAgIHRocmVzaG9sZDogMTAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBiYWxhbmNlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9hcGlDbGllbnQuZ2V0QmFsYW5jZXMoYmFsYW5jZVJlcXVlc3QpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFsYW5jZVJlc3BvbnNlLmJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBwYXJzZUludChiYWxhbmNlUmVzcG9uc2UuYmFsYW5jZXNbaV0sIDEwKTtcclxuICAgICAgICAgICAgaWYgKGJhbGFuY2UgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50RGF0YS5pbnB1dHMucHVzaChpbnB1dF8xLklucHV0LmZyb21QYXJhbXMoYWNjb3VudERhdGEuYWRkcmVzc2VzW2ldLCBzZWN1cml0eSB8fCBhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubWVkaXVtLCBsb2NhbFN0YXJ0SW5kZXggKyBpLCBiYWxhbmNlKSk7XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50RGF0YS5iYWxhbmNlICs9IGJhbGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCI8PT09IFRyYW5zYWN0aW9uQ2xpZW50OjpnZXRBY2NvdW50RGF0YVwiLCBhY2NvdW50RGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGFjY291bnREYXRhO1xyXG4gICAgfVxyXG4gICAgLyogQGludGVybmFsICovXHJcbiAgICBhc3luYyBidW5kbGVzRnJvbUFkZHJlc3NlcyhhZGRyZXNzZXMsIGluY2x1c2lvblN0YXRlcykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uT2JqZWN0cyA9IGF3YWl0IHRoaXMuZmluZFRyYW5zYWN0aW9uT2JqZWN0cyh1bmRlZmluZWQsIGFkZHJlc3NlcywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIC8vIHNldCBvZiB0YWlsIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIGNvbnN0IHRhaWxUcmFuc2FjdGlvbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3Qgbm9uVGFpbEJ1bmRsZUhhc2hlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0cmFuc2FjdGlvbk9iamVjdHMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgLy8gU29ydCB0YWlsIGFuZCBub25UYWlsc1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uY3VycmVudEluZGV4LnRvTnVtYmVyKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRhaWxUcmFuc2FjdGlvbnMuYWRkKHRyYW5zYWN0aW9uSGVscGVyXzEuVHJhbnNhY3Rpb25IZWxwZXIuaGFzaCh0cmFuc2FjdGlvbikudG9Ucnl0ZXMoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vblRhaWxCdW5kbGVIYXNoZXMuYWRkKHRyYW5zYWN0aW9uLmJ1bmRsZS50b1RyeXRlcygpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG5vblRhaWxCdW5kbGVIYXNoZXMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9uVGFpbEJ1bmRsZVRyYW5zYWN0aW9ucyA9IGF3YWl0IHRoaXMuZmluZFRyYW5zYWN0aW9uT2JqZWN0cyhBcnJheS5mcm9tKG5vblRhaWxCdW5kbGVIYXNoZXMpLm1hcChoYXNoID0+IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoaGFzaCkpKSk7XHJcbiAgICAgICAgICAgIG5vblRhaWxCdW5kbGVUcmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhaWxUcmFuc2FjdGlvbnMuYWRkKHRyYW5zYWN0aW9uSGVscGVyXzEuVHJhbnNhY3Rpb25IZWxwZXIuaGFzaCh0cmFuc2FjdGlvbikudG9Ucnl0ZXMoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbmFsQnVuZGxlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRhaWxUeEFycmF5ID0gQXJyYXkuZnJvbSh0YWlsVHJhbnNhY3Rpb25zKTtcclxuICAgICAgICAvLyBJZiBpbmNsdXNpb25TdGF0ZXMsIGdldCB0aGUgY29uZmlybWF0aW9uIHN0YXR1c1xyXG4gICAgICAgIC8vIG9mIHRoZSB0YWlsIHRyYW5zYWN0aW9ucywgYW5kIHRodXMgdGhlIGJ1bmRsZXNcclxuICAgICAgICBsZXQgdGFpbFR4U3RhdGVzO1xyXG4gICAgICAgIGlmIChpbmNsdXNpb25TdGF0ZXMpIHtcclxuICAgICAgICAgICAgdGFpbFR4U3RhdGVzID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RJbmNsdXNpb24odGFpbFR4QXJyYXkubWFwKHRhaWwgPT4gaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0YWlsKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFwIGVhY2ggdGFpbCB0cmFuc2FjdGlvbiB0byB0aGUgZ2V0QnVuZGxlIGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gZm9ybWF0IHRoZSByZXR1cm5lZCBidW5kbGVzIGFuZCBhZGQgaW5jbHVzaW9uIHN0YXRlcyBpZiBuZWNlc3NhcnlcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhaWxUeEFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1bmRsZSA9IGF3YWl0IHRoaXMuZ2V0QnVuZGxlKGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodGFpbFR4QXJyYXlbaV0pKSk7XHJcbiAgICAgICAgICAgIGJ1bmRsZS5pbmNsdXNpb25TdGF0ZSA9IHRhaWxUeFN0YXRlcyA/IHRhaWxUeFN0YXRlc1tpXSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgZmluYWxCdW5kbGVzLnB1c2goYnVuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU29ydCBidW5kbGVzIGJ5IHRpbWVzdGFtcFxyXG4gICAgICAgIGZpbmFsQnVuZGxlcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBhLnRyYW5zYWN0aW9uc1swXS5hdHRhY2htZW50VGltZXN0YW1wLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBiLnRyYW5zYWN0aW9uc1swXS5hdHRhY2htZW50VGltZXN0YW1wLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmaW5hbEJ1bmRsZXM7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGdlbmVyYXRlQWRkcmVzcyhzZWVkLCBpbmRleCwgc2VjdXJpdHksIGluY2x1ZGVDaGVja3N1bSkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGlzc18xLklTUy5rZXkoc2VlZCwgaW5kZXgsIHNlY3VyaXR5KTtcclxuICAgICAgICBjb25zdCBkaWdlc3RzID0gaXNzXzEuSVNTLmRpZ2VzdHMoa2V5KTtcclxuICAgICAgICBjb25zdCBhZGRyZXNzVHJpdHMgPSBpc3NfMS5JU1MuYWRkcmVzcyhkaWdlc3RzKTtcclxuICAgICAgICBsZXQgYWRkcmVzc1RyeXRlc1N0cmluZyA9IHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGFkZHJlc3NUcml0cykudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChpbmNsdWRlQ2hlY2tzdW0pIHtcclxuICAgICAgICAgICAgYWRkcmVzc1RyeXRlc1N0cmluZyArPSBhZGRyZXNzSGVscGVyXzEuQWRkcmVzc0hlbHBlci5jcmVhdGVDaGVja3N1bShhZGRyZXNzVHJpdHMsIDkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWRkcmVzc18xLkFkZHJlc3MuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhhZGRyZXNzVHJ5dGVzU3RyaW5nKSk7XHJcbiAgICB9XHJcbiAgICAvKiBAaW50ZXJuYWwgKi9cclxuICAgIGFzeW5jIGFkZFJlbWFpbmRlcihzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgaW5wdXRzLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCB0b3RhbFZhbHVlLCB0YWcsIGFkZGVkSE1BQykge1xyXG4gICAgICAgIGxldCB0b3RhbFRyYW5zZmVyVmFsdWUgPSB0b3RhbFZhbHVlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IodGhpcy5fdGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkgLyAxMDAwKTtcclxuICAgICAgICAgICAgLy8gQWRkIGlucHV0IGFzIGJ1bmRsZSBlbnRyeVxyXG4gICAgICAgICAgICBidW5kbGUuYWRkVHJhbnNhY3Rpb25zKGlucHV0c1tpXS5zZWN1cml0eSwgaW5wdXRzW2ldLmFkZHJlc3MsIC1pbnB1dHNbaV0uYmFsYW5jZSwgdGFnLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlbWFpbmRlciB2YWx1ZVxyXG4gICAgICAgICAgICAvLyBBZGQgZXh0cmEgb3V0cHV0IHRvIHNlbmQgcmVtYWluaW5nIGZ1bmRzIHRvXHJcbiAgICAgICAgICAgIGlmIChpbnB1dHNbaV0uYmFsYW5jZSA+PSB0b3RhbFRyYW5zZmVyVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmRlciA9IGlucHV0c1tpXS5iYWxhbmNlIC0gdG90YWxUcmFuc2ZlclZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNlciBoYXMgcHJvdmlkZWQgcmVtYWluZGVyIGFkZHJlc3MgdXNlIGl0IHRvIHNlbmQgcmVtYWluaW5nIGZ1bmRzIHRvXHJcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluZGVyID4gMCAmJiAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodHJhbnNmZXJPcHRpb25zKSAmJiBvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyYW5zZmVyT3B0aW9ucy5yZW1haW5kZXJBZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1haW5kZXIgYnVuZGxlIGVudHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlLmFkZFRyYW5zYWN0aW9ucygxLCB0cmFuc2Zlck9wdGlvbnMucmVtYWluZGVyQWRkcmVzcywgcmVtYWluZGVyLCB0YWcsIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWwgZnVuY3Rpb24gZm9yIHNpZ25pbmcgaW5wdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnNpZ25JbnB1dHMoc2VlZCwgYnVuZGxlLCB0cmFuc2Zlck9wdGlvbnMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIGlucHV0cywgYWRkZWRITUFDKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlbWFpbmRlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWF4KGlucHV0c1trXS5rZXlJbmRleCwgc3RhcnRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3Nlc1RvVW51c2VkKHNlZWQsIHN0YXJ0SW5kZXgsIGZhbHNlLCB0cmFuc2Zlck9wdGlvbnMuc2VjdXJpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRzID0gTWF0aC5mbG9vcih0aGlzLl90aW1lU2VydmljZS5tc1NpbmNlRXBvY2goKSAvIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWFpbmRlciBidW5kbGUgZW50cnlcclxuICAgICAgICAgICAgICAgICAgICBidW5kbGUuYWRkVHJhbnNhY3Rpb25zKDEsIGFkZHJlc3Nlc1thZGRyZXNzZXMubGVuZ3RoIC0gMV0sIHJlbWFpbmRlciwgdGFnLCB0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWwgZnVuY3Rpb24gZm9yIHNpZ25pbmcgaW5wdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnNpZ25JbnB1dHMoc2VlZCwgYnVuZGxlLCB0cmFuc2Zlck9wdGlvbnMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIGlucHV0cywgYWRkZWRITUFDKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHJlbWFpbmRlciwgZG8gbm90IGFkZCB0cmFuc2FjdGlvbiB0byBidW5kbGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbHkgc2lnbiBhbmQgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnNpZ25JbnB1dHMoc2VlZCwgYnVuZGxlLCB0cmFuc2Zlck9wdGlvbnMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIGlucHV0cywgYWRkZWRITUFDKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIG11bHRpcGxlIGlucHV0cyBwcm92aWRlZCwgc3VidHJhY3QgdGhlIHRvdGFsVHJhbnNmZXJWYWx1ZSBieVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGlucHV0cyBiYWxhbmNlXHJcbiAgICAgICAgICAgICAgICB0b3RhbFRyYW5zZmVyVmFsdWUgLT0gaW5wdXRzW2ldLmJhbGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyogQGludGVybmFsICovXHJcblRyYW5zYWN0aW9uQ2xpZW50Lk5VTExfSEFTSF9UUllURVMgPSBcIjlcIi5yZXBlYXQoMjQzKTtcclxuLyogQGludGVybmFsICovXHJcblRyYW5zYWN0aW9uQ2xpZW50Lk1BWF9JTlBVVFMgPSA1MDA7XHJcbmV4cG9ydHMuVHJhbnNhY3Rpb25DbGllbnQgPSBUcmFuc2FjdGlvbkNsaWVudDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKaGJuTmhZM1JwYjI1RGJHbGxiblF1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZkSEpoYm5OaFkzUnBiMjV6TDNSeVlXNXpZV04wYVc5dVEyeHBaVzUwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1FVRlZRU3d3UlVGQmRVVTdRVUZEZGtVc05FVkJRWGxGTzBGQlEzcEZMRFJGUVVGNVJUdEJRVWw2UlN4M1JVRkJjVVU3UVVGRGNrVXNLMFpCUVRSR08wRkJRelZHTERKRlFVRjNSVHRCUVVONFJTeDVSRUZCYzBRN1FVRkRkRVFzZDBaQlFYRkdPMEZCUlhKR0xDdEVRVUUwUkR0QlFVTTFSQ3dyUlVGQk5FVTdRVUZETlVVc05rUkJRVEJFTzBGQlF6RkVMSGxFUVVGelJEdEJRVU4wUkN3eVJFRkJkMFE3UVVGRmVFUXNkVVJCUVc5RU8wRkJRM0JFTEhWRlFVRnZSVHRCUVVOd1JTeHBSVUZCT0VRN1FVRkRPVVFzTWtSQlFYZEVPMEZCUTNoRUxEWkVRVUV3UkR0QlFVTXhSQ3d3UkVGQmRVUTdRVUZEZGtRc05FUkJRWGxFTzBGQlEzcEVMREJFUVVGMVJEdEJRVXQyUkN4eFJFRkJhMFE3UVVGRmJFUTdPMGRCUlVjN1FVRkRTRHRKUVhOQ1NUczdPenM3T3p0UFFVOUhPMGxCUTBnc1dVRkJXU3hUUVVGeFFpeEZRVU55UWl4WFFVRXdRaXhGUVVNeFFpeFhRVUV3UWl4RlFVTXhRaXh4UWtGQk9FTXNSVUZET1VNc1RVRkJaMEk3VVVGRGVFSXNTVUZCU1N3eVFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eFRRVUZUTEVOQlFVTXNSVUZCUlR0WlFVTnFReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4cFEwRkJhVU1zUTBGQlF5eERRVUZETzFOQlF6bEVPMUZCUTBRc1NVRkJTU3hEUVVGRExGVkJRVlVzUjBGQlJ5eFRRVUZUTEVOQlFVTTdVVUZETlVJc1NVRkJTU3hEUVVGRExGbEJRVmtzUjBGQlJ5eFhRVUZYTEVsQlFVa3NTVUZCU1N3clFrRkJZeXhEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETzFGQlEycEZMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzVjBGQlZ5eEpRVUZKTEVsQlFVa3NlVUpCUVZjc1JVRkJSU3hEUVVGRE8xRkJRM0pFTEVsQlFVa3NRMEZCUXl4elFrRkJjMElzUjBGQlJ5eHhRa0ZCY1VJc1NVRkJTU3hKUVVGSkxEWkRRVUZ4UWl4RlFVRkZMRU5CUVVNN1VVRkRia1lzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4TlFVRk5MRWxCUVVrc1NVRkJTU3gxUWtGQlZTeEZRVUZGTEVOQlFVTTdTVUZET1VNc1EwRkJRenRKUVVWRU96czdUMEZIUnp0SlFVTkpMRXRCUVVzc1EwRkJReXg1UWtGQmVVSTdVVUZEYkVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNiVVJCUVcxRUxFTkJRVU1zUTBGQlF6dFJRVU4yUlN4TlFVRk5MRkZCUVZFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNUMEZCVHl4RlFVRkZMRU5CUVVNN1VVRkRha1FzU1VGQlNTeFJRVUZSTEVsQlFVa3NVVUZCVVN4RFFVRkRMRTFCUVUwc1JVRkJSVHRaUVVNM1FpeE5RVUZOTEVsQlFVa3NSMEZCUnl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRmRCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrWXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zYlVSQlFXMUVMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRE4wVXNUMEZCVHl4SlFVRkpMRU5CUVVNN1UwRkRaanRoUVVGTk8xbEJRMGdzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc2JVUkJRVzFFTEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1dVRkRNMFVzVDBGQlR5eEZRVUZGTEVOQlFVTTdVMEZEWWp0SlFVTk1MRU5CUVVNN1NVRkZSRHM3T3pzN096czdPMDlCVTBjN1NVRkRTU3hMUVVGTExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1QwRkJaMElzUlVGQlJTeFRRVUZ4UWl4RlFVRkZMRWxCUVZrc1JVRkJSU3hUUVVGclFqdFJRVU51Unl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5d3dRMEZCTUVNc1JVRkJSU3hQUVVGUExFVkJRVVVzVTBGQlV5eEZRVUZGTEVsQlFVa3NSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVWdVJ5eE5RVUZOTEZOQlFWTXNSMEZCUnl4UFFVRlBMRXRCUVVzc1UwRkJVeXhKUVVGSkxFOUJRVThzUzBGQlN5eEpRVUZKTEVsQlFVa3NUMEZCVHl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGJFWXNUVUZCVFN4WlFVRlpMRWRCUVVjc1UwRkJVeXhMUVVGTExGTkJRVk1zU1VGQlNTeFRRVUZUTEV0QlFVc3NTVUZCU1N4SlFVRkpMRk5CUVZNc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETzFGQlF6TkdMRTFCUVUwc1QwRkJUeXhIUVVGSExFbEJRVWtzUzBGQlN5eFRRVUZUTEVsQlFVa3NTVUZCU1N4TFFVRkxMRWxCUVVrc1NVRkJTU3hKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTjJSU3hOUVVGTkxGbEJRVmtzUjBGQlJ5eFRRVUZUTEV0QlFVc3NVMEZCVXl4SlFVRkpMRk5CUVZNc1MwRkJTeXhKUVVGSkxFbEJRVWtzVTBGQlV5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkZNMFlzU1VGQlNTeFRRVUZUTEVsQlFVa3NRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVWQlFVVXNWMEZCU1N4RFFVRkRMRVZCUVVVN1dVRkRiRVFzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc01rTkJRVEpETEVOQlFVTXNRMEZCUXp0VFFVTjRSVHRSUVVWRUxFbEJRVWtzV1VGQldTeEpRVUZKTEVOQlFVTXNlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zVTBGQlV5eEZRVUZGTEdsQ1FVRlBMRU5CUVVNc1JVRkJSVHRaUVVNeFJDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXhuUkVGQlowUXNRMEZCUXl4RFFVRkRPMU5CUXpkRk8xRkJSVVFzU1VGQlNTeFBRVUZQTEVsQlFVa3NRMEZCUXl4NVFrRkJWeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlFVVXNVMEZCUnl4RFFVRkRMRVZCUVVVN1dVRkROVU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2RVTkJRWFZETEVOQlFVTXNRMEZCUXp0VFFVTndSVHRSUVVWRUxFbEJRVWtzV1VGQldTeEpRVUZKTEVOQlFVTXNlVUpCUVZjc1EwRkJReXhQUVVGUExFTkJRVU1zVTBGQlV5eEZRVUZGTEZkQlFVa3NRMEZCUXl4RlFVRkZPMWxCUTNaRUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMRFpEUVVFMlF5eERRVUZETEVOQlFVTTdVMEZETVVVN1VVRkZSQ3hKUVVGSkxFTkJRVU1zVTBGQlV5eEpRVUZKTEVOQlFVTXNXVUZCV1N4SlFVRkpMRU5CUVVNc1QwRkJUeXhKUVVGSkxFTkJRVU1zV1VGQldTeEZRVUZGTzFsQlF6RkVMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhkRVFVRjNSQ3hEUVVGRExFTkJRVU03VTBGRGNrWTdVVUZGUkN4TlFVRk5MRTlCUVU4c1IwRkJOa0k3V1VGRGRFTXNUMEZCVHl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRExFMUJRVTBzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFRRVUZUTzFsQlEzQkdMRk5CUVZNc1JVRkJSU3haUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVVVzUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXp0WlFVTTNSaXhKUVVGSkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRk5CUVZNN1dVRkRkRVVzVTBGQlV5eEZRVUZGTEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eFJRVUZSTEVOQlFVTXNSVUZCUlN4RFFVRkRMRkZCUVZFc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhUUVVGVE8xTkJRMnhITEVOQlFVTTdVVUZGUml4TlFVRk5MRkZCUVZFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEYWtVc1NVRkJTU3hSUVVGUkxFbEJRVWtzVVVGQlVTeERRVUZETEUxQlFVMHNSVUZCUlR0WlFVTTNRaXhOUVVGTkxFbEJRVWtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEZkQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia1lzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc01FTkJRVEJETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRjRVVzVDBGQlR5eEpRVUZKTEVOQlFVTTdVMEZEWmp0aFFVRk5PMWxCUTBnc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNNRU5CUVRCRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdXVUZEYkVVc1QwRkJUeXhGUVVGRkxFTkJRVU03VTBGRFlqdEpRVU5NTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNTeExRVUZMTEVOQlFVTXNjMEpCUVhOQ0xFTkJRVU1zYVVKQlFYbENPMUZCUTNwRUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMR2RFUVVGblJDeEZRVUZGTEdsQ1FVRnBRaXhEUVVGRExFTkJRVU03VVVGRGRrWXNTVUZCU1N4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEdsQ1FVRnBRaXhGUVVGRkxGZEJRVWtzUTBGQlF5eEZRVUZGTzFsQlF5OURMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhGRVFVRnhSQ3hEUVVGRExFTkJRVU03VTBGRGJFWTdVVUZGUkN4TlFVRk5MRTlCUVU4c1IwRkJjMEk3V1VGREwwSXNUVUZCVFN4RlFVRkZMR2xDUVVGcFFpeERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRUUVVOd1JTeERRVUZETzFGQlJVWXNUVUZCVFN4UlFVRlJMRWRCUVVjc1RVRkJUU3hKUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVNeFJDeEpRVUZKTEZGQlFWRXNTVUZCU1N4UlFVRlJMRU5CUVVNc1RVRkJUU3hGUVVGRk8xbEJRemRDTEUxQlFVMHNTVUZCU1N4SFFVRkhMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4RlFVRkZMRU5CUVVNc2VVSkJRVmNzUTBGQlF5eFZRVUZWTEVOQlFVTXNaVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VZc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNaMFJCUVdkRUxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdXVUZETVVVc1QwRkJUeXhKUVVGSkxFTkJRVU03VTBGRFpqdGhRVUZOTzFsQlEwZ3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zWjBSQlFXZEVMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03V1VGRGVFVXNUMEZCVHl4RlFVRkZMRU5CUVVNN1UwRkRZanRKUVVOTUxFTkJRVU03U1VGRlJEczdPMDlCUjBjN1NVRkRTU3hMUVVGTExFTkJRVU1zYTBKQlFXdENMRU5CUVVNc2FVSkJRWGxDTzFGQlEzSkVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETERKRFFVRXlReXhEUVVGRExFTkJRVU03VVVGREwwUXNTVUZCU1N4RFFVRkRMSGxDUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEdsQ1FVRnBRaXhGUVVGRkxGZEJRVWtzUTBGQlF5eEZRVUZGTzFsQlF5OURMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhGRVFVRnhSQ3hEUVVGRExFTkJRVU03VTBGRGJFWTdVVUZGUkN4TlFVRk5MRkZCUVZFc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNWMEZCVnl4RlFVRkZMRU5CUVVNN1VVRkRja1FzU1VGQlNTeFJRVUZSTEVsQlFVa3NNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeERRVUZETERaQ1FVRTJRaXhEUVVGRExFVkJRVVU3V1VGRE5VVXNUVUZCVFN4UFFVRlBMRWRCUVN0Q08yZENRVU40UXl4WlFVRlpMRVZCUVVVc2FVSkJRV2xDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8yZENRVU4yUlN4SlFVRkpMRVZCUVVVc1EwRkJReXhSUVVGUkxFTkJRVU1zTmtKQlFUWkNMRU5CUVVNN1lVRkRha1FzUTBGQlF6dFpRVU5HTEUxQlFVMHNVVUZCVVN4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eHJRa0ZCYTBJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU51UlN4SlFVRkpMRkZCUVZFc1NVRkJTU3hSUVVGUkxFTkJRVU1zVFVGQlRTeEZRVUZGTzJkQ1FVTTNRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl3eVEwRkJNa01zUlVGQlJTeFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1owSkJRMmhHTEU5QlFVOHNVVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJRenRoUVVNeFFqdHBRa0ZCVFR0blFrRkRTQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl3eVEwRkJNa01zUlVGQlJTeEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkRia1VzVDBGQlR5eEZRVUZGTEVOQlFVTTdZVUZEWWp0VFFVTktPMkZCUVUwN1dVRkRTQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl3NFJFRkJPRVFzUTBGQlF5eERRVUZETzFOQlF6TkdPMGxCUTB3c1EwRkJRenRKUVVWRU96czdPenM3T3p0UFFWRkhPMGxCUTBrc1MwRkJTeXhEUVVGRExHRkJRV0VzUTBGQlF5eEpRVUZWTEVWQlFVVXNWVUZCYlVJc1JVRkJSU3hSUVVGcFFpeEZRVUZGTEdWQlFYbENMRVZCUVVVc1VVRkJNRUk3VVVGRGFFa3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zZFVOQlFYVkRMRVZCUVVVc1NVRkJTU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNaVUZCWlN4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8xRkJRMnhJTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNWMEZCU1N4RFFVRkRMRVZCUVVVN1dVRkRiRU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc0swSkJRU3RDTEVOQlFVTXNRMEZCUXp0VFFVTTFSRHRSUVVWRUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVlVzUlVGQlJTeE5RVUZOTEVOQlFVTXNSVUZCUlR0WlFVTXZSU3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4dFEwRkJiVU1zUlVGQlJTeEZRVUZGTEZWQlFWVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRhRVk3VVVGRlJDeE5RVUZOTEdWQlFXVXNSMEZCUnl4VlFVRlZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJSWGhETEVsQlFVa3NaVUZCWlN4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVOeVFpeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXcyUWtGQk5rSXNSVUZCUlN4RlFVRkZMR1ZCUVdVc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGREwwVTdVVUZGUkN4TlFVRk5MRmRCUVZjc1IwRkJSeXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRSUVVOeVJDeE5RVUZOTEdGQlFXRXNSMEZCUnl4UlFVRlJMRWxCUVVrc2FVTkJRV1VzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZGZWtRc1NVRkJTU3hUUVVGVExFTkJRVU03VVVGRFpDeEpRVUZKTEZkQlFWY3NSVUZCUlR0WlFVTmlMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hSUVVGUkxFZEJRVWNzUTBGQlF5eEZRVUZGTzJkQ1FVTnVSQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4dlEwRkJiME1zUlVGQlJTeEZRVUZGTEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1lVRkRMMFU3V1VGRlJDeE5RVUZOTEV0QlFVc3NSMEZCUnl4UlFVRlJMRWRCUVVjc1ZVRkJWU3hIUVVGSExFTkJRVU1zUTBGQlF6dFpRVU40UXl4SlFVRkpMRXRCUVVzc1NVRkJTU3hEUVVGRExFbEJRVWtzUzBGQlN5eEhRVUZITEdsQ1FVRnBRaXhEUVVGRExGVkJRVlVzUlVGQlJUdG5Ra0ZEY0VRc1RVRkJUU3hKUVVGSkxEWkNRVUZoTEVOQlFVTXNaME5CUVdkRExHbENRVUZwUWl4RFFVRkRMRlZCUVZVc1JVRkJSU3hGUVVGRkxFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXp0aFFVTjBSenRaUVVWRUxGTkJRVk1zUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eEpRVUZKTEVWQlFVVXNWVUZCVlN4RlFVRkZMRkZCUVZFc1JVRkJSU3hsUVVGbExFVkJRVVVzWVVGQllTeERRVUZETEVOQlFVTTdVMEZETVVjN1lVRkJUVHRaUVVOSUxGTkJRVk1zUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUTBGQlF5eEpRVUZKTEVWQlFVVXNWVUZCVlN4RlFVRkZMR1ZCUVdVc1JVRkJSU3hoUVVGaExFTkJRVU1zUTBGQlF6dFRRVU5xUnp0UlFVVkVMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEhWRFFVRjFReXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFGQlEzUkZMRTlCUVU4c1UwRkJVeXhEUVVGRE8wbEJRM0pDTEVOQlFVTTdTVUZGUkRzN096czdPenM3VDBGUlJ6dEpRVU5KTEV0QlFVc3NRMEZCUXl4dFFrRkJiVUlzUTBGQlF5eEpRVUZWTEVWQlFVVXNWVUZCYTBJc1JVRkJSU3hSUVVGblFpeEZRVUZGTEdWQlFYZENMRVZCUVVVc1VVRkJlVUk3VVVGRGJFa3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zTmtOQlFUWkRMRVZCUVVVc1NVRkJTU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNaVUZCWlN4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8xRkJSWGhJTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNWMEZCU1N4RFFVRkRMRVZCUVVVN1dVRkRiRU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc0swSkJRU3RDTEVOQlFVTXNRMEZCUXp0VFFVTTFSRHRSUVVORUxFbEJRVWtzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRk5CUVZNc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeFZRVUZWTEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUTNaRUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMSE5EUVVGelF5eEZRVUZGTEVWQlFVVXNWVUZCVlN4RlFVRkZMRU5CUVVNc1EwRkJRenRUUVVOdVJqdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4UlFVRlJMRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRMjVFTEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHOURRVUZ2UXl4RlFVRkZMRVZCUVVVc1VVRkJVU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFRRVU12UlR0UlFVTkVMRTFCUVUwc1MwRkJTeXhIUVVGSExGRkJRVkVzUjBGQlJ5eFZRVUZWTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTNoRExFbEJRVWtzUzBGQlN5eEpRVUZKTEVOQlFVTXNTVUZCU1N4TFFVRkxMRWRCUVVjc2FVSkJRV2xDTEVOQlFVTXNWVUZCVlN4RlFVRkZPMWxCUTNCRUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMR2REUVVGblF5eHBRa0ZCYVVJc1EwRkJReXhWUVVGVkxFVkJRVVVzUlVGQlJTeEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRkRWM3VVVGRFJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NVVUZCVVN4SFFVRkhMRU5CUVVNc1NVRkJTU3hSUVVGUkxFZEJRVWNzUTBGQlF5eEZRVUZGTzFsQlEyNUZMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhORFFVRnpReXhGUVVGRkxFVkJRVVVzVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0VFFVTnFSanRSUVVWRUxFMUJRVTBzVTBGQlV5eEhRVUZqTEVWQlFVVXNRMEZCUXp0UlFVVm9ReXhMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1MwRkJTeXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlF6VkNMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4SlFVRkpMRVZCUVVVc1ZVRkJWU3hIUVVGSExFTkJRVU1zUlVGQlJTeFJRVUZSTEVWQlFVVXNaVUZCWlN4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVONlJqdFJRVVZFTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExEWkRRVUUyUXl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJRelZGTEU5QlFVOHNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUlVRN096czdPenM3VDBGUFJ6dEpRVU5KTEV0QlFVc3NRMEZCUXl4dlFrRkJiMElzUTBGQlF5eEpRVUZWTEVWQlFVVXNWVUZCYTBJc1JVRkJSU3hsUVVGM1FpeEZRVUZGTEZGQlFYbENPMUZCUTJwSUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRGhEUVVFNFF5eEZRVUZGTEVsQlFVa3NSVUZCUlN4VlFVRlZMRVZCUVVVc1pVRkJaU3hGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzFGQlF5OUhMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRVZCUVVVc1YwRkJTU3hEUVVGRExFVkJRVVU3V1VGRGJFTXNUVUZCVFN4SlFVRkpMRFpDUVVGaExFTkJRVU1zSzBKQlFTdENMRU5CUVVNc1EwRkJRenRUUVVNMVJEdFJRVU5FTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExGTkJRVk1zUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4VlFVRlZMRWRCUVVjc1EwRkJReXhGUVVGRk8xbEJRM1pFTEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExITkRRVUZ6UXl4RlFVRkZMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFRRVU51Ump0UlFVTkVMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hSUVVGUkxFZEJRVWNzUTBGQlF5eEpRVUZKTEZGQlFWRXNSMEZCUnl4RFFVRkRMRVZCUVVVN1dVRkRia1VzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2MwTkJRWE5ETEVWQlFVVXNSVUZCUlN4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRMnBHTzFGQlJVUXNTVUZCU1N4bFFVRmxMRWRCUVVjc1ZVRkJWU3hEUVVGRE8xRkJRMnBETEVsQlFVa3NUVUZCVFN4RFFVRkRPMUZCUTFnc1RVRkJUU3hUUVVGVExFZEJRVWNzUlVGQlJTeERRVUZETzFGQlJYSkNMRWRCUVVjN1dVRkRReXhOUVVGTkxFOUJRVThzUjBGQlJ5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hsUVVGbExFVkJRVVVzUlVGQlJTeFJRVUZSTEVWQlFVVXNaVUZCWlN4RFFVRkRMRU5CUVVNN1dVRkZla1lzVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRaUVVWNFFpeE5RVUZOTEdsQ1FVRnBRaXhIUVVGSExFOUJRVThzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRaUVVWNFJDeE5RVUZOTEdkQ1FVRm5RaXhIUVVGdFF6dG5Ra0ZEY2tRc1UwRkJVeXhGUVVGRkxFTkJRVU1zYVVKQlFXbENMRU5CUVVNN1lVRkRha01zUTBGQlF6dFpRVVZHTEUxQlFVMHNhVUpCUVdsQ0xFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMSE5DUVVGelFpeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU03V1VGRmVrWXNUVUZCVFN4SFFVRkhMR2xDUVVGcFFpeEpRVUZKTEdsQ1FVRnBRaXhEUVVGRExFMUJRVTBzU1VGQlNTeHBRa0ZCYVVJc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTTdXVUZEY0Vrc1NVRkJTU3hEUVVGRExFMUJRVTBzUlVGQlJUdG5Ra0ZEVkN4TlFVRk5MSFZDUVVGMVFpeEhRVUUyUWp0dlFrRkRkRVFzVTBGQlV5eEZRVUZGTEVOQlFVTXNhVUpCUVdsQ0xFTkJRVU03YVVKQlEycERMRU5CUVVNN1owSkJSVVlzVFVGQlRTeFpRVUZaTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMSFZDUVVGMVFpeERRVUZETEVOQlFVTTdaMEpCUlhKR0xFMUJRVTBzUjBGQlJ5eFpRVUZaTEVsQlFVa3NXVUZCV1N4RFFVRkRMRTFCUVUwc1NVRkJTU3haUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNN1lVRkRiRVk3VTBGRFNpeFJRVU5OTEUxQlFVMHNSVUZCUlR0UlFVVm1MRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETERoRFFVRTRReXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFGQlF6ZEZMRTlCUVU4c1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXp0SlFVTjBReXhEUVVGRE8wbEJSVVE3T3pzN096czdPMDlCVVVjN1NVRkRTU3hMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFWVXNSVUZCUlN4VlFVRnJRaXhGUVVGRkxGRkJRV2RDTEVWQlFVVXNVVUZCZVVJc1JVRkJSU3hoUVVGeFFqdFJRVU55U0N4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eHRRMEZCYlVNc1JVRkJSU3hKUVVGSkxFVkJRVVVzVlVGQlZTeEZRVUZGTEZGQlFWRXNSVUZCUlN4UlFVRlJMRVZCUVVVc1lVRkJZU3hEUVVGRExFTkJRVU03VVVGRk5VY3NTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NSVUZCUlN4WFFVRkpMRU5CUVVNc1JVRkJSVHRaUVVOc1F5eE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXdyUWtGQkswSXNRMEZCUXl4RFFVRkRPMU5CUXpWRU8xRkJRMFFzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEZWQlFWVXNSMEZCUnl4RFFVRkRMRVZCUVVVN1dVRkRka1FzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2MwTkJRWE5ETEVWQlFVVXNSVUZCUlN4VlFVRlZMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRMjVHTzFGQlEwUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRkZCUVZFc1IwRkJSeXhEUVVGRExFbEJRVWtzVVVGQlVTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTnVSU3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4elEwRkJjME1zUlVGQlJTeEZRVUZGTEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRha1k3VVVGRFJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NZVUZCWVN4SFFVRkhMRU5CUVVNc1JVRkJSVHRaUVVNM1JDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXhuUTBGQlowTXNSVUZCUlN4RlFVRkZMR0ZCUVdFc1JVRkJSU3hEUVVGRExFTkJRVU03VTBGRGFFWTdVVUZGUkN4TlFVRk5MRk5CUVZNc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNTVUZCU1N4RlFVRkZMRlZCUVZVc1JVRkJSU3hSUVVGUkxFVkJRVVVzUzBGQlN5eEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMUZCUlhoR0xFMUJRVTBzVDBGQlR5eEhRVUYzUWp0WlFVTnFReXhUUVVGVExFVkJRVVVzVTBGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRaUVVNeFJDeFRRVUZUTEVWQlFVVXNSMEZCUnp0VFFVTnFRaXhEUVVGRE8xRkJSVVlzVFVGQlRTeFJRVUZSTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExGZEJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVVTFSQ3hOUVVGTkxFMUJRVTBzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZEYkVJc1NVRkJTU3haUVVGWkxFZEJRVWNzUTBGQlF5eERRVUZETzFGQlJYSkNMRWxCUVVrc1VVRkJVU3hGUVVGRk8xbEJRMVlzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExGTkJRVk1zUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1owSkJRM1pETEUxQlFVMHNUMEZCVHl4SFFVRkhMRkZCUVZFc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU51UkN4SlFVRkpMRTlCUVU4c1IwRkJSeXhEUVVGRExFVkJRVVU3YjBKQlEySXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhoUVVGTExFTkJRVU1zVlVGQlZTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hSUVVGUkxFVkJRVVVzVlVGQlZTeEhRVUZITEVOQlFVTXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU12UlN4WlFVRlpMRWxCUVVrc1QwRkJUeXhEUVVGRE8yOUNRVVY0UWl4SlFVRkpMR0ZCUVdFc1IwRkJSeXhEUVVGRExFbEJRVWtzV1VGQldTeEpRVUZKTEdGQlFXRXNSVUZCUlR0M1FrRkRjRVFzVFVGQlRUdHhRa0ZEVkR0cFFrRkRTanRoUVVOS08xTkJRMG83VVVGRlJDeE5RVUZOTEVsQlFVa3NSMEZCUnl4RlFVRkZMRTFCUVUwc1JVRkJSU3haUVVGWkxFVkJRVVVzUTBGQlF6dFJRVU4wUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eHRRMEZCYlVNc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVVUzUkN4SlFVRkpMR0ZCUVdFc1IwRkJSeXhEUVVGRExFbEJRVWtzV1VGQldTeEhRVUZITEdGQlFXRXNSVUZCUlR0WlFVTnVSQ3hOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl3MFJVRkJORVVzUlVGQlJTeEZRVUZGTEdGQlFXRXNSVUZCUlN4WlFVRlpMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRekZKTzFGQlJVUXNUMEZCVHl4SlFVRkpMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVVZFT3pzN096czdPenM3T3p0UFFWZEhPMGxCUTBrc1MwRkJTeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRWxCUVZVc1JVRkJSU3hUUVVGeFFpeEZRVUZGTEdWQlFXbERPMUZCUXpsR0xFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMREJEUVVFd1F5eEZRVUZGTEVsQlFVa3NSVUZCUlN4VFFVRlRMRVZCUVVVc1pVRkJaU3hEUVVGRExFTkJRVU03VVVGRmFFY3NTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NSVUZCUlN4WFFVRkpMRU5CUVVNc1JVRkJSVHRaUVVOc1F5eE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXdyUWtGQkswSXNRMEZCUXl4RFFVRkRPMU5CUXpWRU8xRkJSVVFzU1VGQlNTeERRVUZETEhsQ1FVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExGTkJRVk1zUlVGQlJTeHRRa0ZCVVN4RFFVRkRMRVZCUVVVN1dVRkRNME1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2IwUkJRVzlFTEVOQlFVTXNRMEZCUXp0VFFVTnFSanRSUVVWRUxFMUJRVTBzYjBKQlFXOUNMRWRCUVVjc1pVRkJaU3hKUVVGSkxFVkJRVVVzUTBGQlF6dFJRVU51UkN4dlFrRkJiMElzUTBGQlF5eFJRVUZSTEVkQlFVY3NiMEpCUVc5Q0xFTkJRVU1zVVVGQlVTeEpRVUZKTEdsRFFVRmxMRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJSWGhHTEUxQlFVMHNWMEZCVnl4SFFVRkhMR1ZCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTTdVVUZETVVNc1RVRkJUU3hQUVVGUExFZEJRVWNzUTBGQlF5d3lRa0ZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXh2UWtGQmIwSXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVOd1JTeEpRVUZKTEZOQlFWTXNSMEZCUnl4TFFVRkxMRU5CUVVNN1VVRkZkRUlzWjBSQlFXZEVPMUZCUTJoRUxGTkJRVk1zUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVN1dVRkRla0lzVVVGQlVTeERRVUZETEU5QlFVOHNSMEZCUnl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFTkJRVU03V1VGRGNrVXNVVUZCVVN4RFFVRkRMRWRCUVVjc1IwRkJSeXhSUVVGUkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEZOQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNN1dVRkZla01zU1VGQlNTeFBRVUZQTEVsQlFVa3NVVUZCVVN4RFFVRkRMRXRCUVVzc1IwRkJSeXhEUVVGRExFVkJRVVU3WjBKQlF5OUNMRkZCUVZFc1EwRkJReXhQUVVGUExFZEJRVWNzWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eG5Ra0ZCWjBJc1IwRkJSeXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRM1pITEZOQlFWTXNSMEZCUnl4SlFVRkpMRU5CUVVNN1lVRkRjRUk3VVVGRFRDeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMSE5DUVVGelFqdFJRVU4wUWl4TlFVRk5MRkZCUVZFc1IwRkJSeXd5UWtGQldTeERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzFGQlJURkZMRTFCUVUwc1RVRkJUU3hIUVVGSExGRkJRVkVzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZETDBJc1RVRkJUU3hQUVVGUExFZEJRVWNzVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXp0UlFVTnFReXhOUVVGTkxGVkJRVlVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNWVUZCVlN4RFFVRkRPMUZCUTNaRExFMUJRVTBzZVVKQlFYbENMRWRCUVVjc1VVRkJVU3hEUVVGRExIbENRVUY1UWl4RFFVRkRPMUZCUlhKRkxITkRRVUZ6UXp0UlFVTjBReXhKUVVGSkxGVkJRVlVzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZEYUVJc1owTkJRV2RETzFsQlEyaERMRGhEUVVFNFF6dFpRVU01UXl4SlFVRkpMRzlDUVVGdlFpeERRVUZETEUxQlFVMHNSVUZCUlR0blFrRkROMElzVFVGQlRTeFBRVUZQTEVkQlFYZENPMjlDUVVOcVF5eFRRVUZUTEVWQlFVVXNiMEpCUVc5Q0xFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1JVRkJSU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU03YjBKQlEzaEdMRk5CUVZNc1JVRkJSU3hIUVVGSE8ybENRVU5xUWl4RFFVRkRPMmRDUVVWR0xFMUJRVTBzVVVGQlVTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhYUVVGWExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdaMEpCUXpWRUxFMUJRVTBzWlVGQlpTeEhRVUZITEVWQlFVVXNRMEZCUXp0blFrRkRNMElzU1VGQlNTeFpRVUZaTEVkQlFVY3NRMEZCUXl4RFFVRkRPMmRDUVVOeVFpeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVVVGQlVTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3YjBKQlF5OURMRTFCUVUwc1QwRkJUeXhIUVVGSExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzI5Q1FVVnVSQ3hyUkVGQmEwUTdiMEpCUTJ4RUxFbEJRVWtzVDBGQlR5eEhRVUZITEVOQlFVTXNSVUZCUlR0M1FrRkRZaXhaUVVGWkxFbEJRVWtzVDBGQlR5eERRVUZETzNkQ1FVVjRRaXh2UWtGQmIwSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXp0M1FrRkZha1FzWlVGQlpTeERRVUZETEVsQlFVa3NRMEZCUXl4dlFrRkJiMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenQzUWtGRmNrUXNkVVZCUVhWRk8zZENRVU4yUlN4SlFVRkpMRmxCUVZrc1NVRkJTU3hWUVVGVkxFVkJRVVU3TkVKQlF6VkNMRTFCUVUwN2VVSkJRMVE3Y1VKQlEwbzdhVUpCUTBvN1owSkJSVVFzYTBOQlFXdERPMmRDUVVOc1F5eEpRVUZKTEZWQlFWVXNSMEZCUnl4WlFVRlpMRVZCUVVVN2IwSkJRek5DTEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExHbEdRVUZwUml4RFFVRkRMRU5CUVVNN2FVSkJRemxITzJkQ1FVVkVMRTFCUVUwc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RlFVRkZMRzlDUVVGdlFpeEZRVUZGTEdWQlFXVXNSVUZCUlN4NVFrRkJlVUlzUlVGQlJTeFZRVUZWTEVWQlFVVXNUMEZCVHl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8yRkJRek5KTzJsQ1FVRk5PMmRDUVVOSUxEUkRRVUUwUXp0blFrRkROVU1zVFVGQlRTeGpRVUZqTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVWQlFVVXNVMEZCVXl4RlFVRkZMRzlDUVVGdlFpeERRVUZETEZGQlFWRXNSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRuUWtGRk0wY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFbEJRVWtzUlVGQlJTeE5RVUZOTEVWQlFVVXNiMEpCUVc5Q0xFVkJRVVVzWTBGQll5eERRVUZETEUxQlFVMHNSVUZCUlN4NVFrRkJlVUlzUlVGQlJTeFZRVUZWTEVWQlFVVXNUMEZCVHl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8yRkJRMnBLTzFOQlEwbzdZVUZCVFR0WlFVTklMR3RGUVVGclJUdFpRVU5zUlN3eVFrRkJXU3hEUVVGRExHTkJRV01zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0WlFVTndReXhOUVVGTkxFTkJRVU1zTkVKQlFUUkNMRU5CUVVNc2VVSkJRWGxDTEVOQlFVTXNRMEZCUXp0VFFVTnNSVHRSUVVWRUxFMUJRVTBzUTBGQlF5eFpRVUZaTEVkQlFVY3NUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF6dFJRVVZ3UkN4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5d3dRMEZCTUVNc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVVYwUlN4UFFVRlBMRTFCUVUwc1EwRkJRenRKUVVOc1FpeERRVUZETzBsQlJVUTdPenM3T3pzN1QwRlBSenRKUVVOSkxFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTXNUVUZCWXl4RlFVRkZMRXRCUVdFc1JVRkJSU3hyUWtGQk1FSXNSVUZCUlN4VFFVRm5RanRSUVVOdVJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXgzUTBGQmQwTXNSVUZCUlN4TlFVRk5MRVZCUVVVc1MwRkJTeXhGUVVGRkxHdENRVUZyUWl4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJSVEZITEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNaVUZCVFN4RFFVRkRMRVZCUVVVN1dVRkRkRU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc05FTkJRVFJETEVOQlFVTXNRMEZCUXp0VFFVTjZSVHRSUVVWRUxFbEJRVWtzUTBGQlF5eDVRa0ZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zV1VGQldTeEZRVUZGTEhsQ1FVRlhMRU5CUVVNc1JVRkJSVHRaUVVONFJDeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXc0UkVGQk9FUXNRMEZCUXl4RFFVRkRPMU5CUXpOR08xRkJSVVFzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NTVUZCU1N4RFFVRkRMRVZCUVVVN1dVRkRPVU1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc1owTkJRV2RETEVWQlFVVXNSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRE8xTkJRM2hGTzFGQlJVUXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzYTBKQlFXdENMRWxCUVVrc1EwRkJReXhGUVVGRk8xbEJRM2hGTEUxQlFVMHNTVUZCU1N3MlFrRkJZU3hEUVVGRExEWkRRVUUyUXl4RlFVRkZMRVZCUVVVc2EwSkJRV3RDTEVWQlFVVXNRMEZCUXl4RFFVRkRPMU5CUTJ4SE8xRkJSVVFzVFVGQlRTdzBRa0ZCTkVJc1IwRkJjVU03V1VGRGJrVXNTMEZCU3p0WlFVTk1MRk5CUVZNc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXp0VFFVTnlSU3hEUVVGRE8xRkJSVVlzVFVGQlRTeHhRa0ZCY1VJc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU1zTkVKQlFUUkNMRU5CUVVNc1EwRkJRenRSUVVVelJ5eE5RVUZOTEZOQlFWTXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhaUVVGWkxFTkJRVU1zUjBGQlJ5eERRVUZETEZkQlFVa3NRMEZCUXl4VlFVRlZMRU5CUVVNc1pVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRMRVZCUXpGRkxGZEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNaVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eERRVUZETEVWQlF6TkZMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVWQlF6RkRMR3RDUVVGclFpeERRVUZETEVOQlFVTTdVVUZGYkVVc1RVRkJUU3hsUVVGbExFZEJRVWNzVTBGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4WlFVRlpMRU5CUVVNc1JVRkJSU3hEUVVGRExIbENRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRk5VWXNUVUZCVFN4VFFVRlRMRWRCUVVjc1NVRkJTU3hsUVVGTkxFVkJRVVVzUTBGQlF6dFJRVU12UWl4VFFVRlRMRU5CUVVNc1dVRkJXU3hIUVVGSExHVkJRV1VzUTBGQlF6dFJRVU42UXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eDNRMEZCZDBNc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF6dFJRVU4yUlN4UFFVRlBMRk5CUVZNc1EwRkJRenRKUVVOeVFpeERRVUZETzBsQlJVUTdPenM3T3pzN1QwRlBSenRKUVVOSkxFdEJRVXNzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhOUVVGakxFVkJRVVVzUzBGQllTeEZRVUZGTEd0Q1FVRXdRaXhGUVVGRkxGTkJRV2RDTzFGQlEzSkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETERCRFFVRXdReXhGUVVGRkxFMUJRVTBzUlVGQlJTeExRVUZMTEVWQlFVVXNhMEpCUVd0Q0xFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTTdVVUZGTlVjc1RVRkJUU3d3UWtGQk1FSXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zVFVGQlRTeEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVVXpSeXhOUVVGTkxIZENRVUYzUWl4SFFVRTRRanRaUVVONFJDeE5RVUZOTEVWQlFVVXNNRUpCUVRCQ0xFTkJRVU1zV1VGQldTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRUUVVOd1JpeERRVUZETzFGQlJVWXNUVUZCVFN4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExHbENRVUZwUWl4RFFVRkRMSGRDUVVGM1FpeERRVUZETEVOQlFVTTdVVUZGYkVVc1RVRkJUU3cwUWtGQk5FSXNSMEZCYTBNN1dVRkRhRVVzVFVGQlRTeEZRVUZGTEhkQ1FVRjNRaXhEUVVGRExFMUJRVTA3VTBGRE1VTXNRMEZCUXp0UlFVVkdMRTFCUVUwc1NVRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXcwUWtGQk5FSXNRMEZCUXl4RFFVRkRPMUZCUlRGRkxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMREJEUVVFd1F5eEZRVUZGTERCQ1FVRXdRaXhEUVVGRExFTkJRVU03VVVGRE1VWXNUMEZCVHl3d1FrRkJNRUlzUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUlVRN096czdPenM3T3pzN096czdUMEZoUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zU1VGQlZTeEZRVUZGTEV0QlFXRXNSVUZCUlN4clFrRkJNRUlzUlVGQlJTeFRRVUZ4UWl4RlFVRkZMR1ZCUVdsRExFVkJRVVVzVTBGQlowSTdVVUZEZGtvc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNjME5CUVhORExFVkJRVVVzU1VGQlNTeEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVWQlFVVXNaVUZCWlN4RlFVRkZMRk5CUVZNc1EwRkJReXhEUVVGRE8xRkJSV3hKTEUxQlFVMHNZMEZCWXl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRWxCUVVrc1JVRkJSU3hUUVVGVExFVkJRVVVzWlVGQlpTeERRVUZETEVOQlFVTTdVVUZGY2tZc1RVRkJUU3hWUVVGVkxFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zWTBGQll5eEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVTnlSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4elEwRkJjME1zUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0UlFVTjBSU3hQUVVGUExGVkJRVlVzUTBGQlF6dEpRVU4wUWl4RFFVRkRPMGxCUlVRN096czdUMEZKUnp0SlFVTkpMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zWlVGQmNVSTdVVUZETTBNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNjME5CUVhORExFVkJRVVVzWlVGQlpTeERRVUZETEVOQlFVTTdVVUZGTTBVc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMR1ZCUVdVc1JVRkJSU3hYUVVGSkxFTkJRVU1zUlVGQlJUdFpRVU0zUXl4TlFVRk5MRWxCUVVrc05rSkJRV0VzUTBGQlF5eHZSRUZCYjBRc1EwRkJReXhEUVVGRE8xTkJRMnBHTzFGQlJVUXNUVUZCVFN4MVFrRkJkVUlzUjBGQk5rSTdXVUZEZEVRc1MwRkJTeXhGUVVGRkxFTkJRVU1zWlVGQlpTeERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xTkJRMnBFTEVOQlFVTTdVVUZGUml4TlFVRk5MSGRDUVVGM1FpeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4MVFrRkJkVUlzUTBGQlF5eERRVUZETzFGQlEycEhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEhORFFVRnpReXhGUVVGRkxIZENRVUYzUWl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRekZHTEU5QlFVOHNkMEpCUVhkQ0xFTkJRVU1zUzBGQlN5eERRVUZETzBsQlF6RkRMRU5CUVVNN1NVRkZSRHM3T3p0UFFVbEhPMGxCUTBrc1MwRkJTeXhEUVVGRExHTkJRV01zUTBGQlF5eFRRVUZ2UWp0UlFVTTFReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4M1EwRkJkME1zUlVGQlJTeFRRVUZUTEVOQlFVTXNRMEZCUXp0UlFVTjJSU3hKUVVGSkxFTkJRVU1zZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1UwRkJVeXhGUVVGRkxHbENRVUZQTEVOQlFVTXNSVUZCUlR0WlFVTXhReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4cFJFRkJhVVFzUTBGQlF5eERRVUZETzFOQlF6bEZPMUZCUlVRc1RVRkJUU3hYUVVGWExFZEJRV3RETEVWQlFVVXNRMEZCUXp0UlFVVjBSQ3hMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1UwRkJVeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0WlFVTjJReXhOUVVGTkxHRkJRV0VzUjBGQlJ5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdXVUZEZWtRc1YwRkJWeXhEUVVGRExHRkJRV0VzUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXp0VFFVTnVRenRSUVVWRUxFMUJRVTBzV1VGQldTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMSE5DUVVGelFpeERRVUZETEZOQlFWTXNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVVM1JTeE5RVUZOTEdsQ1FVRnBRaXhIUVVGWExFVkJRVVVzUTBGQlF6dFJRVU55UXl4WlFVRlpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEVWQlFVVTdXVUZEYWtNc1NVRkJTU3hYUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4SFFVRkhMRU5CUVVNc1JVRkJSVHRuUWtGRGJFTXNUVUZCVFN4VFFVRlRMRWRCUVVjc1YwRkJWeXhEUVVGRExFOUJRVThzUTBGQlF6dG5Ra0ZEZEVNc1RVRkJUU3hOUVVGTkxFZEJRVWNzY1VOQlFXbENMRU5CUVVNc1NVRkJTU3hEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETzJkQ1FVVnVSQ3hYUVVGWExFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMmRDUVVVeFJDeHBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdZVUZEYkVNN1VVRkRUQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVVZJTEVsQlFVa3NUMEZCYTBJc1EwRkJRenRSUVVOMlFpeEpRVUZKTEdsQ1FVRnBRaXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVVTdXVUZET1VJc1RVRkJUU3hsUVVGbExFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNhMEpCUVd0Q0xFTkJRVU1zYVVKQlFXbENMRU5CUVVNc1EwRkJRenRaUVVONlJTeFBRVUZQTEVkQlFVY3NVMEZCVXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZGTzJkQ1FVTm9ReXhKUVVGSkxHTkJRV01zUjBGQlJ5eEpRVUZKTEVOQlFVTTdaMEpCUlRGQ0xFMUJRVTBzUjBGQlJ5eEhRVUZITEZkQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNRMEZCUXp0blFrRkZka1FzUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFZEJRVWNzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN2IwSkJRMnBETEUxQlFVMHNUMEZCVHl4SFFVRkhMR2xDUVVGcFFpeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEYkVRc1kwRkJZeXhIUVVGSExFTkJRVU1zWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMjlDUVVNelF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RlFVRkZPM2RDUVVOcVFpeE5RVUZOTzNGQ1FVTlVPMmxDUVVOS08yZENRVVZFTEU5QlFVOHNZMEZCWXl4RFFVRkRPMWxCUXpGQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFOQlEwNDdZVUZCVFR0WlFVTklMRTlCUVU4c1IwRkJSeXhGUVVGRkxFTkJRVU03V1VGRllpeExRVUZMTEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzVTBGQlV5eERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSVHRuUWtGRGRrTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dGhRVU4wUWp0VFFVTktPMUZCUlVRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNkME5CUVhkRExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEY2tVc1QwRkJUeXhQUVVGUExFTkJRVU03U1VGRGJrSXNRMEZCUXp0SlFVVkVPenM3T3pzN096czdPenM3TzA5QllVYzdTVUZEU1N4TFFVRkxMRU5CUVVNc2EwSkJRV3RDTEVOQlFVTXNaVUZCY1VJc1JVRkJSU3hMUVVGaExFVkJRVVVzYTBKQlFUQkNMRVZCUVVVc1UwRkJjVUlzUlVGQlJTeGpRVUVyUWp0UlFVTndTaXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl3MFEwRkJORU1zUlVGQlJTeGxRVUZsTEVWQlFVVXNTMEZCU3l4RlFVRkZMR3RDUVVGclFpeEZRVUZGTEZOQlFWTXNSVUZCUlN4alFVRmpMRU5CUVVNc1EwRkJRenRSUVVWMlNTeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zWlVGQlpTeEZRVUZGTEZkQlFVa3NRMEZCUXl4RlFVRkZPMWxCUXpkRExFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMRzlFUVVGdlJDeERRVUZETEVOQlFVTTdVMEZEYWtZN1VVRkZSQ3hKUVVGSkxFTkJRVU1zTWtKQlFWa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUzBGQlN5eEpRVUZKTEVOQlFVTXNSVUZCUlR0WlFVTTVReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4blEwRkJaME1zUlVGQlJTeEZRVUZGTEV0QlFVc3NSVUZCUlN4RFFVRkRMRU5CUVVNN1UwRkRlRVU3VVVGRlJDeEpRVUZKTEVOQlFVTXNNa0pCUVZrc1EwRkJReXhUUVVGVExFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1NVRkJTU3hyUWtGQmEwSXNTVUZCU1N4RFFVRkRMRVZCUVVVN1dVRkRlRVVzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc05rTkJRVFpETEVWQlFVVXNSVUZCUlN4clFrRkJhMElzUlVGQlJTeERRVUZETEVOQlFVTTdVMEZEYkVjN1VVRkZSQ3hKUVVGSkxFTkJRVU1zZVVKQlFWY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1UwRkJVeXhGUVVGRkxHMUNRVUZSTEVOQlFVTXNSVUZCUlR0WlFVTXpReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4cFJFRkJhVVFzUTBGQlF5eERRVUZETzFOQlF6bEZPMUZCUlVRc1RVRkJUU3h0UWtGQmJVSXNSMEZCUnl4alFVRmpMRWxCUVVrc1JVRkJSU3hEUVVGRE8xRkJRMnBFTEVsQlFVa3NNa0pCUVZrc1EwRkJReXhQUVVGUExFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1UwRkJVeXhEUVVGRExFVkJRVVU3V1VGRGNrUXNiVUpCUVcxQ0xFTkJRVU1zVTBGQlV5eEhRVUZITEV0QlFVc3NRMEZCUXp0VFFVTjZRenRSUVVWRUxFbEJRVWtzYlVKQlFXMUNMRU5CUVVNc1UwRkJVeXhMUVVGTExFdEJRVXNzU1VGQlNTeERRVUZETEU5QlFVOHNiVUpCUVcxQ0xFTkJRVU1zVTBGQlV5eExRVUZMTEZWQlFWVXNTVUZCU1N4RFFVRkRMRzFDUVVGdFFpeERRVUZETEZOQlFWTXNSVUZCUlN4RFFVRkRMRVZCUVVVN1dVRkRkRWtzVFVGQlRTeFpRVUZaTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETzFsQlJUbEVMRWxCUVVrc1dVRkJXU3hGUVVGRk8yZENRVU5rTEUxQlFVMHNiMEpCUVc5Q0xFZEJRVWNzVFVGQlRTeEpRVUZKTEVOQlFVTXNXVUZCV1N4RFFVRkRMRmRCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eEZRVUZGTEV0QlFVc3NSVUZCUlN4clFrRkJhMElzUlVGQlJTeFRRVUZUTEVWQlFVVXNVMEZCVXl4RlFVRkZMR1ZCUVdVc1EwRkJReXhEUVVGRE8yZENRVVY2U3l4SlFVRkpMREpDUVVGWkxFTkJRVU1zVTBGQlV5eERRVUZETEcxQ1FVRnRRaXhEUVVGRExFdEJRVXNzUTBGQlF5eEZRVUZGTzI5Q1FVTnVSQ3hQUVVGUExFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJReXhOUVVGTkxFTkJRM0pETEV0QlFVc3NTVUZCU1N4RlFVRkZMRU5CUVVNc1NVRkJTU3hEUVVGRExHdENRVUZyUWl4RFFVRkRMR1ZCUVdVc1JVRkJSU3hMUVVGTExFVkJRVVVzYTBKQlFXdENMRVZCUVVVc1UwRkJVeXhGUVVGRkxHMUNRVUZ0UWl4RFFVRkRMRVZCUXk5SExHMUNRVUZ0UWl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8ybENRVU5zUXp0eFFrRkJUVHR2UWtGRFNDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXcwUTBGQk5FTXNSVUZCUlN4dlFrRkJiMElzUTBGQlF5eERRVUZETzI5Q1FVTjBSaXhQUVVGUExHOUNRVUZ2UWl4RFFVRkRPMmxDUVVNdlFqdGhRVU5LTzJsQ1FVRk5PMmRDUVVOSUxFMUJRVTBzU1VGQlNTdzJRa0ZCWVN4RFFVRkRMQ3RDUVVFclFpeERRVUZETEVOQlFVTTdZVUZETlVRN1UwRkRTanRoUVVGTk8xbEJRMGdzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc05FTkJRVFJETEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1dVRkRNMFVzVDBGQlR5eFRRVUZUTEVOQlFVTTdVMEZEY0VJN1NVRkRUQ3hEUVVGRE8wbEJSVVE3T3pzN08wOUJTMGM3U1VGRFNTeExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMR1ZCUVhGQ08xRkJRM2hETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExHMURRVUZ0UXl4RlFVRkZMR1ZCUVdVc1EwRkJReXhEUVVGRE8xRkJSWGhGTEVsQlFVa3NRMEZCUXl3eVFrRkJXU3hEUVVGRExFMUJRVTBzUTBGQlF5eGxRVUZsTEVWQlFVVXNWMEZCU1N4RFFVRkRMRVZCUVVVN1dVRkROME1zVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2IwUkJRVzlFTEVOQlFVTXNRMEZCUXp0VFFVTnFSanRSUVVWRUxFMUJRVTBzV1VGQldTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMR05CUVdNc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF6dFJRVVZvUlN4TlFVRk5MRTFCUVUwc1IwRkJSeXhKUVVGSkxHVkJRVTBzUlVGQlJTeERRVUZETzFGQlF6VkNMRTFCUVUwc1EwRkJReXhaUVVGWkxFZEJRVWNzV1VGQldTeERRVUZETzFGQlJXNURMRTFCUVUwc1QwRkJUeXhIUVVGSExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJSVGRETEVsQlFVa3NRMEZCUXl4UFFVRlBMRVZCUVVVN1dVRkRWaXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl4NVFrRkJlVUlzUTBGQlF5eERRVUZETzFOQlEzUkVPMUZCUlVRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNiVU5CUVcxRExFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdVVUZETDBRc1QwRkJUeXhOUVVGTkxFTkJRVU03U1VGRGJFSXNRMEZCUXp0SlFVVkVPenM3T3pzN1QwRk5SenRKUVVOSkxFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTXNaMEpCUVhOQ0xFVkJRVVVzVlVGQmFVSTdVVUZEYWtVc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNkME5CUVhkRExFVkJRVVVzWjBKQlFXZENMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03VVVGRk1VWXNTVUZCU1N4RFFVRkRMREpDUVVGWkxFTkJRVU1zVFVGQlRTeERRVUZETEdkQ1FVRm5RaXhGUVVGRkxGZEJRVWtzUTBGQlF5eEZRVUZGTzFsQlF6bERMRTFCUVUwc1NVRkJTU3cyUWtGQllTeERRVUZETEhGRVFVRnhSQ3hEUVVGRExFTkJRVU03VTBGRGJFWTdVVUZGUkN4TlFVRk5MSEZDUVVGeFFpeEhRVUZyUWl4RlFVRkZMRU5CUVVNN1VVRkRhRVFzU1VGQlNTeHRRa0ZCYlVJc1IwRkJSeXhuUWtGQlowSXNRMEZCUXp0UlFVTXpReXhKUVVGSkxHRkJRV0VzUjBGQlJ5eFZRVUZWTEVOQlFVTTdVVUZGTDBJc1IwRkJSenRaUVVORExFMUJRVTBzWjBKQlFXZENMRWRCUVhOQ08yZENRVU40UXl4TlFVRk5MRVZCUVVVc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dGhRVU4wUkN4RFFVRkRPMWxCUlVZc1RVRkJUU3hwUWtGQmFVSXNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU03V1VGRE5VVXNUVUZCVFN4TlFVRk5MRWRCUVVjc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4cFFrRkJhVUlzUTBGQlF6dG5Ra0ZEZGtNc1EwRkJReXd5UWtGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eE5RVUZOTEVOQlFVTTdaMEpCUXk5RExHbENRVUZwUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF6dFpRVVU1Uml4SlFVRkpMREpDUVVGWkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4RlFVRkZPMmRDUVVNNVFpeE5RVUZOTEVsQlFVa3NOa0pCUVdFc1EwRkJReXhwUTBGQmFVTXNRMEZCUXl4RFFVRkRPMkZCUXpsRU8ybENRVUZOTzJkQ1FVTklMRTFCUVUwc2FVSkJRV2xDTEVkQlFVY3NlVUpCUVZjc1EwRkJReXhWUVVGVkxFTkJRVU1zWlVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVVUxUlN3MlJFRkJOa1E3WjBKQlF6ZEVMRTFCUVUwc1QwRkJUeXhIUVVGSExFTkJRVU1zTWtKQlFWa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1lVRkJZU3hEUVVGRExFTkJRVU03WjBKQlEzSkVMRWxCUVVrc1EwRkJReXhQUVVGUExFbEJRVWtzYVVKQlFXbENMRU5CUVVNc1dVRkJXU3hEUVVGRExGRkJRVkVzUlVGQlJTeExRVUZMTEVOQlFVTXNSVUZCUlR0dlFrRkROMFFzVFVGQlRTeEpRVUZKTERaQ1FVRmhMRU5CUVVNc2JVTkJRVzFETEVOQlFVTXNRMEZCUXp0cFFrRkRhRVU3WjBKQlJVUXNLMEpCUVN0Q08yZENRVU12UWl4TlFVRk5MR1ZCUVdVc1IwRkJSeXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNUVUZCVFN4RFFVRkRPMmRDUVVVelJTeHRRa0ZCYlVJc1IwRkJSeXhUUVVGVExFTkJRVU03WjBKQlEyaERMR0ZCUVdFc1IwRkJSeXhUUVVGVExFTkJRVU03WjBKQlJURkNMQ3RDUVVFclFqdG5Ra0ZETDBJc1NVRkJTU3hsUVVGbExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRXRCUVVzc2FVSkJRV2xDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeEZRVUZGTzI5Q1FVTXhSaXh0UTBGQmJVTTdiMEpCUTI1RExIRkNRVUZ4UWl4RFFVRkRMRWxCUVVrc1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4RFFVRkRPMjlDUVVVNVF5eDVRMEZCZVVNN2IwSkJRM3BETEVsQlFVa3NhVUpCUVdsQ0xFTkJRVU1zVTBGQlV5eERRVUZETEZGQlFWRXNSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hwUWtGQmFVSXNRMEZCUXl4WlFVRlpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFdEJRVXNzUTBGQlF5eEZRVUZGTzNkQ1FVTnFSeXh0UWtGQmJVSXNSMEZCUnl4cFFrRkJhVUlzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJRenQzUWtGRGVrUXNZVUZCWVN4SFFVRkhMR1ZCUVdVc1EwRkJRenR4UWtGRGJrTTdhVUpCUTBvN1lVRkRTanRUUVVOS0xGRkJRVkVzYlVKQlFXMUNMRXRCUVVzc1UwRkJVeXhGUVVGRk8xRkJSVFZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExIZERRVUYzUXl4RlFVRkZMSEZDUVVGeFFpeERRVUZETEVOQlFVTTdVVUZEYmtZc1QwRkJUeXh4UWtGQmNVSXNRMEZCUXp0SlFVTnFReXhEUVVGRE8wbEJSVVE3T3pzN096dFBRVTFITzBsQlEwa3NTMEZCU3l4RFFVRkRMR05CUVdNc1EwRkJReXhsUVVGeFFpeEZRVUZGTEV0QlFXRXNSVUZCUlN4clFrRkJNRUk3VVVGRGVFWXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zZDBOQlFYZERMRVZCUVVVc1pVRkJaU3hGUVVGRkxFdEJRVXNzUlVGQlJTeHJRa0ZCYTBJc1EwRkJReXhEUVVGRE8xRkJSWGhITEUxQlFVMHNUVUZCVFN4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0UlFVVnlSQ3hOUVVGTkxFTkJRVU1zV1VGQldTeEhRVUZITEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU03VVVGRmNFUXNUVUZCVFN4M1FrRkJkMElzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RlFVRkZMR3RDUVVGclFpeERRVUZETEVOQlFVTTdVVUZEYUVjc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNkME5CUVhkRExFVkJRVVVzZDBKQlFYZENMRU5CUVVNc1EwRkJRenRSUVVOMFJpeFBRVUZQTEhkQ1FVRjNRaXhEUVVGRE8wbEJRM0JETEVOQlFVTTdTVUZGUkRzN096dFBRVWxITzBsQlEwa3NTMEZCU3l4RFFVRkRMR2xDUVVGcFFpeERRVUZETEdWQlFYRkNPMUZCUTJoRUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMREpEUVVFeVF5eEZRVUZGTEdWQlFXVXNRMEZCUXl4RFFVRkRPMUZCUldoR0xFMUJRVTBzVFVGQlRTeEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF6dFJRVVZ5UkN4TlFVRk5MRFJDUVVFMFFpeEhRVUZyUXp0WlFVTm9SU3hOUVVGTkxFVkJRVVVzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdVMEZETlVVc1EwRkJRenRSUVVWR0xFMUJRVTBzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4eFFrRkJjVUlzUTBGQlF5dzBRa0ZCTkVJc1EwRkJReXhEUVVGRE8xRkJSVEZGTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExESkRRVUV5UXl4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJSWFpGTEU5QlFVOHNUVUZCVFN4RFFVRkRPMGxCUTJ4Q0xFTkJRVU03U1VGRlJEczdPenM3T3p0UFFVOUhPMGxCUTBrc1MwRkJTeXhEUVVGRExITkNRVUZ6UWl4RFFVRkRMRTlCUVdkQ0xFVkJRVVVzVTBGQmNVSXNSVUZCUlN4SlFVRlpMRVZCUVVVc1UwRkJhMEk3VVVGRGVrY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zWjBSQlFXZEVMRVZCUVVVc1QwRkJUeXhGUVVGRkxGTkJRVk1zUlVGQlJTeEpRVUZKTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1VVRkZla2NzVFVGQlRTeFpRVUZaTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUMEZCVHl4RlFVRkZMRk5CUVZNc1JVRkJSU3hKUVVGSkxFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTTdVVUZEZEVZc1NVRkJTU3haUVVGWkxFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTjZRaXhOUVVGTkxFbEJRVWtzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4elFrRkJjMElzUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXp0WlFVTTNSQ3hKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4blJFRkJaMFFzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTXhSU3hQUVVGUExFbEJRVWtzUTBGQlF6dFRRVU5tTzJGQlFVMDdXVUZEU0N4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eG5SRUZCWjBRc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFpRVU40UlN4UFFVRlBMRVZCUVVVc1EwRkJRenRUUVVOaU8wbEJRMHdzUTBGQlF6dEpRVVZFT3pzN096czdPenM3TzA5QlZVYzdTVUZEU1N4TFFVRkxMRU5CUVVNc1dVRkJXU3hEUVVGRExFbEJRVlVzUlVGQlJTeFZRVUZ0UWl4RlFVRkZMRkZCUVdsQ0xFVkJRVVVzVVVGQk1FSXNSVUZCUlN4bFFVRjVRanRSUVVNdlNDeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXh6UTBGQmMwTXNSVUZCUlN4SlFVRkpMRVZCUVVVc1ZVRkJWU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFJRVUZSTEVWQlFVVXNaVUZCWlN4RFFVRkRMRU5CUVVNN1VVRkZha2dzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUlVGQlJTeFhRVUZKTEVOQlFVTXNSVUZCUlR0WlFVTnNReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl3clFrRkJLMElzUTBGQlF5eERRVUZETzFOQlF6VkVPMUZCUTBRc1NVRkJTU3hsUVVGbExFZEJRVWNzVlVGQlZTeERRVUZETzFGQlEycERMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1JVRkJSVHRaUVVNeFF5eGxRVUZsTEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUTNaQ08xRkJSVVFzVFVGQlRTeFRRVUZUTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFbEJRVWtzUlVGQlJTeGxRVUZsTEVWQlFVVXNVVUZCVVN4RlFVRkZMRXRCUVVzc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVVUzUml4TlFVRk5MRTlCUVU4c1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eHZRa0ZCYjBJc1EwRkJReXhUUVVGVExFVkJRVVVzWlVGQlpTeERRVUZETEVOQlFVTTdVVUZETlVVc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNjME5CUVhORExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEYmtVc1QwRkJUeXhQUVVGUExFTkJRVU03U1VGRGJrSXNRMEZCUXp0SlFVVkVPenM3T3pzN08wOUJUMGM3U1VGRFNTeExRVUZMTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWxCUVZVc1JVRkJSU3hWUVVGdFFpeEZRVUZGTEZGQlFXbENMRVZCUVVVc1VVRkJNRUk3VVVGRGRFY3NTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zZDBOQlFYZERMRVZCUVVVc1NVRkJTU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNN1VVRkZiRWNzU1VGQlNTeERRVUZETERKQ1FVRlpMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUlVGQlJTeFhRVUZKTEVOQlFVTXNSVUZCUlR0WlFVTnNReXhOUVVGTkxFbEJRVWtzTmtKQlFXRXNRMEZCUXl3clFrRkJLMElzUTBGQlF5eERRVUZETzFOQlF6VkVPMUZCUTBRc1NVRkJTU3hsUVVGbExFZEJRVWNzVlVGQlZTeERRVUZETzFGQlEycERMRWxCUVVrc1EwRkJReXd5UWtGQldTeERRVUZETEZOQlFWTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1JVRkJSVHRaUVVNeFF5eGxRVUZsTEVkQlFVY3NRMEZCUXl4RFFVRkRPMU5CUTNaQ08xRkJSVVFzVFVGQlRTeFRRVUZUTEVkQlFVY3NUVUZCVFN4SlFVRkpMRU5CUVVNc1lVRkJZU3hEUVVGRExFbEJRVWtzUlVGQlJTeGxRVUZsTEVWQlFVVXNVVUZCVVN4RlFVRkZMRXRCUVVzc1JVRkJSU3hSUVVGUkxFbEJRVWtzYVVOQlFXVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVWMlNDeE5RVUZOTEU5QlFVOHNSMEZCUnl4TlFVRk5MRWxCUVVrc1EwRkJReXh2UWtGQmIwSXNRMEZCUXl4VFFVRlRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRmFrVXNUVUZCVFN4WFFVRlhMRWRCUVdkQ08xbEJRemRDTEdGQlFXRXNSVUZCUlN4VFFVRlRMRU5CUVVNc1IwRkJSeXhGUVVGRk8xbEJRemxDTEZOQlFWTTdXVUZEVkN4VFFVRlRMRVZCUVVVc1QwRkJUenRaUVVOc1FpeE5RVUZOTEVWQlFVVXNSVUZCUlR0WlFVTldMRTlCUVU4c1JVRkJSU3hEUVVGRE8xTkJRMklzUTBGQlF6dFJRVVZHTEUxQlFVMHNZMEZCWXl4SFFVRjNRanRaUVVONFF5eFRRVUZUTEVWQlFVVXNWMEZCVnl4RFFVRkRMRk5CUVZNc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTTdXVUZEZEVVc1UwRkJVeXhGUVVGRkxFZEJRVWM3VTBGRGFrSXNRMEZCUXp0UlFVVkdMRTFCUVUwc1pVRkJaU3hIUVVGSExFMUJRVTBzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4WFFVRlhMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU03VVVGRk1VVXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEdWQlFXVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlEzUkVMRTFCUVUwc1QwRkJUeXhIUVVGSExGRkJRVkVzUTBGQlF5eGxRVUZsTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETzFsQlF6RkVMRWxCUVVrc1QwRkJUeXhIUVVGSExFTkJRVU1zUlVGQlJUdG5Ra0ZEWWl4WFFVRlhMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eGhRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRmRCUVZjc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNVVUZCVVN4SlFVRkpMR2xEUVVGbExFTkJRVU1zVFVGQlRTeEZRVUZGTEdWQlFXVXNSMEZCUnl4RFFVRkRMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVrc1YwRkJWeXhEUVVGRExFOUJRVThzU1VGQlNTeFBRVUZQTEVOQlFVTTdZVUZEYkVNN1UwRkRTanRSUVVWRUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMSGREUVVGM1F5eEZRVUZGTEZkQlFWY3NRMEZCUXl4RFFVRkRPMUZCUTNwRkxFOUJRVThzVjBGQlZ5eERRVUZETzBsQlEzWkNMRU5CUVVNN1NVRkZSQ3hsUVVGbE8wbEJRMUFzUzBGQlN5eERRVUZETEc5Q1FVRnZRaXhEUVVGRExGTkJRVzlDTEVWQlFVVXNaVUZCZDBJN1VVRkROMFVzVFVGQlRTeHJRa0ZCYTBJc1IwRkJSeXhOUVVGTkxFbEJRVWtzUTBGQlF5eHpRa0ZCYzBJc1EwRkJReXhUUVVGVExFVkJRVVVzVTBGQlV5eEZRVUZGTEZOQlFWTXNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVWNlJ5d3lRa0ZCTWtJN1VVRkRNMElzVFVGQlRTeG5Ra0ZCWjBJc1IwRkJSeXhKUVVGSkxFZEJRVWNzUlVGQlZTeERRVUZETzFGQlF6TkRMRTFCUVUwc2JVSkJRVzFDTEVkQlFVY3NTVUZCU1N4SFFVRkhMRVZCUVZVc1EwRkJRenRSUVVVNVF5eHJRa0ZCYTBJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFhRVUZYTEVWQlFVVXNSVUZCUlR0WlFVTjJReXg1UWtGQmVVSTdXVUZEZWtJc1NVRkJTU3hYUVVGWExFTkJRVU1zV1VGQldTeERRVUZETEZGQlFWRXNSVUZCUlN4TFFVRkxMRU5CUVVNc1JVRkJSVHRuUWtGRE0wTXNaMEpCUVdkQ0xFTkJRVU1zUjBGQlJ5eERRVUZETEhGRFFVRnBRaXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF5eERRVUZETzJGQlEyNUdPMmxDUVVGTk8yZENRVU5JTEcxQ1FVRnRRaXhEUVVGRExFZEJRVWNzUTBGQlF5eFhRVUZYTEVOQlFVTXNUVUZCVFN4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdZVUZEY2tVN1VVRkRUQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVVZJTEVsQlFVa3NiVUpCUVcxQ0xFTkJRVU1zU1VGQlNTeEhRVUZITEVOQlFVTXNSVUZCUlR0WlFVTTVRaXhOUVVGTkxIbENRVUY1UWl4SFFVRkhMRTFCUVUwc1NVRkJTU3hEUVVGRExITkNRVUZ6UWl4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zYlVKQlFXMUNMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4WFFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExHVkJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRk0wb3NlVUpCUVhsQ0xFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNWMEZCVnl4RlFVRkZMRVZCUVVVN1owSkJRemxETEVsQlFVa3NWMEZCVnl4RFFVRkRMRmxCUVZrc1EwRkJReXhSUVVGUkxFVkJRVVVzUzBGQlN5eERRVUZETEVWQlFVVTdiMEpCUXpORExHZENRVUZuUWl4RFFVRkRMRWRCUVVjc1EwRkJReXh4UTBGQmFVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1EwRkJRenRwUWtGRGJrWTdXVUZEVEN4RFFVRkRMRU5CUVVNc1EwRkJRenRUUVVOT08xRkJSVVFzVFVGQlRTeFpRVUZaTEVkQlFXRXNSVUZCUlN4RFFVRkRPMUZCUTJ4RExFMUJRVTBzVjBGQlZ5eEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXp0UlFVVnFSQ3hyUkVGQmEwUTdVVUZEYkVRc2FVUkJRV2xFTzFGQlEycEVMRWxCUVVrc1dVRkJXU3hEUVVGRE8xRkJRMnBDTEVsQlFVa3NaVUZCWlN4RlFVRkZPMWxCUTJwQ0xGbEJRVmtzUjBGQlJ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4clFrRkJhMElzUTBGQlF5eFhRVUZYTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zVjBGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4bFFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTI1SU8xRkJSVVFzYzBSQlFYTkVPMUZCUTNSRUxHOUZRVUZ2UlR0UlFVTndSU3hMUVVGTExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1YwRkJWeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETEVWQlFVVXNSVUZCUlR0WlFVTjZReXhOUVVGTkxFMUJRVTBzUjBGQlZ5eE5RVUZOTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1YwRkJTU3hEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZOTEVOQlFVTXNWVUZCVlN4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVVm9SeXhOUVVGTkxFTkJRVU1zWTBGQll5eEhRVUZITEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4VFFVRlRMRU5CUVVNN1dVRkRia1VzV1VGQldTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRUUVVNM1FqdFJRVVZFTERSQ1FVRTBRanRSUVVNMVFpeFpRVUZaTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTzFsQlEzWkNMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc2JVSkJRVzFDTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1dVRkRNMFFzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eHRRa0ZCYlVJc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFpRVU16UkN4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkZTQ3hQUVVGUExGbEJRVmtzUTBGQlF6dEpRVU40UWl4RFFVRkRPMGxCUlVRc1pVRkJaVHRKUVVOUUxHVkJRV1VzUTBGQlF5eEpRVUZWTEVWQlFVVXNTMEZCWVN4RlFVRkZMRkZCUVhsQ0xFVkJRVVVzWlVGQmQwSTdVVUZEYkVjc1RVRkJUU3hIUVVGSExFZEJRVWNzVTBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4SlFVRkpMRVZCUVVVc1MwRkJTeXhGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzFGQlF6TkRMRTFCUVUwc1QwRkJUeXhIUVVGSExGTkJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRha01zVFVGQlRTeFpRVUZaTEVkQlFVY3NVMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU14UXl4SlFVRkpMRzFDUVVGdFFpeEhRVUZITEdGQlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNN1VVRkZPVVVzU1VGQlNTeGxRVUZsTEVWQlFVVTdXVUZEYWtJc2JVSkJRVzFDTEVsQlFVa3NOa0pCUVdFc1EwRkJReXhqUVVGakxFTkJRVU1zV1VGQldTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMU5CUTNoRk8xRkJSVVFzVDBGQlR5eHBRa0ZCVHl4RFFVRkRMRlZCUVZVc1EwRkJReXhsUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEcxQ1FVRnRRaXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU4wUlN4RFFVRkRPMGxCUlVRc1pVRkJaVHRKUVVOUUxFdEJRVXNzUTBGQlF5eFpRVUZaTEVOQlFVTXNTVUZCVlN4RlFVRkZMRTFCUVdNc1JVRkJSU3hsUVVGblF5eEZRVUZGTEUxQlFXVXNSVUZETjBVc2VVSkJRWEZFTEVWQlFVVXNWVUZCYTBJc1JVRkJSU3hIUVVGUkxFVkJRVVVzVTBGQmEwSTdVVUZGT1Vnc1NVRkJTU3hyUWtGQmEwSXNSMEZCUnl4VlFVRlZMRU5CUVVNN1VVRkRjRU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1EwRkJReXhIUVVGSExFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXl4RlFVRkZMRVZCUVVVN1dVRkRjRU1zVFVGQlRTeFRRVUZUTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEZsQlFWa3NSVUZCUlN4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJSWFJGTERSQ1FVRTBRanRaUVVNMVFpeE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFVkJRVVVzUjBGQlJ5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPMWxCUld4SExHZERRVUZuUXp0WlFVTm9ReXc0UTBGQk9FTTdXVUZET1VNc1NVRkJTU3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4SlFVRkpMR3RDUVVGclFpeEZRVUZGTzJkQ1FVTjZReXhOUVVGTkxGTkJRVk1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhIUVVGSExHdENRVUZyUWl4RFFVRkRPMmRDUVVWNlJDd3lSVUZCTWtVN1owSkJRek5GTEVsQlFVa3NVMEZCVXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExESkNRVUZaTEVOQlFVTXNUMEZCVHl4RFFVRkRMR1ZCUVdVc1EwRkJReXhKUVVGSkxESkNRVUZaTEVOQlFVTXNUVUZCVFN4RFFVRkRMR1ZCUVdVc1EwRkJReXhuUWtGQlowSXNSVUZCUlN4cFFrRkJUeXhEUVVGRExFVkJRVVU3YjBKQlF6TklMSGxDUVVGNVFqdHZRa0ZEZWtJc1RVRkJUU3hEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETEVWQlFVVXNaVUZCWlN4RFFVRkRMR2RDUVVGblFpeEZRVUZGTEZOQlFWTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1UwRkJVeXhEUVVGRExFTkJRVU03YjBKQlEzWkdMRzlEUVVGdlF6dHZRa0ZEY0VNc01rSkJRVmtzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTFCUVUwc1JVRkJSU3hsUVVGbExFVkJRVVVzZVVKQlFYbENMRVZCUVVVc1RVRkJUU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzJsQ1FVTjRSenR4UWtGQlRTeEpRVUZKTEZOQlFWTXNSMEZCUnl4RFFVRkRMRVZCUVVVN2IwSkJRM1JDTEVsQlFVa3NWVUZCVlN4SFFVRkhMRU5CUVVNc1EwRkJRenR2UWtGRGJrSXNTMEZCU3l4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZITEUxQlFVMHNRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVU3ZDBKQlEzQkRMRlZCUVZVc1IwRkJSeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzVlVGQlZTeERRVUZETEVOQlFVTTdjVUpCUTNwRU8yOUNRVVZFTEZWQlFWVXNSVUZCUlN4RFFVRkRPMjlDUVVWaUxFMUJRVTBzVTBGQlV5eEhRVUZITEUxQlFVMHNTVUZCU1N4RFFVRkRMRzlDUVVGdlFpeERRVUZETEVsQlFVa3NSVUZCUlN4VlFVRlZMRVZCUVVVc1MwRkJTeXhGUVVGRkxHVkJRV1VzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0dlFrRkZja2NzVFVGQlRTeEZRVUZGTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEZsQlFWa3NSVUZCUlN4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRE8yOUNRVVV2UkN4NVFrRkJlVUk3YjBKQlEzcENMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eEZRVUZGTEZOQlFWTXNRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eEZRVUZGTEZOQlFWTXNSVUZCUlN4SFFVRkhMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03YjBKQlJTOUZMRzlEUVVGdlF6dHZRa0ZEY0VNc01rSkJRVmtzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTFCUVUwc1JVRkJSU3hsUVVGbExFVkJRVVVzZVVKQlFYbENMRVZCUVVVc1RVRkJUU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzJsQ1FVTjRSenR4UWtGQlRUdHZRa0ZEU0N3MlJFRkJOa1E3YjBKQlF6ZEVMSGxDUVVGNVFqdHZRa0ZEZWtJc01rSkJRVmtzUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTFCUVUwc1JVRkJSU3hsUVVGbExFVkJRVVVzZVVKQlFYbENMRVZCUVVVc1RVRkJUU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzJsQ1FVTjRSenRoUVVOS08ybENRVUZOTzJkQ1FVTklMR3RGUVVGclJUdG5Ra0ZEYkVVc2NVSkJRWEZDTzJkQ1FVTnlRaXhyUWtGQmEwSXNTVUZCU1N4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETzJGQlF6TkRPMU5CUTBvN1NVRkRUQ3hEUVVGRE96dEJRV3hxUTBRc1pVRkJaVHRCUVVOVExHdERRVUZuUWl4SFFVRlhMRWRCUVVjc1EwRkJReXhOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdRVUZGYmtVc1pVRkJaVHRCUVVOVExEUkNRVUZWTEVkQlFWY3NSMEZCUnl4RFFVRkRPMEZCVEhKRUxEaERRVzlxUTBNaWZRPT0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcInJlZ2VuZXJhdG9yUnVudGltZVwiKSA+PSAwO1xuXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG5cbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5cbmlmIChoYWRSdW50aW1lKSB7XG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcbn0gZWxzZSB7XG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXG4gIHRyeSB7XG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xuICB9IGNhdGNoKGUpIHtcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=